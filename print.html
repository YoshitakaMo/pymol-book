<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>pymol-book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">TOP</a></li><li class="chapter-item expanded "><a href="ch01/index.html"><strong aria-hidden="true">1.</strong> 第1章 PyMOL チュートリアル: アルカリホスファターゼの構造を見る</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01/objective.html"><strong aria-hidden="true">1.1.</strong> 目的</a></li><li class="chapter-item expanded "><a href="ch01/accesspdb.html"><strong aria-hidden="true">1.2.</strong> Protein Data Bank (PDB)にアクセスする</a></li><li class="chapter-item expanded "><a href="ch01/download.html"><strong aria-hidden="true">1.3.</strong> PDB データのダウンロード</a></li><li class="chapter-item expanded "><a href="ch01/launchpymol.html"><strong aria-hidden="true">1.4.</strong> PyMOL の起動</a></li><li class="chapter-item expanded "><a href="ch01/displaypdb.html"><strong aria-hidden="true">1.5.</strong> 大腸菌由来アルカリホスファターゼのグラフィック表示</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01/colorbychain.html"><strong aria-hidden="true">1.5.1.</strong> チェインごとの色分け</a></li><li class="chapter-item expanded "><a href="ch01/colorbyss.html"><strong aria-hidden="true">1.5.2.</strong> 二次構造ごとの色分け</a></li><li class="chapter-item expanded "><a href="ch01/saveimage.html"><strong aria-hidden="true">1.5.3.</strong> 画像の保存</a></li><li class="chapter-item expanded "><a href="ch01/savesessionfile.html"><strong aria-hidden="true">1.5.4.</strong> セッションファイルへの保存</a></li><li class="chapter-item expanded "><a href="ch01/focusbindingsite.html"><strong aria-hidden="true">1.5.5.</strong> リガンド結合部位への注目</a></li></ol></li><li class="chapter-item expanded "><a href="ch01/humanalp.html"><strong aria-hidden="true">1.6.</strong> ヒトアルカリホスファターゼとの構造比較</a></li><li class="chapter-item expanded "><a href="ch01/hydrophobicity.html"><strong aria-hidden="true">1.7.</strong> タンパク質の疎水性・親水性残基の分布を確認する</a></li><li class="chapter-item expanded "><a href="ch01/conservation.html"><strong aria-hidden="true">1.8.</strong> タンパク質の位置依存的なアミノ酸保存度の違いを理解する</a></li><li class="chapter-item expanded "><a href="ch01/qmmm.html"><strong aria-hidden="true">1.9.</strong> アルカリホスファターゼの加水分解酵素としての働き</a></li></ol></li><li class="chapter-item expanded "><a href="ch02/index.html"><strong aria-hidden="true">2.</strong> 第2章 Internal GUI の使い方</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02/loadmol.html"><strong aria-hidden="true">2.1.</strong> 分子構造のロード</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02/load_file.html"><strong aria-hidden="true">2.1.1.</strong> 構造ファイルのロード</a></li><li class="chapter-item expanded "><a href="ch02/load_supformat.html"><strong aria-hidden="true">2.1.2.</strong> サポートしている構造ファイル形式</a></li><li class="chapter-item expanded "><a href="ch02/load_biol_unit.html"><strong aria-hidden="true">2.1.3.</strong> Biological Unitを考慮した分子構造のロード</a></li></ol></li><li class="chapter-item expanded "><a href="ch02/dispseq.html"><strong aria-hidden="true">2.2.</strong> 配列の表示</a></li><li class="chapter-item expanded "><a href="ch02/objpanel.html"><strong aria-hidden="true">2.3.</strong> オブジェクトパネル</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02/showandhide.html"><strong aria-hidden="true">2.3.1.</strong> 分子構造の表示形式のON/OFF (Show and Hide)</a></li><li class="chapter-item expanded "><a href="ch02/label.html"><strong aria-hidden="true">2.3.2.</strong> ラベルの設定(Label)</a></li><li class="chapter-item expanded "><a href="ch02/color.html"><strong aria-hidden="true">2.3.3.</strong> 色の設定(Color)</a></li></ol></li><li class="chapter-item expanded "><a href="ch02/mouse.html"><strong aria-hidden="true">2.4.</strong> マウス操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02/buttonmode.html"><strong aria-hidden="true">2.4.1.</strong> 操作モード</a></li><li class="chapter-item expanded "><a href="ch02/buttontable.html"><strong aria-hidden="true">2.4.2.</strong> 各モードにおける操作一覧</a></li><li class="chapter-item expanded "><a href="ch02/buttonaction.html"><strong aria-hidden="true">2.4.3.</strong> 操作の詳細</a></li></ol></li><li class="chapter-item expanded "><a href="ch02/session.html"><strong aria-hidden="true">2.5.</strong> セッションの保存</a></li><li class="chapter-item expanded "><a href="ch02/export.html"><strong aria-hidden="true">2.6.</strong> 構造ファイルのエクスポート</a></li><li class="chapter-item expanded "><a href="ch02/saveimage.html"><strong aria-hidden="true">2.7.</strong> 画像の保存</a></li></ol></li><li class="chapter-item expanded "><a href="ch03/index.html"><strong aria-hidden="true">3.</strong> 第3章 External GUIの使い方</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03/file.html"><strong aria-hidden="true">3.1.</strong> File</a></li><li class="chapter-item expanded "><a href="ch03/edit.html"><strong aria-hidden="true">3.2.</strong> Edit</a></li><li class="chapter-item expanded "><a href="ch03/build.html"><strong aria-hidden="true">3.3.</strong> Build</a></li><li class="chapter-item expanded "><a href="ch03/movie.html"><strong aria-hidden="true">3.4.</strong> Movie</a></li><li class="chapter-item expanded "><a href="ch03/display.html"><strong aria-hidden="true">3.5.</strong> Display</a></li><li class="chapter-item expanded "><a href="ch03/setting.html"><strong aria-hidden="true">3.6.</strong> Setting</a></li><li class="chapter-item expanded "><a href="ch03/scene.html"><strong aria-hidden="true">3.7.</strong> Scene</a></li><li class="chapter-item expanded "><a href="ch03/mouse.html"><strong aria-hidden="true">3.8.</strong> Mouse</a></li><li class="chapter-item expanded "><a href="ch03/wizard.html"><strong aria-hidden="true">3.9.</strong> Wizard</a></li><li class="chapter-item expanded "><a href="ch03/plugin.html"><strong aria-hidden="true">3.10.</strong> Plugin</a></li><li class="chapter-item expanded "><a href="ch03/help.html"><strong aria-hidden="true">3.11.</strong> help</a></li></ol></li><li class="chapter-item expanded "><a href="ch04/index.html"><strong aria-hidden="true">4.</strong> 第4章 コマンドラインの使い方</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04/cmd_load.html"><strong aria-hidden="true">4.1.</strong> 分子構造のロード</a></li><li class="chapter-item expanded "><a href="ch04/cmd_save.html"><strong aria-hidden="true">4.2.</strong> 保存</a></li><li class="chapter-item expanded "><a href="ch04/cmd_showandhide.html"><strong aria-hidden="true">4.3.</strong> 分子構造の表示形式のON/OFF</a></li><li class="chapter-item expanded "><a href="ch04/cmd_super.html"><strong aria-hidden="true">4.4.</strong> オブジェクトの重ね合わせ</a></li></ol></li><li class="chapter-item expanded "><a href="ch05/index.html"><strong aria-hidden="true">5.</strong> 第5章 PyMOL の様々な機能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05/xtal_elecmap.html"><strong aria-hidden="true">5.1.</strong> 結晶構造の電子密度マップを表示する</a></li><li class="chapter-item expanded "><a href="ch05/apbs.html"><strong aria-hidden="true">5.2.</strong> APBSプラグインを使った表面電荷表示</a></li><li class="chapter-item expanded "><a href="ch05/movieschool.html"><strong aria-hidden="true">5.3.</strong> 動画の作成方法</a></li><li class="chapter-item expanded "><a href="ch05/preset.html"><strong aria-hidden="true">5.4.</strong> 表示形式のプリセット</a></li><li class="chapter-item expanded "><a href="ch05/gaussian.html"><strong aria-hidden="true">5.5.</strong> Gaussian 16のcubeファイルを開いて分子軌道を表示する</a></li><li class="chapter-item expanded "><a href="ch05/python_on_pymol.html"><strong aria-hidden="true">5.6.</strong> PyMOL上でのpythonスクリプトの実行</a></li><li class="chapter-item expanded "><a href="ch05/importpymol.html"><strong aria-hidden="true">5.7.</strong> Pythonからpymolモジュールをimportして使う</a></li></ol></li><li class="chapter-item expanded "><a href="ch06/index.html"><strong aria-hidden="true">6.</strong> 第6章 プラグインを使う</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06/installation.html"><strong aria-hidden="true">6.1.</strong> プラグインのインストール方法</a></li><li class="chapter-item expanded "><a href="ch06/dssp.html"><strong aria-hidden="true">6.2.</strong> DSSPプラグイン</a></li><li class="chapter-item expanded "><a href="ch06/pyvol.html"><strong aria-hidden="true">6.3.</strong> PyVOL GUIプラグイン</a></li><li class="chapter-item expanded "><a href="ch06/plddt.html"><strong aria-hidden="true">6.4.</strong> pLDDTカラーリングプラグイン</a></li></ol></li><li class="chapter-item expanded "><a href="append01/index.html"><strong aria-hidden="true">7.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="append01/installation.html"><strong aria-hidden="true">7.1.</strong> インストール方法</a></li><li class="chapter-item expanded "><a href="append01/term.html"><strong aria-hidden="true">7.2.</strong> 用語</a></li><li class="chapter-item expanded "><a href="append01/selealgebra.html"><strong aria-hidden="true">7.3.</strong> 選択範囲の文法と演算子</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">pymol-book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pymol-tutorial"><a class="header" href="#pymol-tutorial">PyMOL Tutorial</a></h1>
<p>PyMOLの機能をまとめた本です。
(c) 2021 YoshitakaMo All Rights Reserved.</p>
<h2 id="はじめてpymolを使う方へ"><a class="header" href="#はじめてpymolを使う方へ">はじめてPyMOLを使う方へ</a></h2>
<ul>
<li>インストール方法については<a href="./append01/installation.html">7.1 インストール方法</a>を御覧ください。</li>
<li>PyMOLを使った分子の表示方法のやり方をまとめて知りたい場合は<a href="./ch01/index.html">第1章-pymolチュートリアル-アルカリホスファターゼの構造を見る</a>から順次御覧ください。</li>
<li>マウスの使い方を学びたい場合は以下のページからどうぞ。
<ul>
<li><a href="./ch02/loadmol.html">2.1 分子構造のロード</a></li>
<li><a href="./ch02/dispseq.html">2.2 配列の表示</a></li>
<li><a href="./ch02/objpanel.html">2.3 オブジェクトパネル</a></li>
<li><a href="./ch02/mouse.html">2.4 マウス操作</a></li>
</ul>
</li>
<li>PyMOL上部メニューの詳細を知りたい方は<a href="./ch03/index.html">第3章 External GUIの使い方</a>を参考にしてください。</li>
</ul>
<h2 id="change-log"><a class="header" href="#change-log">Change log</a></h2>
<p>2022年 5月 3日 <a href="./ch05/apbs.html">5.2 APBSプラグインを使った表面電荷表示</a>を更新。<br>
2021年12月13日 <a href="./ch06/plddt.html">6.4 pLDDTカラーリングプラグイン</a>を追加。<br>
2021年12月11日 <a href="./ch05/movieschool.html">5.3 動画の作成方法</a>を追加。<br>
2021年 5月 9日 <a href="./ch05/importpymol.html">Pythonからpymolモジュールをimportして使う</a>を追加。<br>
2021年 1月 5日 <a href="./ch03/display.html">3.5 Display</a>を順次追加。<br>
2020年 5月11日 <a href="./ch03/movie.html">3.4 Movie</a>を追加。<br>
2020年 5月 5日 <a href="./ch05/python_on_pymol.html">5.6 PyMOL上でのpythonスクリプトの実行</a>を追加。<br>
2020年 5月 3日 <a href="./ch01/hydrophobicity.html">1.7 タンパク質の疎水性・親水性残基の分布を確認する</a>を追加。<br>
2020年 5月 2日 <a href="./ch01/conservation.html">1.8 タンパク質の位置依存的なアミノ酸保存度の違いを理解する</a>を追加。<br>
2020年 4月12日 <a href="./append01/selealgebra.html">Appendix 3 選択範囲の文法と演算子</a>を追加。<br>
2019年12月7日 <a href="./ch02/color.html">2.3.3 色の設定</a>を追加。<br>
...<br>
2019年 3月30日 作成開始。</p>
<h2 id="contribution"><a class="header" href="#contribution">Contribution</a></h2>
<p>このtutorialは<a href="https://github.com/rust-lang-nursery/mdBook">mdbook</a>で運用しています.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="第1章-pymolチュートリアル-アルカリホスファターゼの構造を見る"><a class="header" href="#第1章-pymolチュートリアル-アルカリホスファターゼの構造を見る">第1章 PyMOLチュートリアル: アルカリホスファターゼの構造を見る</a></h1>
<h2 id="目的"><a class="header" href="#目的">目的</a></h2>
<p>酵素などのタンパク質は、それぞれ固有のアミノ酸配列をもち、それが固有の立体構造に折れたたまります。これにより、アミノ酸配列上では離れていた残基同士が接近し、それらが協同して他の分子と相互作用したり化学反応を触媒したりすることができるようになります。タンパク質を含む生体分子が機能を果たすためには、その立体構造が本質的に重要です。生体分子は、ナノメートル（\( 10^{-9}\ \rm{m} \)）オーダーの微小なものですが、X線結晶構造解析法やNMR法、最近ではクライオ電子顕微鏡などの手法を用いて、その立体構造（分子を構成している各原子の\( xyz \)座標）を決定することができます。それらの構造データは、公共の立体構造データベースに蓄積され、誰もが自由かつ無料で利用できるようになっています。コンピュータを用いると、これらの立体構造データにインターネットを介してアクセスし、さらに分子グラフィックスソフトウェアを用いてその構造を表示することが可能となります。</p>
<p>人間の肉眼では見えない生体分子をこのようにコンピュータ上で可視化することで、その機能に対する理解をいっそう深めることができます。ここでは練習として、加水分解酵素「<strong>アルカリホスファターゼ</strong>」のアミノ酸配列や立体構造に関するデータをデータベースから取得し、タンパク質の配列－構造－機能の関係を理解してみます。<strong>アルカリホスファターゼ</strong>は、我々の健康診断の時に肝臓の機能を測る指標（<strong>ALP</strong>）として、生活に関わっているタンパク質です。</p>
<p>それでは早速やっていきましょう。</p>
<h2 id="protein-data-bank-pdbにアクセスする"><a class="header" href="#protein-data-bank-pdbにアクセスする">Protein Data Bank (PDB)にアクセスする</a></h2>
<p>お使いのパソコンにインストールされているウェブブラウザ（Edge, Safari, Google Chrome, Firefoxなど）の検索エンジンに、「PDB」と入れて検索すると、<a href="https://www.rcsb.org/">RCSB PDB</a>のホームページが表示されます。</p>
<img src="ch01/./image/rcsbpdb1.png" width="70%">
<p>画面右上のボックスに「alkaline phosphatase」と入力し，ボックス右のGoボタンを押します。</p>
<img src="ch01/./image/rcsbpdb2.png" width="100%">
<p>メニュー左側に現れている「Refinements」の「ORGANISM」に表示されている「Escherichia coli」をクリックして検索ボタン（ルーペマーク）をクリックします。これで大腸菌由来の「alkaline phosphatase」に検索を絞り込むことができます。</p>
<img src="ch01/./image/rcsbpdb3.png" width="40%">
<p>右上の「Displaying 25 per page」の「25」を「100」に変更し，表示された結果の中から「1ALK」を探してクリックします（リストの一番下付近にあります）。</p>
<img src="ch01/./image/rcsbpdb4.png" width="100%">
<p>PDBの各エントリには、このように4文字の記号（<strong>PDB ID</strong>）が付けられています。なお、PDBのIDがあらかじめわかっている場合はテキストボックスにPDB IDを入れてGoボタンを押すことでも目的の構造のページに移動することができます。これによって、1ALKエントリの内容が表示されます。</p>
<img src="ch01/./image/rcsbpdb5.png" width="100%">
<p>最初のページには、このエントリのタイトル、登録日、由来する生物種や立体構造のグラフィックスなどが表示されています。さらに画面上方のタブをクリックすると、このタンパク質に関するさまざまなデータにアクセスできます。現在表示されているのは「Structure Summary」タブの内容です。</p>
<img src="ch01/./image/rcsbpdb6.png" width="100%">
<p>このStructure Summaryのタブのページで、以下のデータに注目してみましょう。</p>
<p>「<strong>Macromolecules</strong>」にはこのエントリのタンパク質の簡単な説明が記載されています。検索条件で指定したとおり、大腸菌（Escherichia coli）のアルカリホスファターゼであり、さらに分子量が94687.01であること、 449残基のアルカリホスファターゼ分子がA、 Bの2本のチェイン（鎖）として含まれていることなどがわかります。</p>
<img src="ch01/./image/rcsbpdb7.png" width="100%">
<p>「<strong>Small Molecules</strong>」にはこのエントリに含まれるタンパク質以外の低分子化合物や金属などの情報が記載されています。リン酸塩(<strong>PO4</strong>)、亜鉛イオン(<strong>ZN</strong>)、マグネシウムイオン(<strong>MG</strong>)が結合していることがわかります。このアルカリホスファターゼは、本来リン酸エステル化合物を加水分解する酵素であり、リン酸塩はこの酵素の<strong>阻害剤</strong>として結合している無機リン酸です。</p>
<img src="ch01/./image/rcsbpdb8.png" width="100%">
## PDBデータのダウンロード
PDBの構造情報ファイルをダウンロードし、その中身を確認してみましょう。
<p><strong>分子の立体構造データ</strong>の実体は、<strong>その分子を構成している各原子の\( xyz \)座標データの集まり</strong>です。PDB ID: 1ALKのStructure Summaryのタブに戻って右上の<strong>Display Files</strong>を左クリックし、さらに<strong>PDB Format</strong>を左クリックすると、開かれたタブの中にPDBデータの中身が表示されます。</p>
<p>最初に<code>HEADER</code>レコードや<code>REMARK</code>レコード、<code>SEQRES</code>レコードなどのヘッダ部があり、下方の<code>ATOM</code>（あるいは<code>HETATM</code>）レコードに分子を構成する各原子の\( xyz \)座標などが並んでいます。ヘッダ部には、この分子が由来する生物種や文献情報、構造決定方法に関する情報、アミノ酸配列、単量体か多量体か、構造中に含まれる金属や補酵素の情報などが書かれており、先程まで見ていたPDB ID: 1ALKのウェブページ上ではこれらの情報がわかりやすく整形されて表示されています。座標データは、20種類の標準アミノ酸は<code>ATOM</code>レコードに、それ以外の基質や金属、修飾アミノ酸などは<code>HETATM</code>レコードに記述されています。1ALKの<code>ATOM/HETATM</code>レコードに、タンパク質のAチェイン、 Bチェイン、続いて亜鉛（<code>ZN</code>）、マグネシウム（<code>MG</code>）、リン酸（<code>PO4</code>）、水分子（<code>HOH</code>）の座標データが並んでいることを確認してみましょう。</p>
<pre><code>HEADER:		PDB IDやタンパク質の種類，データ登録年月日
TITLE:		このデータを得た研究内容の簡単な説明
SOURCE:		その分子の由来（遺伝子名，生物種など）
AUTHOR:		著者名
JRNL:		立体構造が発表された文献情報
REMARK:		X線結晶解析の解像度やその他のコメントなど
SEQRES:		アミノ酸・塩基配列
HET:		標準アミノ酸・塩基以外の金属原子，基質などの情報
HELIX/SHEET/TURN:  2次構造情報
SSBOND:		ジスルフィド（S-S）結合
ATOM:		原子座標など
HETATM:		アミノ酸やヌクレオチド以外の原子（金属，基質化合物など）の座標など
TER: 		チェイン（chain, 鎖）の終わり
END:		エントリの終わり
</code></pre>
<p>なお、構造ファイルのデータフォーマットは、これまで伝統的に用いられてきた<strong>PDB format</strong>に代わって、2019年7月1日からは<strong>PDBx/mmCIF format</strong>が標準形式として採用されることになっています。このファイル形式は、人間にはわかりにくいがコンピュータで処理しやすい形式になっています。余裕があればこのフォーマットも新規タブで開いてみましょう。</p>
<p>では、大腸菌のアルカリホスファターゼの立体構造データをダウンロードして、手元のコンピュータの中で可視化し、実際の立体構造を見てみましょう。このための可視化ソフトウェアとして、ここでは無料で利用でき、かつ多くの種類のコンピュータ上で動作することができる<strong>PyMOL</strong>を利用します。</p>
<p>再びRCSB PDBの1ALKのページに戻って、画面右上の<strong>Download Files</strong>を左クリックし、メニューの中の<strong>PDB Format</strong>を右クリックして<strong>対象をファイルに保存</strong>を選択します。</p>
<img src="ch01/./image/rcsbpdb_down.png" width="250px">
<p>ここで、ファイル名を<code>1alk.pdb</code>とします。PDBファイルが<code>ダウンロード</code>のフォルダにダウンロードされるので、そこから<code>デスクトップ</code>にファイルを移動させます。</p>
<h2 id="pymolの起動"><a class="header" href="#pymolの起動">PyMOLの起動</a></h2>
<p>それではPyMOLを起動してみましょう。起動の仕方は、お使いのパソコン・macによってやり方が変わります。もしまだPyMOLをインストールしていない場合は、<a href="ch01/../append01/installation.html">インストール方法</a>を参照してください。</p>
<h3 id="windows-10の場合"><a class="header" href="#windows-10の場合">Windows 10の場合</a></h3>
<p>（調査中です）</p>
<h3 id="macos-バイナリ版の場合"><a class="header" href="#macos-バイナリ版の場合">macOS (バイナリ版)の場合</a></h3>
<p>初心者向けです。バイナリ版をインストールした場合、Finderから[アプリケーション]を選択して中にあるPyMOLをダブルクリックすることで起動できます。</p>
<img src="ch01/./image/launch1.png" width="80%">
<h3 id="macosオープンソース版の場合"><a class="header" href="#macosオープンソース版の場合">macOS（オープンソース版の場合）</a></h3>
<p>ターミナル操作に習熟した上級者向けです。オープンソース版はHomebrewを使うことでインストールできます。（参考：<a href="ch01/../append01/installation.html">インストール方法</a>）
インストールに完了した後、[アプリケーション]→[ユーティリティ]→[ターミナル]を選択して、<code>pymol</code>と打てば起動します。実用上は <code>pymol &gt; /dev/null 2&gt;&amp;1 &amp;</code> とコマンドを打つ方が便利かもしれません。</p>
<h3 id="linuxの場合"><a class="header" href="#linuxの場合">Linuxの場合</a></h3>
<p>インストール完了後、ターミナルから <code>pymol</code> と打つことで起動します。</p>
<h2 id="大腸菌由来アルカリホスファターゼのグラフィック表示"><a class="header" href="#大腸菌由来アルカリホスファターゼのグラフィック表示">大腸菌由来アルカリホスファターゼのグラフィック表示</a></h2>
<p>PyMOLを起動した後、画面左上にある<code>File</code>メニューから<code>Open...</code>を選び、先程デスクトップに移動させた<code>1alk.pdb</code>ファイルを選択します。すると、PyMOL画面の中にPDB ID: 1ALKの<strong>大腸菌由来アルカリホスファターゼ</strong>が表示されます。</p>
<img src="ch01/./image/graphic1.png" width="100%" alt="PDB ID: 1ALKの大腸菌由来アルカリホスファターゼの図" title="PDB ID: 1ALKの大腸菌由来アルカリホスファターゼの図">
<p>このチュートリアルではPyMOLのGUI機能を駆使して、アルカリホスファターゼの2次構造の配置（フォールド）や、リン酸付近の原子・残基の配置などを調べてみます。必要に応じて<a href="ch01/../ch02/index.html">第2章 PyMOLのGUIの使い方</a>の<a href="ch01/../ch02/mouse.html">マウス操作</a> とMouse Mode: <a href="ch01/../ch02/buttontable.html">3-Button Viewing</a> を読みます。マウスで分子をドラッグすることで、分子の回転、平行移動、拡大縮小などが行うことができます。</p>
<p>PyMOLでは、まずマウス(または<code>select</code>コマンド)で原子やアミノ酸を<strong>選択(select)</strong> し、続いて選択した範囲に対する <strong>操作(Action)</strong> を指定します。選択された部分はピンクのマーカーで強調されるので、今何が「選択」されているかに常に注意します。また、<strong>操作のやり直しはできない</strong>ので、操作を間違えた場合にはその都度それを上書きする形で表示をやり直します。</p>
<img src="ch01/./image/graphic2.png" width="100%" alt="1ALKのAチェインを選択したときの図。ピンクのマーカーで覆われているのがAチェイン。配列の上でもハイライトされていることに留意しよう。" title="1ALKのAチェインを選択したときの図。ピンクのマーカーで覆われているのがAチェイン。配列の上でもハイライトされていることに留意しよう。">
<h3 id="チェインごとの色分け"><a class="header" href="#チェインごとの色分け">チェインごとの色分け</a></h3>
<p>このアルカリホスファターゼがホモ2量体であることをわかりやすく表示するために、Aチェインを緑色（デフォルト）、Bチェインを水色（cyan）で表示してみます。PyMOL右下の画面に<code>S</code>という小さなボタンがあるので、ここを押すと、タンパク質が表示されている画面の上にアミノ酸配列が現れます（参考： <a href="ch01/../ch02/dispseq.html">配列の表示について</a> ）。</p>
<img src="ch01/./image/colorchain.png" alt="チェインごとの色分け">
<p>今表示されたアミノ酸配列の上で、マウスを使ってチェインBをすべて選択します。次に、色の設定を参考にしてチェインBを水色に変更します（参考：<a href="ch01/../ch02/color.html">色の設定</a> ）。</p>
<p>※ PyMOLの画面上に存在する入力欄<code>PyMOL&gt; </code>の所（中段上と一番下の2ヶ所に存在しますが、どちらに入力してもOK）で上や下の矢印キーを押すと、それまでに入力したコマンドを再び呼び出すことができます。また左右の矢印キーを使って、以前使ったコマンドを自由に編集できます。同じコマンドを何度も入力するのは面倒なので、上下左右の矢印キーを上手に使いましょう。</p>
<h3 id="二次構造ごとの色分け"><a class="header" href="#二次構造ごとの色分け">二次構造ごとの色分け</a></h3>
<p>この大腸菌アルカリホスファターゼを、今度は二次構造による色分けを使って表示してみます（参考： <a href="ch01/../ch02/color.html">色の設定について</a> ）。</p>
<p>オブジェクトパネルにおける<code>1ALK</code>のCのところをクリックし、Colorのメニューのところで、[by ss]にマウスを重ねます。色分けの種類はデフォルトで3種類用意されており、どれを使っても問題ありませんが、ここでは一番上の例（ヘリックス:赤; シート:黄; ループ:緑）のカラーリングで表示してみます。</p>
<img src="ch01/./image/colorbyss1.png" alt="" title="">
<p>このように表示されるはずです。</p>
<img src="ch01/./image/colorbyss2.png" alt="" title="">
<p>ここで、大腸菌アルカリホスファターゼの立体構造のCATHによる分類は、&quot;Alpha Beta 3-Layer(aba) Sandwich&quot;とされています。Cartoon表示で見る角度を調節して、このタンパク質の立体構造がCATHの分類通りにAlpha Betaの3層構造を形成していることを確認してみましょう。</p>
<h3 id="画像の保存"><a class="header" href="#画像の保存">画像の保存</a></h3>
<p>画面に映されているタンパク質を画像ファイルとして保存します。ただし、そのまま保存しようとすると背景が黒のままとなってしまいます。</p>
<img src="ch01/./image/saveimage1.png" alt="黒背景のままの保存">
<p>これを白背景で出力します。上部のDisplay &gt; Backgroundメニューから、Whiteを選択します。</p>
<img src="ch01/./image/saveimage2.png" alt="白背景">
<p>この設定の後、PyMOL画面の右上に存在するDraw/Rayボタンを押し、<code>Draw (fast)</code>または<code>Ray (slow)</code>ボタンを押すと、きれいな画像となって表示されます。</p>
<img src="ch01/../ch02/image/saveimage/saveimage5.png" alt="白背景" width="60%">
<p>問題がなければ、<code>Save Image to File</code>ボタンを押し、ファイル名を設定して保存しましょう。ちなみに、<code>transparent background</code>にチェックを入れると背景透過画像を生成することができます（ただし<code>Ray (slow)</code>を適用した場合のみ）。背景透過処理を行うとレポートやスライドの上で扱いやすくなるので、ぜひ利用しましょう。</p>
<p>その他の詳しい項目については<a href="ch01/../ch02/saveimage.html">2.7 画像の保存</a>を参照してください。</p>
<h3 id="セッションファイルへの保存"><a class="header" href="#セッションファイルへの保存">セッションファイルへの保存</a></h3>
<p>ここまでの作業内容をセッションファイルに保存します。セッションファイルとは、現在のPyMOLの画面の状態をそのまま保存しておくファイルのことです。画面上部にあるFileメニューから<code>Save session as…</code>を選んで名前を指定して保存します(<code>kadai1.pse</code>など、わかりやすい名前をつけましょう)。（参考：<a href="ch01/../ch02/session.html">セッションの保存</a> ）。</p>
<img src="ch01/./image/savesession.png" width="300px" alt="セッションファイルへの保存">
<p>保存したセッションファイルはFile &gt; Openメニューから読み込むことができます。</p>
<img src="ch01/./image/fileopen.png" width="300px" alt="ファイルを開く">
<p>すでにタンパク質を他に表示させている状態でセッションファイルを読み込もうとすると下図のようなメッセージが現れますが、今開いている画面と別のPyMOL画面でタンパク質を表示させたい場合は、一番下の<code>Open in new PyMOL Window</code>を選択することをおすすめします。</p>
<img src="ch01/./image/loadsession.png" width="300px" alt="セッションを開く時のプロンプト画面">
<p>※ （上級者向け）上述の<code>PyMOL&gt; </code>の入力欄にコマンドを入力することでも可能です。デスクトップ上に保存したい場合は、<code>cd ~/Desktop</code>としてWorking Directoryをデスクトップに設定した後、<code>save kadai1.pse</code>とすることでセッションファイルを保存できます。</p>
<h3 id="リガンド結合部位への注目"><a class="header" href="#リガンド結合部位への注目">リガンド結合部位への注目</a></h3>
<p>ここから、タンパク質内の<strong>リン酸や金属が結合している部分</strong>に注目してみます。まず、全体構造の中のどこに結合しているかを確認してみます。</p>
<ul>
<li>PyMOL内で<a href="ch01/../ch02/dispseq.html">配列を表示</a>させます。</li>
<li>表示された配列のところで、Chain Aの<code>ZN</code>2つと<code>MG</code>,<code>PO4</code>をすべて<strong>選択</strong>します。</li>
<li>次に、<a href="ch01/../ch02/objpanel.html">オブジェクトパネル</a>においてその選択範囲<code>(sele)</code>についてStickとSpheresで表示させてみます（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。</li>
</ul>
<img src="ch01/./image/focus1.png" width="100%" alt="" title="">
<p>デフォルト設定では、sphere表示で表されるボールがかなり大きくなっているので、ここではいったん小さくしてみます。これは<code>PyMOL &gt;</code>のところにコマンドを打つことで設定できます。</p>
<pre><code>set sphere_scale, 0.4
</code></pre>
<p>これで球が小さく表示されました。</p>
<img src="ch01/./image/focus2.png" width="100%" alt="" title="">
<p>ここで、表示をチェインA（A鎖）だけにし、Bチェインはhideで隠します（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。リン酸や金属は各チェインに1組ずつ結合していることがわかります。</p>
<img src="ch01/./image/focus3.png" width="100%" alt="" title="">
<p>チェインAのリン酸(<code>PO4</code>)が画面の中心にくるよう設定してみます。これはこの<code>PO4</code>を選択した上で右クリックを押してメニューを表示させ、<code>center</code>を選択することでできます。
参考：<a href="ch01/../ch02/mouse.html">マウス操作</a>と<a href="ch01/(../ch02/buttontable.html">各モードにおける操作一覧</a></p>
<img src="ch01/./image/focus4.png" width="100%" alt="" title="">
<p>マウス操作で、画面を拡大して見やすくしておきます。</p>
<p>タンパク質のCartoon表示をオフにします（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。</p>
<p>チェインAのリン酸から4.6 Å以内にある水分子以外のアミノ酸残基を表示させます。チェインAのリン酸<code>PO4</code>だけが選択された状態で以下のコマンドを打ちます。</p>
<pre><code>select byres resn * within 4.6 of sele
show sticks, sele
</code></pre>
<p>ここで、<code>byres</code>は「残基単位での選択」を意味する設定であり、とある残基が1原子でもリン酸から4.6 Åの距離以内に存在するのであれば、その残基をすべて選択するようにしています。その後、2行目のコマンドで選択した範囲を<code>sticks</code>で表示させます（オブジェクトパネルでも可能）</p>
<p>Zn，Mgは原子種ごとの色分け（→<a href="ch01/../ch02/color.html">色の設定</a>）にします。</p>
<p>リン酸付近にどのようなアミノ酸種が分布しているかを確認するために、先程の選択範囲<code>(sele)</code>について、<a href="ch01/../ch02/label.html">ラベルの設定</a>で<code>label</code> -&gt; <code>residues</code>を選択します。</p>
<img src="ch01/./image/focus5.png" width="100%" alt="" title="">
<p>PyMOL画面を回転させて、どのアミノ酸がこのリガンド結合部位に存在しているかをすべてメモします。目視で行っても構いませんが、ここではPyMOLがPythonプログラミングで動いているということを利用して、以下のコマンドを入力して確認してみましょう。</p>
<p>コマンド入力欄に以下のコマンドを順次入れていきます（コピー＆ペースト可能）。</p>
<pre><code class="language-python"># チェインAのリン酸を選択する(残基名がPO4でかつchain Aのものをselectする)
select resn PO4 and chain A
# 現在の選択範囲から4.6Å以内にある分子を、残基単位(byres)ですべて選択する
select byres resn * within 4.6 of sele

# ここで空の配列であるreslistを作成しておく（初期化）
reslist = []
# pymolのiterateコマンドを用いて、選択範囲(sele)に存在するCα炭素(name CA)について
# (residue_id, residue_name)のタプルをreslistに繰り返し加えていく
iterate sele and name CA, reslist.append((resi, resn))
# reslistを表示する
print(reslist)
</code></pre>
<p>ここまでうまく入力されていれば、最後に以下のように結果が表示されるはずです。</p>
<pre><code>PyMOL&gt; print(reslist)
[('51', 'ASP'), ('101', 'ASP'), ('102', 'SER'), ('153', 'ASP'), ('166', 'ARG'), ('327', 'ASP'), ('331', 'HIS'), ('369', 'ASP'), ('370', 'HIS'), ('412', 'HIS')]
</code></pre>
<p>これはpythonで言うところの、リスト型変数<code>reslist</code>の中にタプル型で（残基番号, 3文字残基名）の組が入っている形になっています。</p>
<p>これをよく生物学の表示で使われるようなMET-1, ASP-2のような表示に変換したい場合は、pythonのprint文を知識を使って例えば以下のようにpythonプログラムを書けばうまく出力することができます。ただし、PyMOLのコマンドラインでpythonプログラムを書く場合は<code>python</code>と<code>python end</code>というブロックの間に挟む必要があります。（参考： https://pymolwiki.org/index.php/Python ）</p>
<pre><code class="language-python">python
# リスト内のタプルをi, jに代入するfor loop
for i, j in reslist:
    # print&amp;format文法を使って&quot;{residue_name}-{residue_id}&quot;の順番で表示する
	print(&quot;{0}-{1}&quot;.format(j, i))

python end
</code></pre>
<p>すると、以下のように表示されます。</p>
<pre><code>PyMOL&gt;python end

ASP-51
ASP-101
SER-102
ASP-153
ARG-166
ASP-327
HIS-331
ASP-369
HIS-370
HIS-412
</code></pre>
<p>こうすれば目視でやるより書き漏らしがなくて済みますね。</p>
<p>終わったら、再び現在までの作業内容をセッションファイルに保存しておきます。ファイル名はたとえば<code>1alk_active_site.pse</code>などとしておくと分かりやすくて良いでしょう。</p>
<h2 id="ヒトアルカリホスファターゼとの構造比較"><a class="header" href="#ヒトアルカリホスファターゼとの構造比較">ヒトアルカリホスファターゼとの構造比較</a></h2>
<p>ヒトアルカリホスファターゼも立体構造が解かれ、PDBに登録されている（<a href="https://www.rcsb.org/structure/1EW2">PDB ID: 1EW2</a>）。大腸菌アルカリホスファターゼとの類似点・相違点を調べてみよう。</p>
<p>ヒトアルカリホスファターゼと大腸菌アルカリホスファターゼのアミノ酸一致度は30%弱である。つまり平均すると10箇所のうち7箇所以上はアミノ酸が異なっていることになります。では、<strong>ヒトアルカリホスファターゼは大腸菌アルカリホスファターゼとまったく異なるやり方でリン酸エステル化合物の加水分解を行っているのだろうか？それとも似た反応機構をもっているのでしょうか</strong>。立体構造の観点から調べてみましょう。</p>
<h3 id="ヒトアルカリホスファターゼの構造ファイルのダウンロード"><a class="header" href="#ヒトアルカリホスファターゼの構造ファイルのダウンロード">ヒトアルカリホスファターゼの構造ファイルのダウンロード</a></h3>
<p>まず大腸菌のときと同様に、RCSB PDBから1EW2のPDBファイルをダウンロードします（参考：<a href="ch01/../ch02/loadmol.html">分子構造のロード</a>）。次に、すでに1ALKの構造を開いているPyMOLの中で、この1EW2の構造ファイルをロードします。しかし、ここで1ALKのときと違いChain Aしか表示されていないことに気付くでしょう。1EW2も1ALKと同様にBiological unitはホモダイマーですが、この構造ファイルには結晶の対称性を考慮してチェイン1本分の座標しか入っていない状態になっています。このような場合はPyMOLの機能を使って、結晶の対称性からもう1本のチェインの座標データを生成することができます。</p>
<p><a href="ch01/../ch02/loadmol.html#biological-unit%E3%82%92%E8%80%83%E6%85%AE%E3%81%97%E3%81%9F%E5%88%86%E5%AD%90%E6%A7%8B%E9%80%A0%E3%81%AE%E3%83%AD%E3%83%BC%E3%83%89">Biological unitを考慮した分子構造のロード</a>のページを参考に、1EW2の構造を2量体でロードします。1EW2の各チェインは<code>1ew2_0001</code>, <code>1ew2_0002</code>と表示されることになります。ここで、わかりやすくするために大腸菌のアルカリホスファターゼを緑色に、今開いたヒトアルカリホスファターゼの2量体を水色で表示させておきます。</p>
<img src="ch01/./image/compare1.png" alt="1ALK（緑）と1EW2（青）の2量体表示" title="1ALK（緑）と1EW2（青）の2量体表示">
<h3 id="2つのアルカリホスファターゼの構造の重ね合わせ"><a class="header" href="#2つのアルカリホスファターゼの構造の重ね合わせ">2つのアルカリホスファターゼの構造の重ね合わせ</a></h3>
<p>では、大腸菌とヒトのアルカリホスファターゼの構造をそれぞれ重ね合わせることで比較してみましょう。ここではPyMOLの<code>super</code>という重ね合わせ用のコマンドを使います。</p>
<p>今、画面には<code>1alk</code>と<code>1ew2_0001</code>, <code>1ew2_0002</code>のオブジェクトが存在しているはずです。ここで、<code>1alk</code>オブジェクトを<code>1ew2_0001</code>オブジェクトに重ね合わせることを以下のコマンドで行います（※<strong><code>1ew2_0001</code>を<code>1alk</code>に、ではないことに注意</strong>）。このコマンドは</p>
<pre><code>super 1alk, 1ew2_0001
</code></pre>
<p>です。これを行うと、</p>
<img src="ch01/./image/compare2.png" alt="1ALK（緑）と1EW2（青）の重ね合わせ結果" title="1ALK（緑）と1EW2（青）の重ね合わせ結果">
<p>図のように大腸菌ホスファターゼとヒトアルカリホスファターゼを重ねることができます（図では背景をグレーにしています）。また、画面上部のPyMOLコンソール画面には2つの構造のRMSD値が表示されます。</p>
<img src="ch01/./image/compare3.png" alt="PyMOLコンソール画面" title="PyMOLコンソール画面">
<pre><code>PyMOL&gt;super 1alk, 1ew2_0001
 MatchAlign: aligning residues (898 vs 479)...
 MatchAlign: score 740.851
 ExecutiveAlign: 1947 atoms aligned.
 ExecutiveRMS: 83 atoms rejected during cycle 1 (RMSD=4.31).
 ExecutiveRMS: 135 atoms rejected during cycle 2 (RMSD=2.64).
 ExecutiveRMS: 187 atoms rejected during cycle 3 (RMSD=2.03).
 ExecutiveRMS: 135 atoms rejected during cycle 4 (RMSD=1.39).
 ExecutiveRMS: 87 atoms rejected during cycle 5 (RMSD=1.03).
 Executive: RMSD =    0.864 (1320 to 1320 atoms)
</code></pre>
<p>この結果、0.864 Åというとても小さなRMSD値が得られました。これはこの2つの構造の差が小さいことを表しています。</p>
<h2 id="タンパク質の疎水性親水性残基の分布を確認する"><a class="header" href="#タンパク質の疎水性親水性残基の分布を確認する">タンパク質の疎水性・親水性残基の分布を確認する</a></h2>
<p>タンパク質を構成しているアミノ酸は通常20種類ですが、その20種類のアミノ酸を化学的な性質に基づいて<strong>親水性・疎水性</strong>で分類することがあります。この親水性とは水に対して親和性が高いという意味で、疎水性は反対に親和性が低いということを意味します。特に、<strong>水素結合を形成しやすい</strong>側鎖を持つアミノ酸は<strong>親水性アミノ酸</strong>と呼ばれ、そうでないものは<strong>疎水性アミノ酸</strong>と呼ばれます。</p>
<p>親水性アミノ酸は以下のアミノ酸が該当します。pH 7.0の中性溶液中で持つ電荷についても示します。</p>
<ul>
<li>酸性アミノ酸（負電荷を持つ）
<ul>
<li>アスパラギン酸（Asp, D）</li>
<li>グルタミン酸（Glu, E）</li>
</ul>
</li>
<li>塩基性アミノ酸（正電荷を持つ）
<ul>
<li>リジン（Lys, K）</li>
<li>アルギニン（Arg, R）</li>
</ul>
</li>
<li>中性アミノ酸
<ul>
<li>スレオニン（Thr, T）</li>
<li>セリン（Ser, S）</li>
<li>アスパラギン（Asn, N）</li>
<li>グルタミン（Gln, Q）</li>
<li>ヒスチジン（His, H）</li>
</ul>
</li>
</ul>
<p>また、これらの親水性度・疎水性度を数値化した研究も存在しています（<a href="https://www.sciencedirect.com/science/article/abs/pii/0022283684903097?via%3Dihub"><em>J. Mol. Biol.</em> 179:125-142 (1984)</a>）。これによれば、</p>
<table><thead><tr><th>アミノ酸</th><th align="right">疎水性度</th></tr></thead><tbody>
<tr><td>Ala</td><td align="right">0.620</td></tr>
<tr><td>Arg</td><td align="right">-2.530</td></tr>
<tr><td>Asn</td><td align="right">-0.780</td></tr>
<tr><td>Asp</td><td align="right">-0.900</td></tr>
<tr><td>Cys</td><td align="right">0.290</td></tr>
<tr><td>Gln</td><td align="right">-0.850</td></tr>
<tr><td>Glu</td><td align="right">-0.740</td></tr>
<tr><td>Gly</td><td align="right">0.480</td></tr>
<tr><td>His</td><td align="right">-0.400</td></tr>
<tr><td>Ile</td><td align="right">1.380</td></tr>
<tr><td>Leu</td><td align="right">1.060</td></tr>
<tr><td>Lys</td><td align="right">-1.500</td></tr>
<tr><td>Met</td><td align="right">0.640</td></tr>
<tr><td>Phe</td><td align="right">1.190</td></tr>
<tr><td>Pro</td><td align="right">0.120</td></tr>
<tr><td>Ser</td><td align="right">-0.180</td></tr>
<tr><td>Thr</td><td align="right">-0.050</td></tr>
<tr><td>Trp</td><td align="right">0.810</td></tr>
<tr><td>Tyr</td><td align="right">0.260</td></tr>
<tr><td>Val</td><td align="right">1.080</td></tr>
</tbody></table>
<p>となっています（値が高いほど疎水性、低いほど親水性）。</p>
<p>一方で、これまで見てきたようにタンパク質はある1つの決まった形を取るように折りたたまっています。このとき親水性・疎水性アミノ酸はタンパク質構造上でどのように分布しているかを、PyMOLに表示した大腸菌アルカリホスファターゼを例にとって確認してみましょう。</p>
<p>まずあらためて大腸菌アルカリホスファターゼ（PDB ID: 1ALK）をロードし直しておきます。</p>
<img src="ch01/./image/hyph1.png">
<p>続いて、この構造を上の表で登場したアミノ酸の親水性・疎水性基準に従って、アミノ酸の側鎖を色分けしてみます。親水性のアミノ酸（表で0以下の値を持つアミノ酸）をすべて水色に、疎水性アミノ酸をすべてオレンジ色に塗ってみます。このとき、すべてのアミノ酸をマウスで選ぶのは大変なので、PyMOLのコマンドラインを活用します。</p>
<p>PyMOLソフトウェアの<code>PyMOL&gt;</code>と書かれている欄にまず<code>select hydrophobic,(resn ala+cys+gly+val+ile+leu+phe+pro+met+trp+tyr)</code>と入れてEnterキーを入力すると、疎水性アミノ酸たちが<code>hydrophobic</code>という名前の選択範囲が保存されます。この後、この選択範囲をオレンジ色にするために<code>color orange, hydrophobic</code>というコマンドを入力します。同様にして、すべての親水性アミノ酸を<code>hydrophilic</code>という名前の選択範囲として登録しておき、これをシアン色に色付けします。最後に、これらのアミノ酸残基の体積を強調するためにSphere表示にしてみます。</p>
<p>以上のコマンドは</p>
<pre><code class="language-bash"># 疎水性残基をhydrophobicという名前の選択範囲として保存
select hydrophobic,(resn ala+cys+gly+val+ile+leu+phe+pro+met+trp+tyr)
# 選択範囲hydrophobicをorange色にする
color orange,hydrophobic
# 親水性残基をhydrophobicという名前の選択範囲として保存
select hydrophilic,(resn arg+asn+asp+gln+glu+his+lys+ser+thr)
# 選択範囲hydrophilicをcyan色にする
color cyan, hydrophilic
# すべての残基をsphere表示にする
show spheres, all
</code></pre>
<p>と打っていくことで達成されます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/hyph2.mp4" type="video/mp4">
</video>
<p>このように色付けをしてみると、大腸菌アルカリホスファターゼの表面には親水性の残基が比較的多く分布していることがわかります。</p>
<p>ここで、PyMOLのマウス機能の1つである<a href="ch01/../ch02/buttonaction.html#%E3%82%B9%E3%83%A9%E3%83%93%E3%83%B3%E3%82%B0slab">Slab</a>を使ってタンパク質の中を覗いてみます。Slabはマウスのホイールを回転させて行います（Macbookなどに付属しているタッチパッドで行う場合は、タッチパッドに2本指を置いて上下に動かします）</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/hyph3.mp4" type="video/mp4">
</video>
<p>すると、アルカリホスファターゼのタンパク質構造の内部には<strong>疎水性アミノ酸がとても密に詰まっていることがわかる</strong>と思います。その一方で、表面にはやはり親水性アミノ酸が分布していることから、<strong>タンパク質構造の外側には親水性アミノ酸が、内側には疎水性アミノ酸が</strong>それぞれ分布していることがわかります。</p>
<p>このことはアルカリホスファターゼに限らず他の多くのタンパク質についても一般に成立します。ただこのアミノ酸の分布は親水性・疎水性アミノ酸の性質からすると当然のことを言っているに過ぎないと思われるかもしれません。しかしながら、これらの大きな疎水性アミノ酸のかたまり、通称<strong>疎水性コア</strong>は、タンパク質構造を安定に保つために重要な役割を果たしています。</p>
<p>水溶液中で安定に存在できる球状タンパク質は、疎水性アミノ酸が周囲の水分子と反発することによって親水性アミノ酸を外側へ、疎水性アミノ酸は内側へ集中させることから生まれる<strong>疎水性相互作用</strong>によって構造を形成していくことが知られています。そしてこの疎水性コアは疎水性アミノ酸同士の側鎖が密にパッキングすることによって文字通り隙間なく形成されており、これによってタンパク質全体の構造の安定性を大きく伸ばすことに貢献しています。タンパク質構造で注目されがちなのは親水性アミノ酸がよく用いられ外側に露出している活性部位（大腸菌アルカリホスファターゼで言うところのSer102, Arg166周辺）なのですが、こうした構造の成り立ちに関わるアミノ酸の分布のことも重要であることを覚えておくと、タンパク質構造についての理解がより深まると思います。</p>
<p>補足ですが、タンパク質アミノ酸を疎水性・親水性に応じて色分けを行うための拡張コマンドとして<code>color_h</code>, <code>color_h2</code>が存在します（<a href="https://pymolwiki.org/index.php/Color_h">https://pymolwiki.org/index.php/Color_h</a>）。<code>color_h</code>, <code>color_h2</code>コマンドの使い方は<a href="ch01/../ch05/python_on_pymol.html#%E6%8B%A1%E5%BC%B5%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E4%BD%BF%E3%81%88%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%80">PyMOL上でのpythonスクリプトの実行</a>を参考にしてみてください。</p>
<h2 id="タンパク質の位置依存的なアミノ酸保存度の違いを理解する"><a class="header" href="#タンパク質の位置依存的なアミノ酸保存度の違いを理解する">タンパク質の位置依存的なアミノ酸保存度の違いを理解する</a></h2>
<p>これまで見てきたように、タンパク質の内部は疎水性アミノ酸で充填されており、外側には水に溶けやすい親水性残基を露出することで水溶液中に存在しているというのがタンパク質の構築原理でした。一方、タンパク質は構造を保つだけでなく、リガンドを結合したり、化学反応を触媒したりする<strong>機能</strong>を持つことが生体内で特に重要です。言い換えれば、タンパク質は限られた20種類のアミノ酸をうまく使い分けることで、<strong>内部構造を保ちつつ、そして機能も発現させなければならない</strong>という二面性を持っています。</p>
<p>しかし、タンパク質を使って生きている生物というものは不思議なもので、すでにヒトと大腸菌のアルカリホスファターゼで見てきた通り、同じ機能を持つタンパク質であっても、それを構成しているアミノ酸配列を調べてみると、配列間の相同性が2〜3割しかないということもよく見られます。これは一体どういうことでしょうか？</p>
<p>以上のことを、アルカリホスファターゼについて確認してみましょう。まずは、<strong>PDBsum</strong> (<a href="https://www.ebi.ac.uk/thornton-srv/databases/cgi-bin/pdbsum/GetPage.pl?pdbcode=index.html">https://www.ebi.ac.uk/thornton-srv/databases/cgi-bin/pdbsum/GetPage.pl?pdbcode=index.html</a>) というデータベースに登録されているデータを用います。PDBsumはPDBに登録された生体分子の構造データを加工したデータベースの1つで、配列・構造情報・リガンド結合・文献情報などをわかりやすくまとめてあります。ここのトップページのフォームに、調べたいPDBデータのIDを入れてFindボタンを押します。</p>
<img src="ch01/./image/pdbsum1.png">
<p>すると、PDB ID: 1ALKについてのページに移ります。このトップページには構造の図とともに、タンパク質の分類・リガンド情報・化学反応・一次文献情報・この構造を引用している論文一覧……などが表示されています。</p>
<img src="ch01/./image/pdbsum2.png">
<p>さらに、上部にあるタブをクリックすることで、さらに他の詳細な情報を表示させることができます。ここではProteinタブをクリックしてみましょう。</p>
<img src="ch01/./image/pdbsum3.png">
<p>Proteins タブ、ページ左側にあるMotifsメニューのSecondary structure, Residue conservationをクリックすると（上図の赤丸部分）、アミノ酸の生物種間での保存度が1つずつカラーリングされているページが現れます。</p>
<img src="ch01/./image/pdbsum4.png">
<img src="ch01/./image/pdbsum5.png">
<p>この1文字表記のアミノ酸配列を見てみると、青〜緑〜黄〜赤までのカラーリングがなされていることに気づくと思います。<strong>このカラーリングはこの大腸菌アルカリホスファターゼの類縁配列上で、そのアミノ酸の位置がどれほど保存されているかを表しています</strong>（ページ下部に説明が書かれてあります）。言い換えれば、大腸菌アルカリホスファターゼについて他の類縁配列とのマルチプルシーケンスアライメントを作成してみたとき、ある位置のアミノ酸の種類が他の類縁配列上でも同じであればその位置のアミノ酸の保存度は高く、逆に他の類縁配列上でバラバラな様子が観測されていればその位置のアミノ酸の保存度は低くなります。例えば、この大腸菌アルカリホスファターゼのcatalytic residueである<strong>Ser102</strong>, <strong>Arg166</strong>のアミノ酸の保存度は最も高い9で示されています。この他にも、<strong>PDB SITE records</strong>（※なにかのリガンドが結合しているアミノ酸につくレコード）のマークが付いているアミノ酸はいずれも高い保存度を示していることが見て取れます。しかし、大腸菌アルカリホスファターゼのアミノ酸配列全体を見渡してみると、他にも保存度が高いところがあるのが伺えますし、逆に保存度が低いアミノ酸はなぜ低くなっているのか、という疑問も残ります。</p>
<p>そこでこの疑問を考察するために、これからこの保存度の情報をPyMOLで表示させた大腸菌アルカリホスファターゼ構造の上に表示させてみます。</p>
<p>先程のResidue Conservationのページの下の方を見ると、この保存度は<strong>Consurf-DB</strong>というデータベースに保存されてあります（<a href="https://consurfdb.tau.ac.il/">https://consurfdb.tau.ac.il/</a> ）。このページにアクセスして、大腸菌アルカリホスファターゼのPDB IDとChain IDを以下の画像のように入力してみましょう。</p>
<img src="ch01/./image/consurfdb1.png" width="80%">
<p>すると、まもなくPDB: 1ALKについての保存度情報についてのページに遷移します。ここで、下の方にある<strong>High Resolution Figures</strong>のところから、PyMOLの方のマークをクリックして、PyMOLのセッションファイル（<code>consurf_pymol_session.pse</code>）をダウンロードします。</p>
<img src="ch01/./image/consurfdb2.png">
<p>このダウンロードしてきたファイルをPyMOLで開いてみましょう。</p>
<img src="ch01/./image/consurfdb3.png">
<p>ここで、保存度のカラーリングはChain Aのみに行われており、Chain Bについては情報が存在していないためグレー表示となっていることに注意してください。</p>
<p>このダウンロードしてきた構造をPyMOL上で様々な角度から眺めていると、<strong>タンパク質構造の内側は保存度が高く、外側は保存度が小さい</strong>ことに気付かれると思います。これは偶然ではなく、前項の<a href="ch01/hydrophobicity.html">タンパク質の疎水性親水性残基の分布を確認する</a>で確認した通り、タンパク質構造の内部は疎水性アミノ酸によって隙間なく密にしておくことで、タンパク質構造を安定に支えておく必要があるからです。つまり、内部を支えるアミノ酸が不用意に別のアミノ酸に変化してしまうと構造を支えられなくなって機能を保てなくなってしまいます。また構造の外側に位置するアミノ酸であっても、<strong>活性残基、およびその周辺の残基</strong>は特に保存されていることがわかります。これはもちろんタンパク質の機能を直接担う責任重大なアミノ酸だから、と考えることができます。反対に、外側に露出しているアミノ酸はある程度どのアミノ酸を使ってもタンパク質構造全体の安定性という観点からすると大きな問題ではないため、アミノ酸の保存度が低くても機能に支障が出ないというわけです。</p>
<p>タンパク質は<strong>その機能を失わず、かつ構造を安定に保つという最低限の目的さえ果たせれば、そのアミノ酸配列はある程度自由に構成することができます</strong>。アルカリホスファターゼの例で言えば、リン酸モノエステル化合物を加水分解するという機能を損なわず、かつタンパク質全体の構造が壊れなければ、そのアミノ酸配列はある程度許容されることになり、長い進化の課程で大腸菌やヒトのものといった様々なバリエーションが生まれていったと考えることができます。</p>
<h2 id="アルカリホスファターゼの加水分解酵素としての働き"><a class="header" href="#アルカリホスファターゼの加水分解酵素としての働き">アルカリホスファターゼの加水分解酵素としての働き</a></h2>
<p>最後に、アルカリホスファターゼが「<strong>ホスファターゼ</strong>」の名前通りに<strong>リン酸モノエステル加水分解酵素</strong>として化学的にどう働いているかを観察してみましょう。</p>
<p>アルカリホスファターゼ（ALP）は以下の反応式のように、<em>p</em>-ニトロフェニルリン酸を<strong>加水分解</strong>して<em>p</em>-ニトロフェノール（黄色く発色する）を生成することができます。</p>
<img src="ch01/./image/ALPreaction.png" width="60%">
<p>この反応の様子をPyMOLで見てみましょう。</p>
<p><a href="http://vivace.bi.a.u-tokyo.ac.jp:8008/1alk_reaction.pse">このリンク</a>に<code>1alk_reaction.pse</code>という名前のPyMOLセッションファイルを置いています。これをダウンロードしてダブルクリック、またはFile -&gt; Openからこのファイルを開いてみましょう。このセッションファイルにはアルカリホスファターゼの単量体とともに、今まで無機リン酸が入っていた箇所に<em>p</em>-ニトロフェニルリン酸（残基名：NPH）の構造が見えるはずです。</p>
<img src="ch01/./image/reaction1.png" width="80%">
<p>PyMOL Internal GUIの右下には▶ボタンがあります。この▶ボタンを押すとタンパク質と<em>p</em>-ニトロフェニルリン酸が少しずつ動き、化学反応を起こしている様子が可視化されて見えるはずです。</p>
<video width="100%" height="100%" controls autoplay>
<source src="./image/reactionmovie.mp4" type="video/mp4">
</video>
<p>このような動いている様子が見られるのは、このセッションファイルにはあらかじめ149フレーム分の構造データを入れたオブジェクトが含まれているからです。ほとんどすべてのRCSB PDBからダウンロードしてきた結晶構造のデータは静止しているために1フレーム分のデータしかありませんが、NMRで構造決定されたデータですと、タンパク質の「動き」が収録されているものもあります（例としてPDB ID: 1G03）。</p>
<p>このセッションファイルには、<code>dist01</code>から<code>dist11</code>までの距離オブジェクトも含まれています。この距離オブジェクトは<a href="ch01/../../../ch02/buttontable.html">マウス操作の原子ピッキング（PkAt）機能</a>を用いることで作成することができます。距離を測定したい2点の原子の上でそれぞれCtrlキーを押しながらマウスのホイールクリックを行い、コマンドで<code>dist</code>と入力することで距離オブジェクトを生成することができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="目的-1"><a class="header" href="#目的-1">目的</a></h2>
<p>酵素などのタンパク質は、それぞれ固有のアミノ酸配列をもち、それが固有の立体構造に折れたたまります。これにより、アミノ酸配列上では離れていた残基同士が接近し、それらが協同して他の分子と相互作用したり化学反応を触媒したりすることができるようになります。タンパク質を含む生体分子が機能を果たすためには、その立体構造が本質的に重要です。生体分子は、ナノメートル（\( 10^{-9}\ \rm{m} \)）オーダーの微小なものですが、X線結晶構造解析法やNMR法、最近ではクライオ電子顕微鏡などの手法を用いて、その立体構造（分子を構成している各原子の\( xyz \)座標）を決定することができます。それらの構造データは、公共の立体構造データベースに蓄積され、誰もが自由かつ無料で利用できるようになっています。コンピュータを用いると、これらの立体構造データにインターネットを介してアクセスし、さらに分子グラフィックスソフトウェアを用いてその構造を表示することが可能となります。</p>
<p>人間の肉眼では見えない生体分子をこのようにコンピュータ上で可視化することで、その機能に対する理解をいっそう深めることができます。ここでは練習として、加水分解酵素「<strong>アルカリホスファターゼ</strong>」のアミノ酸配列や立体構造に関するデータをデータベースから取得し、タンパク質の配列－構造－機能の関係を理解してみます。<strong>アルカリホスファターゼ</strong>は、我々の健康診断の時に肝臓の機能を測る指標（<strong>ALP</strong>）として、生活に関わっているタンパク質です。</p>
<p>それでは早速やっていきましょう。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="protein-data-bank-pdbにアクセスする-1"><a class="header" href="#protein-data-bank-pdbにアクセスする-1">Protein Data Bank (PDB)にアクセスする</a></h2>
<p>お使いのパソコンにインストールされているウェブブラウザ（Edge, Safari, Google Chrome, Firefoxなど）の検索エンジンに、「PDB」と入れて検索すると、<a href="https://www.rcsb.org/">RCSB PDB</a>のホームページが表示されます。</p>
<img src="ch01/./image/rcsbpdb1.png" width="70%">
<p>画面右上のボックスに「alkaline phosphatase」と入力し，ボックス右のGoボタンを押します。</p>
<img src="ch01/./image/rcsbpdb2.png" width="100%">
<p>メニュー左側に現れている「Refinements」の「ORGANISM」に表示されている「Escherichia coli」をクリックして検索ボタン（ルーペマーク）をクリックします。これで大腸菌由来の「alkaline phosphatase」に検索を絞り込むことができます。</p>
<img src="ch01/./image/rcsbpdb3.png" width="40%">
<p>右上の「Displaying 25 per page」の「25」を「100」に変更し，表示された結果の中から「1ALK」を探してクリックします（リストの一番下付近にあります）。</p>
<img src="ch01/./image/rcsbpdb4.png" width="100%">
<p>PDBの各エントリには、このように4文字の記号（<strong>PDB ID</strong>）が付けられています。なお、PDBのIDがあらかじめわかっている場合はテキストボックスにPDB IDを入れてGoボタンを押すことでも目的の構造のページに移動することができます。これによって、1ALKエントリの内容が表示されます。</p>
<img src="ch01/./image/rcsbpdb5.png" width="100%">
<p>最初のページには、このエントリのタイトル、登録日、由来する生物種や立体構造のグラフィックスなどが表示されています。さらに画面上方のタブをクリックすると、このタンパク質に関するさまざまなデータにアクセスできます。現在表示されているのは「Structure Summary」タブの内容です。</p>
<img src="ch01/./image/rcsbpdb6.png" width="100%">
<p>このStructure Summaryのタブのページで、以下のデータに注目してみましょう。</p>
<p>「<strong>Macromolecules</strong>」にはこのエントリのタンパク質の簡単な説明が記載されています。検索条件で指定したとおり、大腸菌（Escherichia coli）のアルカリホスファターゼであり、さらに分子量が94687.01であること、 449残基のアルカリホスファターゼ分子がA、 Bの2本のチェイン（鎖）として含まれていることなどがわかります。</p>
<img src="ch01/./image/rcsbpdb7.png" width="100%">
<p>「<strong>Small Molecules</strong>」にはこのエントリに含まれるタンパク質以外の低分子化合物や金属などの情報が記載されています。リン酸塩(<strong>PO4</strong>)、亜鉛イオン(<strong>ZN</strong>)、マグネシウムイオン(<strong>MG</strong>)が結合していることがわかります。このアルカリホスファターゼは、本来リン酸エステル化合物を加水分解する酵素であり、リン酸塩はこの酵素の<strong>阻害剤</strong>として結合している無機リン酸です。</p>
<img src="ch01/./image/rcsbpdb8.png" width="100%">
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="pdbデータのダウンロード"><a class="header" href="#pdbデータのダウンロード">PDBデータのダウンロード</a></h2>
<p>PDBの構造情報ファイルをダウンロードし、その中身を確認してみましょう。</p>
<p><strong>分子の立体構造データ</strong>の実体は、<strong>その分子を構成している各原子の\( xyz \)座標データの集まり</strong>です。PDB ID: 1ALKのStructure Summaryのタブに戻って右上の<strong>Display Files</strong>を左クリックし、さらに<strong>PDB Format</strong>を左クリックすると、開かれたタブの中にPDBデータの中身が表示されます。</p>
<p>最初に<code>HEADER</code>レコードや<code>REMARK</code>レコード、<code>SEQRES</code>レコードなどのヘッダ部があり、下方の<code>ATOM</code>（あるいは<code>HETATM</code>）レコードに分子を構成する各原子の\( xyz \)座標などが並んでいます。ヘッダ部には、この分子が由来する生物種や文献情報、構造決定方法に関する情報、アミノ酸配列、単量体か多量体か、構造中に含まれる金属や補酵素の情報などが書かれており、先程まで見ていたPDB ID: 1ALKのウェブページ上ではこれらの情報がわかりやすく整形されて表示されています。座標データは、20種類の標準アミノ酸は<code>ATOM</code>レコードに、それ以外の基質や金属、修飾アミノ酸などは<code>HETATM</code>レコードに記述されています。1ALKの<code>ATOM/HETATM</code>レコードに、タンパク質のAチェイン、 Bチェイン、続いて亜鉛（<code>ZN</code>）、マグネシウム（<code>MG</code>）、リン酸（<code>PO4</code>）、水分子（<code>HOH</code>）の座標データが並んでいることを確認してみましょう。</p>
<pre><code>HEADER:		PDB IDやタンパク質の種類，データ登録年月日
TITLE:		このデータを得た研究内容の簡単な説明
SOURCE:		その分子の由来（遺伝子名，生物種など）
AUTHOR:		著者名
JRNL:		立体構造が発表された文献情報
REMARK:		X線結晶解析の解像度やその他のコメントなど
SEQRES:		アミノ酸・塩基配列
HET:		標準アミノ酸・塩基以外の金属原子，基質などの情報
HELIX/SHEET/TURN:  2次構造情報
SSBOND:		ジスルフィド（S-S）結合
ATOM:		原子座標など
HETATM:		アミノ酸やヌクレオチド以外の原子（金属，基質化合物など）の座標など
TER: 		チェイン（chain, 鎖）の終わり
END:		エントリの終わり
</code></pre>
<p>なお、構造ファイルのデータフォーマットは、これまで伝統的に用いられてきた<strong>PDB format</strong>に代わって、2019年7月1日からは<strong>PDBx/mmCIF format</strong>が標準形式として採用されることになっています。このファイル形式は、人間にはわかりにくいがコンピュータで処理しやすい形式になっています。余裕があればこのフォーマットも新規タブで開いてみましょう。</p>
<p>では、大腸菌のアルカリホスファターゼの立体構造データをダウンロードして、手元のコンピュータの中で可視化し、実際の立体構造を見てみましょう。このための可視化ソフトウェアとして、ここでは無料で利用でき、かつ多くの種類のコンピュータ上で動作することができる<strong>PyMOL</strong>を利用します。</p>
<p>再びRCSB PDBの1ALKのページに戻って、画面右上の<strong>Download Files</strong>を左クリックし、メニューの中の<strong>PDB Format</strong>を右クリックして<strong>対象をファイルに保存</strong>を選択します。</p>
<img src="ch01/./image/rcsbpdb_down.png" width="250px">
<p>ここで、ファイル名を<code>1alk.pdb</code>とします。PDBファイルが<code>ダウンロード</code>のフォルダにダウンロードされるので、そこから<code>デスクトップ</code>にファイルを移動させます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="pymolの起動-1"><a class="header" href="#pymolの起動-1">PyMOLの起動</a></h2>
<p>それではPyMOLを起動してみましょう。起動の仕方は、お使いのパソコン・macによってやり方が変わります。もしまだPyMOLをインストールしていない場合は、<a href="ch01/../append01/installation.html">インストール方法</a>を参照してください。</p>
<h3 id="windows-10の場合-1"><a class="header" href="#windows-10の場合-1">Windows 10の場合</a></h3>
<p>（調査中です）</p>
<h3 id="macos-バイナリ版の場合-1"><a class="header" href="#macos-バイナリ版の場合-1">macOS (バイナリ版)の場合</a></h3>
<p>初心者向けです。バイナリ版をインストールした場合、Finderから[アプリケーション]を選択して中にあるPyMOLをダブルクリックすることで起動できます。</p>
<img src="ch01/./image/launch1.png" width="80%">
<h3 id="macosオープンソース版の場合-1"><a class="header" href="#macosオープンソース版の場合-1">macOS（オープンソース版の場合）</a></h3>
<p>ターミナル操作に習熟した上級者向けです。オープンソース版はHomebrewを使うことでインストールできます。（参考：<a href="ch01/../append01/installation.html">インストール方法</a>）
インストールに完了した後、[アプリケーション]→[ユーティリティ]→[ターミナル]を選択して、<code>pymol</code>と打てば起動します。実用上は <code>pymol &gt; /dev/null 2&gt;&amp;1 &amp;</code> とコマンドを打つ方が便利かもしれません。</p>
<h3 id="linuxの場合-1"><a class="header" href="#linuxの場合-1">Linuxの場合</a></h3>
<p>インストール完了後、ターミナルから <code>pymol</code> と打つことで起動します。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="大腸菌由来アルカリホスファターゼのグラフィック表示-1"><a class="header" href="#大腸菌由来アルカリホスファターゼのグラフィック表示-1">大腸菌由来アルカリホスファターゼのグラフィック表示</a></h2>
<p>PyMOLを起動した後、画面左上にある<code>File</code>メニューから<code>Open...</code>を選び、先程デスクトップに移動させた<code>1alk.pdb</code>ファイルを選択します。すると、PyMOL画面の中にPDB ID: 1ALKの<strong>大腸菌由来アルカリホスファターゼ</strong>が表示されます。</p>
<img src="ch01/./image/graphic1.png" width="100%" alt="PDB ID: 1ALKの大腸菌由来アルカリホスファターゼの図" title="PDB ID: 1ALKの大腸菌由来アルカリホスファターゼの図">
<p>このチュートリアルではPyMOLのGUI機能を駆使して、アルカリホスファターゼの2次構造の配置（フォールド）や、リン酸付近の原子・残基の配置などを調べてみます。必要に応じて<a href="ch01/../ch02/index.html">第2章 PyMOLのGUIの使い方</a>の<a href="ch01/../ch02/mouse.html">マウス操作</a> とMouse Mode: <a href="ch01/../ch02/buttontable.html">3-Button Viewing</a> を読みます。マウスで分子をドラッグすることで、分子の回転、平行移動、拡大縮小などが行うことができます。</p>
<p>PyMOLでは、まずマウス(または<code>select</code>コマンド)で原子やアミノ酸を<strong>選択(select)</strong> し、続いて選択した範囲に対する <strong>操作(Action)</strong> を指定します。選択された部分はピンクのマーカーで強調されるので、今何が「選択」されているかに常に注意します。また、<strong>操作のやり直しはできない</strong>ので、操作を間違えた場合にはその都度それを上書きする形で表示をやり直します。</p>
<img src="ch01/./image/graphic2.png" width="100%" alt="1ALKのAチェインを選択したときの図。ピンクのマーカーで覆われているのがAチェイン。配列の上でもハイライトされていることに留意しよう。" title="1ALKのAチェインを選択したときの図。ピンクのマーカーで覆われているのがAチェイン。配列の上でもハイライトされていることに留意しよう。">
<h3 id="チェインごとの色分け-1"><a class="header" href="#チェインごとの色分け-1">チェインごとの色分け</a></h3>
<p>このアルカリホスファターゼがホモ2量体であることをわかりやすく表示するために、Aチェインを緑色（デフォルト）、Bチェインを水色（cyan）で表示してみます。PyMOL右下の画面に<code>S</code>という小さなボタンがあるので、ここを押すと、タンパク質が表示されている画面の上にアミノ酸配列が現れます（参考： <a href="ch01/../ch02/dispseq.html">配列の表示について</a> ）。</p>
<img src="ch01/./image/colorchain.png" alt="チェインごとの色分け">
<p>今表示されたアミノ酸配列の上で、マウスを使ってチェインBをすべて選択します。次に、色の設定を参考にしてチェインBを水色に変更します（参考：<a href="ch01/../ch02/color.html">色の設定</a> ）。</p>
<p>※ PyMOLの画面上に存在する入力欄<code>PyMOL&gt; </code>の所（中段上と一番下の2ヶ所に存在しますが、どちらに入力してもOK）で上や下の矢印キーを押すと、それまでに入力したコマンドを再び呼び出すことができます。また左右の矢印キーを使って、以前使ったコマンドを自由に編集できます。同じコマンドを何度も入力するのは面倒なので、上下左右の矢印キーを上手に使いましょう。</p>
<h3 id="二次構造ごとの色分け-1"><a class="header" href="#二次構造ごとの色分け-1">二次構造ごとの色分け</a></h3>
<p>この大腸菌アルカリホスファターゼを、今度は二次構造による色分けを使って表示してみます（参考： <a href="ch01/../ch02/color.html">色の設定について</a> ）。</p>
<p>オブジェクトパネルにおける<code>1ALK</code>のCのところをクリックし、Colorのメニューのところで、[by ss]にマウスを重ねます。色分けの種類はデフォルトで3種類用意されており、どれを使っても問題ありませんが、ここでは一番上の例（ヘリックス:赤; シート:黄; ループ:緑）のカラーリングで表示してみます。</p>
<img src="ch01/./image/colorbyss1.png" alt="" title="">
<p>このように表示されるはずです。</p>
<img src="ch01/./image/colorbyss2.png" alt="" title="">
<p>ここで、大腸菌アルカリホスファターゼの立体構造のCATHによる分類は、&quot;Alpha Beta 3-Layer(aba) Sandwich&quot;とされています。Cartoon表示で見る角度を調節して、このタンパク質の立体構造がCATHの分類通りにAlpha Betaの3層構造を形成していることを確認してみましょう。</p>
<h3 id="画像の保存-1"><a class="header" href="#画像の保存-1">画像の保存</a></h3>
<p>画面に映されているタンパク質を画像ファイルとして保存します。ただし、そのまま保存しようとすると背景が黒のままとなってしまいます。</p>
<img src="ch01/./image/saveimage1.png" alt="黒背景のままの保存">
<p>これを白背景で出力します。上部のDisplay &gt; Backgroundメニューから、Whiteを選択します。</p>
<img src="ch01/./image/saveimage2.png" alt="白背景">
<p>この設定の後、PyMOL画面の右上に存在するDraw/Rayボタンを押し、<code>Draw (fast)</code>または<code>Ray (slow)</code>ボタンを押すと、きれいな画像となって表示されます。</p>
<img src="ch01/../ch02/image/saveimage/saveimage5.png" alt="白背景" width="60%">
<p>問題がなければ、<code>Save Image to File</code>ボタンを押し、ファイル名を設定して保存しましょう。ちなみに、<code>transparent background</code>にチェックを入れると背景透過画像を生成することができます（ただし<code>Ray (slow)</code>を適用した場合のみ）。背景透過処理を行うとレポートやスライドの上で扱いやすくなるので、ぜひ利用しましょう。</p>
<p>その他の詳しい項目については<a href="ch01/../ch02/saveimage.html">2.7 画像の保存</a>を参照してください。</p>
<h3 id="セッションファイルへの保存-1"><a class="header" href="#セッションファイルへの保存-1">セッションファイルへの保存</a></h3>
<p>ここまでの作業内容をセッションファイルに保存します。セッションファイルとは、現在のPyMOLの画面の状態をそのまま保存しておくファイルのことです。画面上部にあるFileメニューから<code>Save session as…</code>を選んで名前を指定して保存します(<code>kadai1.pse</code>など、わかりやすい名前をつけましょう)。（参考：<a href="ch01/../ch02/session.html">セッションの保存</a> ）。</p>
<img src="ch01/./image/savesession.png" width="300px" alt="セッションファイルへの保存">
<p>保存したセッションファイルはFile &gt; Openメニューから読み込むことができます。</p>
<img src="ch01/./image/fileopen.png" width="300px" alt="ファイルを開く">
<p>すでにタンパク質を他に表示させている状態でセッションファイルを読み込もうとすると下図のようなメッセージが現れますが、今開いている画面と別のPyMOL画面でタンパク質を表示させたい場合は、一番下の<code>Open in new PyMOL Window</code>を選択することをおすすめします。</p>
<img src="ch01/./image/loadsession.png" width="300px" alt="セッションを開く時のプロンプト画面">
<p>※ （上級者向け）上述の<code>PyMOL&gt; </code>の入力欄にコマンドを入力することでも可能です。デスクトップ上に保存したい場合は、<code>cd ~/Desktop</code>としてWorking Directoryをデスクトップに設定した後、<code>save kadai1.pse</code>とすることでセッションファイルを保存できます。</p>
<h3 id="リガンド結合部位への注目-1"><a class="header" href="#リガンド結合部位への注目-1">リガンド結合部位への注目</a></h3>
<p>ここから、タンパク質内の<strong>リン酸や金属が結合している部分</strong>に注目してみます。まず、全体構造の中のどこに結合しているかを確認してみます。</p>
<ul>
<li>PyMOL内で<a href="ch01/../ch02/dispseq.html">配列を表示</a>させます。</li>
<li>表示された配列のところで、Chain Aの<code>ZN</code>2つと<code>MG</code>,<code>PO4</code>をすべて<strong>選択</strong>します。</li>
<li>次に、<a href="ch01/../ch02/objpanel.html">オブジェクトパネル</a>においてその選択範囲<code>(sele)</code>についてStickとSpheresで表示させてみます（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。</li>
</ul>
<img src="ch01/./image/focus1.png" width="100%" alt="" title="">
<p>デフォルト設定では、sphere表示で表されるボールがかなり大きくなっているので、ここではいったん小さくしてみます。これは<code>PyMOL &gt;</code>のところにコマンドを打つことで設定できます。</p>
<pre><code>set sphere_scale, 0.4
</code></pre>
<p>これで球が小さく表示されました。</p>
<img src="ch01/./image/focus2.png" width="100%" alt="" title="">
<p>ここで、表示をチェインA（A鎖）だけにし、Bチェインはhideで隠します（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。リン酸や金属は各チェインに1組ずつ結合していることがわかります。</p>
<img src="ch01/./image/focus3.png" width="100%" alt="" title="">
<p>チェインAのリン酸(<code>PO4</code>)が画面の中心にくるよう設定してみます。これはこの<code>PO4</code>を選択した上で右クリックを押してメニューを表示させ、<code>center</code>を選択することでできます。
参考：<a href="ch01/../ch02/mouse.html">マウス操作</a>と<a href="ch01/(../ch02/buttontable.html">各モードにおける操作一覧</a></p>
<img src="ch01/./image/focus4.png" width="100%" alt="" title="">
<p>マウス操作で、画面を拡大して見やすくしておきます。</p>
<p>タンパク質のCartoon表示をオフにします（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。</p>
<p>チェインAのリン酸から4.6 Å以内にある水分子以外のアミノ酸残基を表示させます。チェインAのリン酸<code>PO4</code>だけが選択された状態で以下のコマンドを打ちます。</p>
<pre><code>select byres resn * within 4.6 of sele
show sticks, sele
</code></pre>
<p>ここで、<code>byres</code>は「残基単位での選択」を意味する設定であり、とある残基が1原子でもリン酸から4.6 Åの距離以内に存在するのであれば、その残基をすべて選択するようにしています。その後、2行目のコマンドで選択した範囲を<code>sticks</code>で表示させます（オブジェクトパネルでも可能）</p>
<p>Zn，Mgは原子種ごとの色分け（→<a href="ch01/../ch02/color.html">色の設定</a>）にします。</p>
<p>リン酸付近にどのようなアミノ酸種が分布しているかを確認するために、先程の選択範囲<code>(sele)</code>について、<a href="ch01/../ch02/label.html">ラベルの設定</a>で<code>label</code> -&gt; <code>residues</code>を選択します。</p>
<img src="ch01/./image/focus5.png" width="100%" alt="" title="">
<p>PyMOL画面を回転させて、どのアミノ酸がこのリガンド結合部位に存在しているかをすべてメモします。目視で行っても構いませんが、ここではPyMOLがPythonプログラミングで動いているということを利用して、以下のコマンドを入力して確認してみましょう。</p>
<p>コマンド入力欄に以下のコマンドを順次入れていきます（コピー＆ペースト可能）。</p>
<pre><code class="language-python"># チェインAのリン酸を選択する(残基名がPO4でかつchain Aのものをselectする)
select resn PO4 and chain A
# 現在の選択範囲から4.6Å以内にある分子を、残基単位(byres)ですべて選択する
select byres resn * within 4.6 of sele

# ここで空の配列であるreslistを作成しておく（初期化）
reslist = []
# pymolのiterateコマンドを用いて、選択範囲(sele)に存在するCα炭素(name CA)について
# (residue_id, residue_name)のタプルをreslistに繰り返し加えていく
iterate sele and name CA, reslist.append((resi, resn))
# reslistを表示する
print(reslist)
</code></pre>
<p>ここまでうまく入力されていれば、最後に以下のように結果が表示されるはずです。</p>
<pre><code>PyMOL&gt; print(reslist)
[('51', 'ASP'), ('101', 'ASP'), ('102', 'SER'), ('153', 'ASP'), ('166', 'ARG'), ('327', 'ASP'), ('331', 'HIS'), ('369', 'ASP'), ('370', 'HIS'), ('412', 'HIS')]
</code></pre>
<p>これはpythonで言うところの、リスト型変数<code>reslist</code>の中にタプル型で（残基番号, 3文字残基名）の組が入っている形になっています。</p>
<p>これをよく生物学の表示で使われるようなMET-1, ASP-2のような表示に変換したい場合は、pythonのprint文を知識を使って例えば以下のようにpythonプログラムを書けばうまく出力することができます。ただし、PyMOLのコマンドラインでpythonプログラムを書く場合は<code>python</code>と<code>python end</code>というブロックの間に挟む必要があります。（参考： https://pymolwiki.org/index.php/Python ）</p>
<pre><code class="language-python">python
# リスト内のタプルをi, jに代入するfor loop
for i, j in reslist:
    # print&amp;format文法を使って&quot;{residue_name}-{residue_id}&quot;の順番で表示する
	print(&quot;{0}-{1}&quot;.format(j, i))

python end
</code></pre>
<p>すると、以下のように表示されます。</p>
<pre><code>PyMOL&gt;python end

ASP-51
ASP-101
SER-102
ASP-153
ARG-166
ASP-327
HIS-331
ASP-369
HIS-370
HIS-412
</code></pre>
<p>こうすれば目視でやるより書き漏らしがなくて済みますね。</p>
<p>終わったら、再び現在までの作業内容をセッションファイルに保存しておきます。ファイル名はたとえば<code>1alk_active_site.pse</code>などとしておくと分かりやすくて良いでしょう。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="チェインごとの色分け-2"><a class="header" href="#チェインごとの色分け-2">チェインごとの色分け</a></h3>
<p>このアルカリホスファターゼがホモ2量体であることをわかりやすく表示するために、Aチェインを緑色（デフォルト）、Bチェインを水色（cyan）で表示してみます。PyMOL右下の画面に<code>S</code>という小さなボタンがあるので、ここを押すと、タンパク質が表示されている画面の上にアミノ酸配列が現れます（参考： <a href="ch01/../ch02/dispseq.html">配列の表示について</a> ）。</p>
<img src="ch01/./image/colorchain.png" alt="チェインごとの色分け">
<p>今表示されたアミノ酸配列の上で、マウスを使ってチェインBをすべて選択します。次に、色の設定を参考にしてチェインBを水色に変更します（参考：<a href="ch01/../ch02/color.html">色の設定</a> ）。</p>
<p>※ PyMOLの画面上に存在する入力欄<code>PyMOL&gt; </code>の所（中段上と一番下の2ヶ所に存在しますが、どちらに入力してもOK）で上や下の矢印キーを押すと、それまでに入力したコマンドを再び呼び出すことができます。また左右の矢印キーを使って、以前使ったコマンドを自由に編集できます。同じコマンドを何度も入力するのは面倒なので、上下左右の矢印キーを上手に使いましょう。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="二次構造ごとの色分け-2"><a class="header" href="#二次構造ごとの色分け-2">二次構造ごとの色分け</a></h3>
<p>この大腸菌アルカリホスファターゼを、今度は二次構造による色分けを使って表示してみます（参考： <a href="ch01/../ch02/color.html">色の設定について</a> ）。</p>
<p>オブジェクトパネルにおける<code>1ALK</code>のCのところをクリックし、Colorのメニューのところで、[by ss]にマウスを重ねます。色分けの種類はデフォルトで3種類用意されており、どれを使っても問題ありませんが、ここでは一番上の例（ヘリックス:赤; シート:黄; ループ:緑）のカラーリングで表示してみます。</p>
<img src="ch01/./image/colorbyss1.png" alt="" title="">
<p>このように表示されるはずです。</p>
<img src="ch01/./image/colorbyss2.png" alt="" title="">
<p>ここで、大腸菌アルカリホスファターゼの立体構造のCATHによる分類は、&quot;Alpha Beta 3-Layer(aba) Sandwich&quot;とされています。Cartoon表示で見る角度を調節して、このタンパク質の立体構造がCATHの分類通りにAlpha Betaの3層構造を形成していることを確認してみましょう。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="画像の保存-2"><a class="header" href="#画像の保存-2">画像の保存</a></h3>
<p>画面に映されているタンパク質を画像ファイルとして保存します。ただし、そのまま保存しようとすると背景が黒のままとなってしまいます。</p>
<img src="ch01/./image/saveimage1.png" alt="黒背景のままの保存">
<p>これを白背景で出力します。上部のDisplay &gt; Backgroundメニューから、Whiteを選択します。</p>
<img src="ch01/./image/saveimage2.png" alt="白背景">
<p>この設定の後、PyMOL画面の右上に存在するDraw/Rayボタンを押し、<code>Draw (fast)</code>または<code>Ray (slow)</code>ボタンを押すと、きれいな画像となって表示されます。</p>
<img src="ch01/../ch02/image/saveimage/saveimage5.png" alt="白背景" width="60%">
<p>問題がなければ、<code>Save Image to File</code>ボタンを押し、ファイル名を設定して保存しましょう。ちなみに、<code>transparent background</code>にチェックを入れると背景透過画像を生成することができます（ただし<code>Ray (slow)</code>を適用した場合のみ）。背景透過処理を行うとレポートやスライドの上で扱いやすくなるので、ぜひ利用しましょう。</p>
<p>その他の詳しい項目については<a href="ch01/../ch02/saveimage.html">2.7 画像の保存</a>を参照してください。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="セッションファイルへの保存-2"><a class="header" href="#セッションファイルへの保存-2">セッションファイルへの保存</a></h3>
<p>ここまでの作業内容をセッションファイルに保存します。セッションファイルとは、現在のPyMOLの画面の状態をそのまま保存しておくファイルのことです。画面上部にあるFileメニューから<code>Save session as…</code>を選んで名前を指定して保存します(<code>kadai1.pse</code>など、わかりやすい名前をつけましょう)。（参考：<a href="ch01/../ch02/session.html">セッションの保存</a> ）。</p>
<img src="ch01/./image/savesession.png" width="300px" alt="セッションファイルへの保存">
<p>保存したセッションファイルはFile &gt; Openメニューから読み込むことができます。</p>
<img src="ch01/./image/fileopen.png" width="300px" alt="ファイルを開く">
<p>すでにタンパク質を他に表示させている状態でセッションファイルを読み込もうとすると下図のようなメッセージが現れますが、今開いている画面と別のPyMOL画面でタンパク質を表示させたい場合は、一番下の<code>Open in new PyMOL Window</code>を選択することをおすすめします。</p>
<img src="ch01/./image/loadsession.png" width="300px" alt="セッションを開く時のプロンプト画面">
<p>※ （上級者向け）上述の<code>PyMOL&gt; </code>の入力欄にコマンドを入力することでも可能です。デスクトップ上に保存したい場合は、<code>cd ~/Desktop</code>としてWorking Directoryをデスクトップに設定した後、<code>save kadai1.pse</code>とすることでセッションファイルを保存できます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="リガンド結合部位への注目-2"><a class="header" href="#リガンド結合部位への注目-2">リガンド結合部位への注目</a></h3>
<p>ここから、タンパク質内の<strong>リン酸や金属が結合している部分</strong>に注目してみます。まず、全体構造の中のどこに結合しているかを確認してみます。</p>
<ul>
<li>PyMOL内で<a href="ch01/../ch02/dispseq.html">配列を表示</a>させます。</li>
<li>表示された配列のところで、Chain Aの<code>ZN</code>2つと<code>MG</code>,<code>PO4</code>をすべて<strong>選択</strong>します。</li>
<li>次に、<a href="ch01/../ch02/objpanel.html">オブジェクトパネル</a>においてその選択範囲<code>(sele)</code>についてStickとSpheresで表示させてみます（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。</li>
</ul>
<img src="ch01/./image/focus1.png" width="100%" alt="" title="">
<p>デフォルト設定では、sphere表示で表されるボールがかなり大きくなっているので、ここではいったん小さくしてみます。これは<code>PyMOL &gt;</code>のところにコマンドを打つことで設定できます。</p>
<pre><code>set sphere_scale, 0.4
</code></pre>
<p>これで球が小さく表示されました。</p>
<img src="ch01/./image/focus2.png" width="100%" alt="" title="">
<p>ここで、表示をチェインA（A鎖）だけにし、Bチェインはhideで隠します（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。リン酸や金属は各チェインに1組ずつ結合していることがわかります。</p>
<img src="ch01/./image/focus3.png" width="100%" alt="" title="">
<p>チェインAのリン酸(<code>PO4</code>)が画面の中心にくるよう設定してみます。これはこの<code>PO4</code>を選択した上で右クリックを押してメニューを表示させ、<code>center</code>を選択することでできます。
参考：<a href="ch01/../ch02/mouse.html">マウス操作</a>と<a href="ch01/(../ch02/buttontable.html">各モードにおける操作一覧</a></p>
<img src="ch01/./image/focus4.png" width="100%" alt="" title="">
<p>マウス操作で、画面を拡大して見やすくしておきます。</p>
<p>タンパク質のCartoon表示をオフにします（→<a href="ch01/../ch02/showandhide.html">分子構造の表示形式のON/OFF</a>）。</p>
<p>チェインAのリン酸から4.6 Å以内にある水分子以外のアミノ酸残基を表示させます。チェインAのリン酸<code>PO4</code>だけが選択された状態で以下のコマンドを打ちます。</p>
<pre><code>select byres resn * within 4.6 of sele
show sticks, sele
</code></pre>
<p>ここで、<code>byres</code>は「残基単位での選択」を意味する設定であり、とある残基が1原子でもリン酸から4.6 Åの距離以内に存在するのであれば、その残基をすべて選択するようにしています。その後、2行目のコマンドで選択した範囲を<code>sticks</code>で表示させます（オブジェクトパネルでも可能）</p>
<p>Zn，Mgは原子種ごとの色分け（→<a href="ch01/../ch02/color.html">色の設定</a>）にします。</p>
<p>リン酸付近にどのようなアミノ酸種が分布しているかを確認するために、先程の選択範囲<code>(sele)</code>について、<a href="ch01/../ch02/label.html">ラベルの設定</a>で<code>label</code> -&gt; <code>residues</code>を選択します。</p>
<img src="ch01/./image/focus5.png" width="100%" alt="" title="">
<p>PyMOL画面を回転させて、どのアミノ酸がこのリガンド結合部位に存在しているかをすべてメモします。目視で行っても構いませんが、ここではPyMOLがPythonプログラミングで動いているということを利用して、以下のコマンドを入力して確認してみましょう。</p>
<p>コマンド入力欄に以下のコマンドを順次入れていきます（コピー＆ペースト可能）。</p>
<pre><code class="language-python"># チェインAのリン酸を選択する(残基名がPO4でかつchain Aのものをselectする)
select resn PO4 and chain A
# 現在の選択範囲から4.6Å以内にある分子を、残基単位(byres)ですべて選択する
select byres resn * within 4.6 of sele

# ここで空の配列であるreslistを作成しておく（初期化）
reslist = []
# pymolのiterateコマンドを用いて、選択範囲(sele)に存在するCα炭素(name CA)について
# (residue_id, residue_name)のタプルをreslistに繰り返し加えていく
iterate sele and name CA, reslist.append((resi, resn))
# reslistを表示する
print(reslist)
</code></pre>
<p>ここまでうまく入力されていれば、最後に以下のように結果が表示されるはずです。</p>
<pre><code>PyMOL&gt; print(reslist)
[('51', 'ASP'), ('101', 'ASP'), ('102', 'SER'), ('153', 'ASP'), ('166', 'ARG'), ('327', 'ASP'), ('331', 'HIS'), ('369', 'ASP'), ('370', 'HIS'), ('412', 'HIS')]
</code></pre>
<p>これはpythonで言うところの、リスト型変数<code>reslist</code>の中にタプル型で（残基番号, 3文字残基名）の組が入っている形になっています。</p>
<p>これをよく生物学の表示で使われるようなMET-1, ASP-2のような表示に変換したい場合は、pythonのprint文を知識を使って例えば以下のようにpythonプログラムを書けばうまく出力することができます。ただし、PyMOLのコマンドラインでpythonプログラムを書く場合は<code>python</code>と<code>python end</code>というブロックの間に挟む必要があります。（参考： https://pymolwiki.org/index.php/Python ）</p>
<pre><code class="language-python">python
# リスト内のタプルをi, jに代入するfor loop
for i, j in reslist:
    # print&amp;format文法を使って&quot;{residue_name}-{residue_id}&quot;の順番で表示する
	print(&quot;{0}-{1}&quot;.format(j, i))

python end
</code></pre>
<p>すると、以下のように表示されます。</p>
<pre><code>PyMOL&gt;python end

ASP-51
ASP-101
SER-102
ASP-153
ARG-166
ASP-327
HIS-331
ASP-369
HIS-370
HIS-412
</code></pre>
<p>こうすれば目視でやるより書き漏らしがなくて済みますね。</p>
<p>終わったら、再び現在までの作業内容をセッションファイルに保存しておきます。ファイル名はたとえば<code>1alk_active_site.pse</code>などとしておくと分かりやすくて良いでしょう。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="ヒトアルカリホスファターゼとの構造比較-1"><a class="header" href="#ヒトアルカリホスファターゼとの構造比較-1">ヒトアルカリホスファターゼとの構造比較</a></h2>
<p>ヒトアルカリホスファターゼも立体構造が解かれ、PDBに登録されている（<a href="https://www.rcsb.org/structure/1EW2">PDB ID: 1EW2</a>）。大腸菌アルカリホスファターゼとの類似点・相違点を調べてみよう。</p>
<p>ヒトアルカリホスファターゼと大腸菌アルカリホスファターゼのアミノ酸一致度は30%弱である。つまり平均すると10箇所のうち7箇所以上はアミノ酸が異なっていることになります。では、<strong>ヒトアルカリホスファターゼは大腸菌アルカリホスファターゼとまったく異なるやり方でリン酸エステル化合物の加水分解を行っているのだろうか？それとも似た反応機構をもっているのでしょうか</strong>。立体構造の観点から調べてみましょう。</p>
<h3 id="ヒトアルカリホスファターゼの構造ファイルのダウンロード-1"><a class="header" href="#ヒトアルカリホスファターゼの構造ファイルのダウンロード-1">ヒトアルカリホスファターゼの構造ファイルのダウンロード</a></h3>
<p>まず大腸菌のときと同様に、RCSB PDBから1EW2のPDBファイルをダウンロードします（参考：<a href="ch01/../ch02/loadmol.html">分子構造のロード</a>）。次に、すでに1ALKの構造を開いているPyMOLの中で、この1EW2の構造ファイルをロードします。しかし、ここで1ALKのときと違いChain Aしか表示されていないことに気付くでしょう。1EW2も1ALKと同様にBiological unitはホモダイマーですが、この構造ファイルには結晶の対称性を考慮してチェイン1本分の座標しか入っていない状態になっています。このような場合はPyMOLの機能を使って、結晶の対称性からもう1本のチェインの座標データを生成することができます。</p>
<p><a href="ch01/../ch02/loadmol.html#biological-unit%E3%82%92%E8%80%83%E6%85%AE%E3%81%97%E3%81%9F%E5%88%86%E5%AD%90%E6%A7%8B%E9%80%A0%E3%81%AE%E3%83%AD%E3%83%BC%E3%83%89">Biological unitを考慮した分子構造のロード</a>のページを参考に、1EW2の構造を2量体でロードします。1EW2の各チェインは<code>1ew2_0001</code>, <code>1ew2_0002</code>と表示されることになります。ここで、わかりやすくするために大腸菌のアルカリホスファターゼを緑色に、今開いたヒトアルカリホスファターゼの2量体を水色で表示させておきます。</p>
<img src="ch01/./image/compare1.png" alt="1ALK（緑）と1EW2（青）の2量体表示" title="1ALK（緑）と1EW2（青）の2量体表示">
<h3 id="2つのアルカリホスファターゼの構造の重ね合わせ-1"><a class="header" href="#2つのアルカリホスファターゼの構造の重ね合わせ-1">2つのアルカリホスファターゼの構造の重ね合わせ</a></h3>
<p>では、大腸菌とヒトのアルカリホスファターゼの構造をそれぞれ重ね合わせることで比較してみましょう。ここではPyMOLの<code>super</code>という重ね合わせ用のコマンドを使います。</p>
<p>今、画面には<code>1alk</code>と<code>1ew2_0001</code>, <code>1ew2_0002</code>のオブジェクトが存在しているはずです。ここで、<code>1alk</code>オブジェクトを<code>1ew2_0001</code>オブジェクトに重ね合わせることを以下のコマンドで行います（※<strong><code>1ew2_0001</code>を<code>1alk</code>に、ではないことに注意</strong>）。このコマンドは</p>
<pre><code>super 1alk, 1ew2_0001
</code></pre>
<p>です。これを行うと、</p>
<img src="ch01/./image/compare2.png" alt="1ALK（緑）と1EW2（青）の重ね合わせ結果" title="1ALK（緑）と1EW2（青）の重ね合わせ結果">
<p>図のように大腸菌ホスファターゼとヒトアルカリホスファターゼを重ねることができます（図では背景をグレーにしています）。また、画面上部のPyMOLコンソール画面には2つの構造のRMSD値が表示されます。</p>
<img src="ch01/./image/compare3.png" alt="PyMOLコンソール画面" title="PyMOLコンソール画面">
<pre><code>PyMOL&gt;super 1alk, 1ew2_0001
 MatchAlign: aligning residues (898 vs 479)...
 MatchAlign: score 740.851
 ExecutiveAlign: 1947 atoms aligned.
 ExecutiveRMS: 83 atoms rejected during cycle 1 (RMSD=4.31).
 ExecutiveRMS: 135 atoms rejected during cycle 2 (RMSD=2.64).
 ExecutiveRMS: 187 atoms rejected during cycle 3 (RMSD=2.03).
 ExecutiveRMS: 135 atoms rejected during cycle 4 (RMSD=1.39).
 ExecutiveRMS: 87 atoms rejected during cycle 5 (RMSD=1.03).
 Executive: RMSD =    0.864 (1320 to 1320 atoms)
</code></pre>
<p>この結果、0.864 Åというとても小さなRMSD値が得られました。これはこの2つの構造の差が小さいことを表しています。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="タンパク質の疎水性親水性残基の分布を確認する-1"><a class="header" href="#タンパク質の疎水性親水性残基の分布を確認する-1">タンパク質の疎水性・親水性残基の分布を確認する</a></h2>
<p>タンパク質を構成しているアミノ酸は通常20種類ですが、その20種類のアミノ酸を化学的な性質に基づいて<strong>親水性・疎水性</strong>で分類することがあります。この親水性とは水に対して親和性が高いという意味で、疎水性は反対に親和性が低いということを意味します。特に、<strong>水素結合を形成しやすい</strong>側鎖を持つアミノ酸は<strong>親水性アミノ酸</strong>と呼ばれ、そうでないものは<strong>疎水性アミノ酸</strong>と呼ばれます。</p>
<p>親水性アミノ酸は以下のアミノ酸が該当します。pH 7.0の中性溶液中で持つ電荷についても示します。</p>
<ul>
<li>酸性アミノ酸（負電荷を持つ）
<ul>
<li>アスパラギン酸（Asp, D）</li>
<li>グルタミン酸（Glu, E）</li>
</ul>
</li>
<li>塩基性アミノ酸（正電荷を持つ）
<ul>
<li>リジン（Lys, K）</li>
<li>アルギニン（Arg, R）</li>
</ul>
</li>
<li>中性アミノ酸
<ul>
<li>スレオニン（Thr, T）</li>
<li>セリン（Ser, S）</li>
<li>アスパラギン（Asn, N）</li>
<li>グルタミン（Gln, Q）</li>
<li>ヒスチジン（His, H）</li>
</ul>
</li>
</ul>
<p>また、これらの親水性度・疎水性度を数値化した研究も存在しています（<a href="https://www.sciencedirect.com/science/article/abs/pii/0022283684903097?via%3Dihub"><em>J. Mol. Biol.</em> 179:125-142 (1984)</a>）。これによれば、</p>
<table><thead><tr><th>アミノ酸</th><th align="right">疎水性度</th></tr></thead><tbody>
<tr><td>Ala</td><td align="right">0.620</td></tr>
<tr><td>Arg</td><td align="right">-2.530</td></tr>
<tr><td>Asn</td><td align="right">-0.780</td></tr>
<tr><td>Asp</td><td align="right">-0.900</td></tr>
<tr><td>Cys</td><td align="right">0.290</td></tr>
<tr><td>Gln</td><td align="right">-0.850</td></tr>
<tr><td>Glu</td><td align="right">-0.740</td></tr>
<tr><td>Gly</td><td align="right">0.480</td></tr>
<tr><td>His</td><td align="right">-0.400</td></tr>
<tr><td>Ile</td><td align="right">1.380</td></tr>
<tr><td>Leu</td><td align="right">1.060</td></tr>
<tr><td>Lys</td><td align="right">-1.500</td></tr>
<tr><td>Met</td><td align="right">0.640</td></tr>
<tr><td>Phe</td><td align="right">1.190</td></tr>
<tr><td>Pro</td><td align="right">0.120</td></tr>
<tr><td>Ser</td><td align="right">-0.180</td></tr>
<tr><td>Thr</td><td align="right">-0.050</td></tr>
<tr><td>Trp</td><td align="right">0.810</td></tr>
<tr><td>Tyr</td><td align="right">0.260</td></tr>
<tr><td>Val</td><td align="right">1.080</td></tr>
</tbody></table>
<p>となっています（値が高いほど疎水性、低いほど親水性）。</p>
<p>一方で、これまで見てきたようにタンパク質はある1つの決まった形を取るように折りたたまっています。このとき親水性・疎水性アミノ酸はタンパク質構造上でどのように分布しているかを、PyMOLに表示した大腸菌アルカリホスファターゼを例にとって確認してみましょう。</p>
<p>まずあらためて大腸菌アルカリホスファターゼ（PDB ID: 1ALK）をロードし直しておきます。</p>
<img src="ch01/./image/hyph1.png">
<p>続いて、この構造を上の表で登場したアミノ酸の親水性・疎水性基準に従って、アミノ酸の側鎖を色分けしてみます。親水性のアミノ酸（表で0以下の値を持つアミノ酸）をすべて水色に、疎水性アミノ酸をすべてオレンジ色に塗ってみます。このとき、すべてのアミノ酸をマウスで選ぶのは大変なので、PyMOLのコマンドラインを活用します。</p>
<p>PyMOLソフトウェアの<code>PyMOL&gt;</code>と書かれている欄にまず<code>select hydrophobic,(resn ala+cys+gly+val+ile+leu+phe+pro+met+trp+tyr)</code>と入れてEnterキーを入力すると、疎水性アミノ酸たちが<code>hydrophobic</code>という名前の選択範囲が保存されます。この後、この選択範囲をオレンジ色にするために<code>color orange, hydrophobic</code>というコマンドを入力します。同様にして、すべての親水性アミノ酸を<code>hydrophilic</code>という名前の選択範囲として登録しておき、これをシアン色に色付けします。最後に、これらのアミノ酸残基の体積を強調するためにSphere表示にしてみます。</p>
<p>以上のコマンドは</p>
<pre><code class="language-bash"># 疎水性残基をhydrophobicという名前の選択範囲として保存
select hydrophobic,(resn ala+cys+gly+val+ile+leu+phe+pro+met+trp+tyr)
# 選択範囲hydrophobicをorange色にする
color orange,hydrophobic
# 親水性残基をhydrophobicという名前の選択範囲として保存
select hydrophilic,(resn arg+asn+asp+gln+glu+his+lys+ser+thr)
# 選択範囲hydrophilicをcyan色にする
color cyan, hydrophilic
# すべての残基をsphere表示にする
show spheres, all
</code></pre>
<p>と打っていくことで達成されます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/hyph2.mp4" type="video/mp4">
</video>
<p>このように色付けをしてみると、大腸菌アルカリホスファターゼの表面には親水性の残基が比較的多く分布していることがわかります。</p>
<p>ここで、PyMOLのマウス機能の1つである<a href="ch01/../ch02/buttonaction.html#%E3%82%B9%E3%83%A9%E3%83%93%E3%83%B3%E3%82%B0slab">Slab</a>を使ってタンパク質の中を覗いてみます。Slabはマウスのホイールを回転させて行います（Macbookなどに付属しているタッチパッドで行う場合は、タッチパッドに2本指を置いて上下に動かします）</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/hyph3.mp4" type="video/mp4">
</video>
<p>すると、アルカリホスファターゼのタンパク質構造の内部には<strong>疎水性アミノ酸がとても密に詰まっていることがわかる</strong>と思います。その一方で、表面にはやはり親水性アミノ酸が分布していることから、<strong>タンパク質構造の外側には親水性アミノ酸が、内側には疎水性アミノ酸が</strong>それぞれ分布していることがわかります。</p>
<p>このことはアルカリホスファターゼに限らず他の多くのタンパク質についても一般に成立します。ただこのアミノ酸の分布は親水性・疎水性アミノ酸の性質からすると当然のことを言っているに過ぎないと思われるかもしれません。しかしながら、これらの大きな疎水性アミノ酸のかたまり、通称<strong>疎水性コア</strong>は、タンパク質構造を安定に保つために重要な役割を果たしています。</p>
<p>水溶液中で安定に存在できる球状タンパク質は、疎水性アミノ酸が周囲の水分子と反発することによって親水性アミノ酸を外側へ、疎水性アミノ酸は内側へ集中させることから生まれる<strong>疎水性相互作用</strong>によって構造を形成していくことが知られています。そしてこの疎水性コアは疎水性アミノ酸同士の側鎖が密にパッキングすることによって文字通り隙間なく形成されており、これによってタンパク質全体の構造の安定性を大きく伸ばすことに貢献しています。タンパク質構造で注目されがちなのは親水性アミノ酸がよく用いられ外側に露出している活性部位（大腸菌アルカリホスファターゼで言うところのSer102, Arg166周辺）なのですが、こうした構造の成り立ちに関わるアミノ酸の分布のことも重要であることを覚えておくと、タンパク質構造についての理解がより深まると思います。</p>
<p>補足ですが、タンパク質アミノ酸を疎水性・親水性に応じて色分けを行うための拡張コマンドとして<code>color_h</code>, <code>color_h2</code>が存在します（<a href="https://pymolwiki.org/index.php/Color_h">https://pymolwiki.org/index.php/Color_h</a>）。<code>color_h</code>, <code>color_h2</code>コマンドの使い方は<a href="ch01/../ch05/python_on_pymol.html#%E6%8B%A1%E5%BC%B5%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E4%BD%BF%E3%81%88%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%80">PyMOL上でのpythonスクリプトの実行</a>を参考にしてみてください。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="タンパク質の位置依存的なアミノ酸保存度の違いを理解する-1"><a class="header" href="#タンパク質の位置依存的なアミノ酸保存度の違いを理解する-1">タンパク質の位置依存的なアミノ酸保存度の違いを理解する</a></h2>
<p>これまで見てきたように、タンパク質の内部は疎水性アミノ酸で充填されており、外側には水に溶けやすい親水性残基を露出することで水溶液中に存在しているというのがタンパク質の構築原理でした。一方、タンパク質は構造を保つだけでなく、リガンドを結合したり、化学反応を触媒したりする<strong>機能</strong>を持つことが生体内で特に重要です。言い換えれば、タンパク質は限られた20種類のアミノ酸をうまく使い分けることで、<strong>内部構造を保ちつつ、そして機能も発現させなければならない</strong>という二面性を持っています。</p>
<p>しかし、タンパク質を使って生きている生物というものは不思議なもので、すでにヒトと大腸菌のアルカリホスファターゼで見てきた通り、同じ機能を持つタンパク質であっても、それを構成しているアミノ酸配列を調べてみると、配列間の相同性が2〜3割しかないということもよく見られます。これは一体どういうことでしょうか？</p>
<p>以上のことを、アルカリホスファターゼについて確認してみましょう。まずは、<strong>PDBsum</strong> (<a href="https://www.ebi.ac.uk/thornton-srv/databases/cgi-bin/pdbsum/GetPage.pl?pdbcode=index.html">https://www.ebi.ac.uk/thornton-srv/databases/cgi-bin/pdbsum/GetPage.pl?pdbcode=index.html</a>) というデータベースに登録されているデータを用います。PDBsumはPDBに登録された生体分子の構造データを加工したデータベースの1つで、配列・構造情報・リガンド結合・文献情報などをわかりやすくまとめてあります。ここのトップページのフォームに、調べたいPDBデータのIDを入れてFindボタンを押します。</p>
<img src="ch01/./image/pdbsum1.png">
<p>すると、PDB ID: 1ALKについてのページに移ります。このトップページには構造の図とともに、タンパク質の分類・リガンド情報・化学反応・一次文献情報・この構造を引用している論文一覧……などが表示されています。</p>
<img src="ch01/./image/pdbsum2.png">
<p>さらに、上部にあるタブをクリックすることで、さらに他の詳細な情報を表示させることができます。ここではProteinタブをクリックしてみましょう。</p>
<img src="ch01/./image/pdbsum3.png">
<p>Proteins タブ、ページ左側にあるMotifsメニューのSecondary structure, Residue conservationをクリックすると（上図の赤丸部分）、アミノ酸の生物種間での保存度が1つずつカラーリングされているページが現れます。</p>
<img src="ch01/./image/pdbsum4.png">
<img src="ch01/./image/pdbsum5.png">
<p>この1文字表記のアミノ酸配列を見てみると、青〜緑〜黄〜赤までのカラーリングがなされていることに気づくと思います。<strong>このカラーリングはこの大腸菌アルカリホスファターゼの類縁配列上で、そのアミノ酸の位置がどれほど保存されているかを表しています</strong>（ページ下部に説明が書かれてあります）。言い換えれば、大腸菌アルカリホスファターゼについて他の類縁配列とのマルチプルシーケンスアライメントを作成してみたとき、ある位置のアミノ酸の種類が他の類縁配列上でも同じであればその位置のアミノ酸の保存度は高く、逆に他の類縁配列上でバラバラな様子が観測されていればその位置のアミノ酸の保存度は低くなります。例えば、この大腸菌アルカリホスファターゼのcatalytic residueである<strong>Ser102</strong>, <strong>Arg166</strong>のアミノ酸の保存度は最も高い9で示されています。この他にも、<strong>PDB SITE records</strong>（※なにかのリガンドが結合しているアミノ酸につくレコード）のマークが付いているアミノ酸はいずれも高い保存度を示していることが見て取れます。しかし、大腸菌アルカリホスファターゼのアミノ酸配列全体を見渡してみると、他にも保存度が高いところがあるのが伺えますし、逆に保存度が低いアミノ酸はなぜ低くなっているのか、という疑問も残ります。</p>
<p>そこでこの疑問を考察するために、これからこの保存度の情報をPyMOLで表示させた大腸菌アルカリホスファターゼ構造の上に表示させてみます。</p>
<p>先程のResidue Conservationのページの下の方を見ると、この保存度は<strong>Consurf-DB</strong>というデータベースに保存されてあります（<a href="https://consurfdb.tau.ac.il/">https://consurfdb.tau.ac.il/</a> ）。このページにアクセスして、大腸菌アルカリホスファターゼのPDB IDとChain IDを以下の画像のように入力してみましょう。</p>
<img src="ch01/./image/consurfdb1.png" width="80%">
<p>すると、まもなくPDB: 1ALKについての保存度情報についてのページに遷移します。ここで、下の方にある<strong>High Resolution Figures</strong>のところから、PyMOLの方のマークをクリックして、PyMOLのセッションファイル（<code>consurf_pymol_session.pse</code>）をダウンロードします。</p>
<img src="ch01/./image/consurfdb2.png">
<p>このダウンロードしてきたファイルをPyMOLで開いてみましょう。</p>
<img src="ch01/./image/consurfdb3.png">
<p>ここで、保存度のカラーリングはChain Aのみに行われており、Chain Bについては情報が存在していないためグレー表示となっていることに注意してください。</p>
<p>このダウンロードしてきた構造をPyMOL上で様々な角度から眺めていると、<strong>タンパク質構造の内側は保存度が高く、外側は保存度が小さい</strong>ことに気付かれると思います。これは偶然ではなく、前項の<a href="ch01/hydrophobicity.html">タンパク質の疎水性親水性残基の分布を確認する</a>で確認した通り、タンパク質構造の内部は疎水性アミノ酸によって隙間なく密にしておくことで、タンパク質構造を安定に支えておく必要があるからです。つまり、内部を支えるアミノ酸が不用意に別のアミノ酸に変化してしまうと構造を支えられなくなって機能を保てなくなってしまいます。また構造の外側に位置するアミノ酸であっても、<strong>活性残基、およびその周辺の残基</strong>は特に保存されていることがわかります。これはもちろんタンパク質の機能を直接担う責任重大なアミノ酸だから、と考えることができます。反対に、外側に露出しているアミノ酸はある程度どのアミノ酸を使ってもタンパク質構造全体の安定性という観点からすると大きな問題ではないため、アミノ酸の保存度が低くても機能に支障が出ないというわけです。</p>
<p>タンパク質は<strong>その機能を失わず、かつ構造を安定に保つという最低限の目的さえ果たせれば、そのアミノ酸配列はある程度自由に構成することができます</strong>。アルカリホスファターゼの例で言えば、リン酸モノエステル化合物を加水分解するという機能を損なわず、かつタンパク質全体の構造が壊れなければ、そのアミノ酸配列はある程度許容されることになり、長い進化の課程で大腸菌やヒトのものといった様々なバリエーションが生まれていったと考えることができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="アルカリホスファターゼの加水分解酵素としての働き-1"><a class="header" href="#アルカリホスファターゼの加水分解酵素としての働き-1">アルカリホスファターゼの加水分解酵素としての働き</a></h2>
<p>最後に、アルカリホスファターゼが「<strong>ホスファターゼ</strong>」の名前通りに<strong>リン酸モノエステル加水分解酵素</strong>として化学的にどう働いているかを観察してみましょう。</p>
<p>アルカリホスファターゼ（ALP）は以下の反応式のように、<em>p</em>-ニトロフェニルリン酸を<strong>加水分解</strong>して<em>p</em>-ニトロフェノール（黄色く発色する）を生成することができます。</p>
<img src="ch01/./image/ALPreaction.png" width="60%">
<p>この反応の様子をPyMOLで見てみましょう。</p>
<p><a href="http://vivace.bi.a.u-tokyo.ac.jp:8008/1alk_reaction.pse">このリンク</a>に<code>1alk_reaction.pse</code>という名前のPyMOLセッションファイルを置いています。これをダウンロードしてダブルクリック、またはFile -&gt; Openからこのファイルを開いてみましょう。このセッションファイルにはアルカリホスファターゼの単量体とともに、今まで無機リン酸が入っていた箇所に<em>p</em>-ニトロフェニルリン酸（残基名：NPH）の構造が見えるはずです。</p>
<img src="ch01/./image/reaction1.png" width="80%">
<p>PyMOL Internal GUIの右下には▶ボタンがあります。この▶ボタンを押すとタンパク質と<em>p</em>-ニトロフェニルリン酸が少しずつ動き、化学反応を起こしている様子が可視化されて見えるはずです。</p>
<video width="100%" height="100%" controls autoplay>
<source src="./image/reactionmovie.mp4" type="video/mp4">
</video>
<p>このような動いている様子が見られるのは、このセッションファイルにはあらかじめ149フレーム分の構造データを入れたオブジェクトが含まれているからです。ほとんどすべてのRCSB PDBからダウンロードしてきた結晶構造のデータは静止しているために1フレーム分のデータしかありませんが、NMRで構造決定されたデータですと、タンパク質の「動き」が収録されているものもあります（例としてPDB ID: 1G03）。</p>
<p>このセッションファイルには、<code>dist01</code>から<code>dist11</code>までの距離オブジェクトも含まれています。この距離オブジェクトは<a href="ch01/../../../ch02/buttontable.html">マウス操作の原子ピッキング（PkAt）機能</a>を用いることで作成することができます。距離を測定したい2点の原子の上でそれぞれCtrlキーを押しながらマウスのホイールクリックを行い、コマンドで<code>dist</code>と入力することで距離オブジェクトを生成することができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="第2章-internal-guiの使い方"><a class="header" href="#第2章-internal-guiの使い方">第2章 Internal GUIの使い方</a></h1>
<h1 id="guiによる基本的な操作方法"><a class="header" href="#guiによる基本的な操作方法">GUIによる基本的な操作方法</a></h1>
<p>GUIとはGraphical User Interfaceのことで、マウスを使ってタンパク質オブジェクトを操作したり、設定を変更したりできるユーザーインターフェースのことです。またPyMOLには<strong>Internal GUI</strong>と<strong>External GUI</strong>と呼ばれるメニューが存在し、マウスのクリックを使った直感的な操作が行えるようになっています。</p>
<img src="ch02/./image/gui.png" width="80%">
<h2 id="分子構造のロード"><a class="header" href="#分子構造のロード">分子構造のロード</a></h2>
<h3 id="構造ファイルのロード"><a class="header" href="#構造ファイルのロード">構造ファイルのロード</a></h3>
<p>メニュー左上の[File]から、[Open...]を選び、PyMOLに表示させたい構造ファイルを選択します。ここでは、先程ダウンロードした <code>1alk.cif</code> ファイルを例として、ダブルクリックして表示させてみます。</p>
<img src="ch02/./image/load/load1.png" width="25%">
<p>すると、画面に1ALKのアルカリフォスファターゼの構造が表示されました。はじめは黒背景に緑のタンパク質がオブジェクトが浮かんでいると思いますが、ここで続けて、メニューの[Display]から[Background]-&gt;[White]を選択すると、白背景にすることができます。</p>
<p><img src="ch02/./image/load/load3.png" width="40%"><br>
<img src="ch02/./image/load/load2.png" width="80%"></p>
<h3 id="サポートしている構造ファイル形式"><a class="header" href="#サポートしている構造ファイル形式">サポートしている構造ファイル形式</a></h3>
<p>PyMOLが読み込むことのできる構造ファイルフォーマットはたくさんありますが、まず以下の2つのファイル形式を覚えましょう。</p>
<ul>
<li>pdbフォーマット
<ul>
<li>ファイル名の最後に<code>.pdb</code>（<strong>拡張子</strong>）がついているのが目印です。PDBが設立された当初から使われているファイルフォーマットで、PyMOLの表示に使う座標情報だけでなく、結晶学（NMR）的情報（B-factor、 空間群、単位格子定数…）、 構造的特徴（2次構造、SS結合… ）、実験情報（解像度、回折実験情報、精密化条件、結晶化条件… ）、生物学的情報（蛋白質名、種名、生物学的単位、EC番号… ）、化学的情報（化合物の名称や構造…）、文献情報などが記載されており、慣れれば人間でも読みやすく、必要最低限の情報が記述されています。しかし、時代が下るとともにこのフォーマットでは限界や不便な点が指摘されるようになりました。特に、近年は結晶解析だけでなくクライオ電子顕微鏡などの技術の発達により、巨大タンパク質の構造決定が次々と報告されるようになりましたが、従来のPDBフォーマットの最も大きな問題点の1つには100,000原子以上からなる構造、または多数のアミノ酸鎖（63チェイン以上）から構成される複合体の構造情報の記述をほとんど想定していなかったことがあります。このため、後述の<strong>mmCIF</strong>形式の利用が推奨されるようになりました。</li>
</ul>
</li>
<li>mmCIFフォーマット
<ul>
<li>ファイル名の最後に<code>.cif</code>がついているのが目印です。元来、mmCIFファイルフォーマットは国際結晶学連合が低分子用に定めていたCIF(Crystallographic Information File)形式を高分子(macromolecular)に拡張したものです。pdbフォーマットでは1ファイル内に記述することができなかった、100,000原子数以上または63チェイン以上の構造記述が可能になっています。例えばPDB: 3J3QのHIV-1 capsidは超巨大分子であり、従来のPDBフォーマットでは配布されていません。<strong>2014年にPDBの標準フォーマットとなり、2019年7月1日からは、PDBに登録する際にmmCIF形式での構造情報登録を義務付けられるようになりました。</strong> このmmCIF形式がこれからのスタンダードとなっていくことは間違いありません。ファイルの中身はpdbフォーマットの内容の上位互換となっており、最近の構造可視化ソフトウェアはすべてこれに対応するよう調整をしています。</li>
</ul>
</li>
</ul>
<p>他のファイル形式として、以下のものがあります。多くの場合、ファイル名末尾についている拡張子で見分けることが可能です。詳細な記述文法については、ここでは本題ではないので省略します。</p>
<ul>
<li>生体高分子系・電子密度情報
<ul>
<li>
<p>CCP4フォーマット: 拡張子は<code>.ccp4</code>, <code>.map</code>, <code>.mrc</code>。電子密度マップ。</p>
</li>
<li>
<p>PDBMLフォーマット: 拡張子は<code>.xml</code>, <code>.pdbml</code>。コンピュータ間でのデータのやり取りや管理が簡単になるように設計された<strong>XMLファイルフォーマット</strong>をPDB用に特化させたものです。RCSB PDBでも配布されており、mmCIF形式とほぼ同一の情報が書き込まれています。ファイルサイズがmmCIFに比べて大きいことや、中身を見ても人間には読みにくい文法になっていますが、各プログラム言語が持っているXMLパーサ（構文解析器）にかけることでデータ構造の複合体に変換することが容易なため、インフォマティクスの専門家からは好まれるファイル形式です。</p>
</li>
<li>
<p>MMTFフォーマット: 拡張子は<code>.mmtf</code>。Macromolecular Transmission Formatの略称で、2016年頃から活発になり始めた<strong>新しいPDBファイル形式</strong>です。https://mmtf.rcsb.org/ によればMMTFの大きな特長はバイナリ化されていることであり、mmCIFフォーマットの1/3以下へのファイル縮小、そして最高で400倍以上の高速な読み込みが可能となっています。PyMOL 2.2.0以降でMMTFファイルフォーマットの読み込み・書き出しができるようになったようですが、まだ書き出しあたりには不十分なところもあります。これはViral Capsid（PDB: 3J3Q）のような超巨大タンパク質の表示にとても便利です。</p>
</li>
<li>
<p>MacroModelフォーマット: 拡張子は<code>.mmod</code>, <code>.mmd</code>。Schrödinger社のMacroModelやMaestroで使われているファイルフォーマット。</p>
</li>
</ul>
</li>
<li>小分子化合物系
<ul>
<li>MOLフォーマット: 拡張子は<code>.mol</code>。MDL Information Systems社が開発した、化学構造式を記述する標準フォーマットの1つです。詳細はCTFile formatというガイドに記載されています。</li>
<li>MOL Structure Data Fileフォーマット: 拡張子は<code>.sdf</code>。上記MOL形式を改良し、複数の構造式を1ファイルに記述でき、さらに様々な付加情報を追記することができるようになっています。</li>
<li>SYBYL MOL2フォーマット: 拡張子は<code>.mol2</code>。Tripos（現Certara）が開発した、SYBYLと呼ばれるケモインフォマティクスのソフトウェアで使われていたファイルフォーマットです。タンパク質などの巨大分子でもこのファイル形式で書くことが可能です。詳細はSYBYL MOL2 formatというガイドに記載されています。</li>
<li>XYZフォーマット: 拡張子は<code>.xyz</code>。単純に原子の種類と原子の\( xyz \)座標を記述するファイル形式です。http://openbabel.org/wiki/XYZ_(format) に説明があります。</li>
</ul>
</li>
</ul>
<p>以下の拡張子は、表のように別のファイル拡張子として認識されます。</p>
<table><thead><tr><th align="right">入力拡張子</th><th align="right">認識されるファイル拡張子</th></tr></thead><tbody>
<tr><td align="right"><code>ent</code>, <code>p5m</code></td><td align="right"><code>pdb</code></td></tr>
<tr><td align="right"><code>mmd</code>, <code>out</code>, <code>dat</code></td><td align="right"><code>mmod</code></td></tr>
<tr><td align="right"><code>map</code>, <code>mrc</code></td><td align="right"><code>ccp4</code></td></tr>
<tr><td align="right"><code>cc2</code></td><td align="right"><code>cc1</code></td></tr>
<tr><td align="right"><code>sd</code></td><td align="right"><code>sdf</code></td></tr>
<tr><td align="right"><code>rst7</code></td><td align="right"><code>rst</code></td></tr>
<tr><td align="right"><code>o</code>, <code>dsn6</code>, <code>omap</code></td><td align="right"><code>brix</code></td></tr>
<tr><td align="right"><code>ph4</code></td><td align="right"><code>moe</code></td></tr>
<tr><td align="right"><code>spi</code></td><td align="right"><code>spider</code></td></tr>
<tr><td align="right"><code>pym</code>, <code>pyc</code></td><td align="right"><code>py</code></td></tr>
<tr><td align="right"><code>p1m</code>, <code>pim</code></td><td align="right"><code>pml</code></td></tr>
<tr><td align="right"><code>xml</code></td><td align="right"><code>pdbml</code></td></tr>
</tbody></table>
<h3 id="biological-unitを考慮した分子構造のロード"><a class="header" href="#biological-unitを考慮した分子構造のロード">Biological Unitを考慮した分子構造のロード</a></h3>
<p>タンパク質は1本のアミノ酸ポリペプチド鎖が折り畳まって存在しているのがほとんどですが、タンパク質の種類によっては、多量体の形で初めて安定に存在し機能しうるものもあります。<strong>Biological Unit</strong>（Biological Assemblyとも呼ばれる）とは、実際に生物の中で機能している構造の状態のことを指します。詳しくはPDBjのウェブサイトの「<a href="https://pdbj.org/help/pdb_aubu">非対称単位と生物学的単位について</a>」も参照してください。</p>
<p>例として<code>PDB ID: 1ALK</code>（大腸菌由来アルカリフォスファターゼ）と<code>PDB ID: 1EW2</code>（ヒト由来アルカリフォスファターゼ）を比較してみましょう。各構造ファイルを取り扱うRCSB PDBのウェブサイト（ https://www.rcsb.org/structure/1ALK と https://www.rcsb.org/structure/1EW2 ）のStructure Summaryタブで画面左の方には、タンパク質の構造とともに、Global SymmetryとGlobal Stoichiometryの情報が書かれています。</p>
<img src="ch02/./image/load/bunit1.png" width="80%">
<p>Global Stoichiometryには<code>Homo 2-mer - A2</code>という情報が記されています。論文で調べてみても、このタンパク質がそれぞれホモ2量体として生物中で機能していることが示されています。しかしそれぞれのファイルをPyMOLで単純に開いてみますと、1ALKの方にはA chain、B chainの構造が含まれていますが、1EW2の方ではA chainしか含まれていません。これは、<strong>PDBに登録されている原子座標のデータには、必要最小限の「非対称単位」(assymmetric unit)のみ含まれているから</strong> です。</p>
<p>そこで、場合によっては2量体の状態でタンパク質構造を表示してみたいということがあると思います。PyMOL 1.8からはこのBiological Unitを考慮した構造のロードが簡単に行えるようになりましたので、それを<code>1EW2</code>ファイルに対してやってみます。以下の画像のように、[File]-&gt;[Get PDB...]を選び、続くウィンドウの画面でIDとAssembly情報を入力します。</p>
<p><img src="ch02/./image/load/bunit2.png" width="25%"><br>
<img src="ch02/./image/load/bunit3.png" width="40%"></p>
<p>これにより、1EW2の構造がホモ2量体構造で表示されました。</p>
<img src="ch02/./image/load/bunit4.png" width="60%">
<p>このチェインを別々に扱うためには、右側のオブジェクトパネルから<code>1EW2A</code>のAボタンをクリックし、[state] -&gt; [split]を開いてクリックします。</p>
<img src="ch02/./image/load/bunit5.png" width="30%">
<p>すると、<code>1EW2A_0001</code>, <code>1EW2A_0002</code>というオブジェクトが新たに生成されます。ここまでくれば<code>1EW2A</code>オブジェクトは不要ですので、最後に<code>1EW2A</code>のAボタンから[delete object]を押せば完了です。</p>
<img src="ch02/./image/load/bunit6.png" width="80%">
<p>以上がBiological Unitを考慮した分子構造のロード操作ですが、これは一例であり、他にも同等の操作を達成する方法があります。コマンドラインで上記の操作を達成するには</p>
<pre><code>set assembly, 1
fetch 1ew2
split_states 1ew2
delete 1ew2
</code></pre>
<p>でOKです。タイピングが早ければこちらの方が素早くできるでしょう。<code>set assembly, 1</code>に相当する設定変更は、上部メニューの[Setting] -&gt; [mmCIF File Loading] -&gt; [Load Assembly (Biological Unit)]にチェックを入れることでも可能です。</p>
<h2 id="配列の表示"><a class="header" href="#配列の表示">配列の表示</a></h2>
<p>分子構造をロードしたら、ここでPyMOL画面の右下に注目してみます。ここには様々な記号や文字が並んでいますが、ここのSボタンを押してみましょう。</p>
<img src="ch02/./image/viewer/seq1.png" width="40%">
<p>このSボタンを押すと、画面に分子の配列情報が現れます。もう一度Sボタンを押すと文字列が隠れます。</p>
<img src="ch02/./image/viewer/seq2.png" width="80%">
<p>ここに表示される配列の文字列は、タンパク質の場合にはA, C, Dなどアミノ酸の1文字表記、核酸構造の場合にはDA, DT, DG, DCで2文字表記となっています。RNAの場合には1文字表記ですが、タンパク質の場合と異なり、各文字にスペースが挿入されて表示されます。リガンドやその他のについては3文字表記で表されることが多いです。これらの表記は、ロードする構造ファイル内の記述に依存してします。</p>
<p>配列の表示・非表示は、上部メニューの[Display]→[Sequence]にチェックを入れたり外したりすることでも行うことができます。</p>
<p>以下に、配列表示ウィンドウ上でのマウス操作を方法を記します。macOSの場合はCtrlはCmdキーになります。</p>
<ul>
<li><strong>左クリック＋ドラッグ</strong>
<ul>
<li>分子の一部を選択した状態にできます。選択した箇所にはハイライトが付きます。タンパク質の場合は残基ごと、核酸の場合は塩基ごと、それ以外の場合は1分子ごとに選択します。</li>
</ul>
</li>
<li><strong>Shift+左クリック</strong>
<ul>
<li>上記の選択範囲を拡張・縮小することができます。クリックボタンを押し続ける必要はありません。</li>
</ul>
</li>
<li><strong>Ctrl+Shift+左クリック</strong>
<ul>
<li>選択範囲を拡張・縮小しつつ、視点を選択範囲にセンタリングしてくれます。</li>
</ul>
</li>
<li><strong>ホイールクリック</strong>
<ul>
<li>クリックした箇所に視点をセンタリングします。</li>
</ul>
</li>
<li><strong>Ctrl+ホイールクリック</strong>
<ul>
<li>クリックした箇所に視点を大きくズームします。</li>
</ul>
</li>
<li><strong>Ctrl+ホイールクリック+Shift+ドラッグ</strong>
<ul>
<li>Shift+ドラッグで選んだ選択範囲に向かって視点を大きくズームします。</li>
</ul>
</li>
<li><strong>右クリック</strong>
<ul>
<li>選択されていない箇所で右クリックをすると、その位置に存在する配列を選択し、それについての設定変更メニューを表示します。</li>
<li>すでに選択されている箇所で右クリックをすると、選択範囲に対する設定変更メニューを表示します。</li>
</ul>
</li>
</ul>
<h2 id="オブジェクトパネル"><a class="header" href="#オブジェクトパネル">オブジェクトパネル</a></h2>
<p>PyMOL画面の右側には、ロードしている分子構造について様々な操作を行えるパネルが表示されています。</p>
<img src="ch02/./image/viewer/objectpanel1.png" width="40%">
<p>画像の例では<code>all</code>と<code>1alk</code>が表示されています。また、画面上の分子構造をクリックし選択すると、<code>(sele)</code>という表示も追加されます。このパネルに表示されている文字のことを<strong>オブジェクト</strong>と呼びます。その右についているA, S, H, L, Cという文字のボタンには、対応するオブジェクトについての表示設定変更・編集を行うためのメニューがたくさん格納されています。それぞれの文字が表す大まかな意味は以下の通り。</p>
<ul>
<li><strong>Action(A)</strong>
<ul>
<li>視点の移動や分子についての編集、一括設定変更、構造のアラインや名前変更など、オブジェクト全体に関わる様々な設定を行うためのメニューが格納されています。</li>
</ul>
</li>
<li><strong>Show (S)</strong>
<ul>
<li>分子構造の表示形式をONにするためのメニューが格納されています。</li>
</ul>
</li>
<li><strong>Hide (H)</strong>
<ul>
<li>分子構造の表示形式をOFFにするためのメニューが格納されています。</li>
</ul>
</li>
<li><strong>Label (L)</strong>
<ul>
<li>分子構造のすぐそばに表示する文字ラベルを追加するためのメニューが格納されています。</li>
</ul>
</li>
<li><strong>Color (C)</strong>
<ul>
<li>分子構造の色変更を行うためのメニューが格納されています。</li>
</ul>
</li>
</ul>
<h2 id="分子構造の表示形式のonoff-show-and-hide"><a class="header" href="#分子構造の表示形式のonoff-show-and-hide">分子構造の表示形式のON/OFF (Show and Hide)</a></h2>
<p>タンパク質の構造情報をロードしたとき、デフォルト設定では、20種類のアミノ酸についてはCartoon表示形式と呼ばれる漫画風な表現形式になっています。このCartoon表示形式では、αヘリックスを形成している部分については大きな螺旋で描かれ、βストランド（βシート）を形成している部分については、進行方向に向かって矢印が伸びる表現で描かれています。</p>
<p>タンパク質を構成するアミノ酸を1つ1つ強調して見てみたい場合には、<strong>Cartoon</strong>, <strong>Line</strong>, <strong>Stick</strong>, <strong>Ribbon</strong>, <strong>Sphere</strong>, <strong>Dot</strong>, <strong>Surface</strong>, <strong>Mesh</strong> 表示などの、他の表示形式をONにするという操作を行います。この表示形式の設定は、各オブジェクト構造について個別に行います。例えば、先程ロードした1alkのタンパク質オブジェクトについて他の表示形式をONにしたい場合は、図のように、1alkの<strong>Sマーク部分（図の赤四角部分のボタン）</strong> をクリックします。反対に、OFFにしたい場合は<strong>Hマーク部分（図の青四角部分のボタン）</strong> を押し、各表示形式を選択することでOFFになります。</p>
<img src="ch02/./image/display/disp1.png" width="40%">
<p><img src="ch02/./image/display/disp3.png" width="40%"><br></p>
<!--
set_view (\
     0.990649223,   -0.127824500,    0.047657397,\
     0.136341795,    0.915909708,   -0.377514422,\
     0.004605473,    0.380482703,    0.924775600,\
    -0.000116501,   -0.000019159,  -50.788997650,\
    29.517896652,    2.209085464,   19.883510590,\
     0.894756913,  100.680503845,  -20.000000000 )
-->
<p>各表示形式のサンプルを以下に示します。</p>
<ul>
<li>
<p><strong>Cartoon表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_cartoon.png" width="40%">
</li>
<li>タンパク質やDNA・RNAを表示するときにおすすめです。タンパク質の場合はαヘリックスやβシートが先述のように螺旋や矢印で示されます。DNA/RNAが存在する場合には、各塩基の概形や5'末端→3'末端のつながりが強調して表示されます。</li>
</ul>
</li>
<li>
<p><strong>Line表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_line.png" width="40%"><img src="ch02/./image/display/disp_linecartoon.png" width="40%"><br></li>
<li>各原子間の結合が細い線で表示されます。上の図では、左にLine表示だけをONにしたものを、右にCartoon表示形式をLine表示とともにONにした場合を右図に示しています（以降、見やすくするためにCartoon表示をONにした上で、他の表示形式を載せます）。</li>
<li>各原子は構造情報ファイルの座標のATOMまたはHETATMレコードに書かれている座標情報（\( x, y, z \)の3次元ベクトル）をもとにプロットされ、各原子座標の距離が一定以内にあれば、自動的にその近い2点が直線で結ばれて表示される仕様となっていることに気をつけてください。</li>
</ul>
</li>
<li>
<p><strong>Stick表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_stick.png" width="40%"><br></li>
<li>各原子間の結合がLine表示よりも太いStickで表示されます。Stickは円筒状に表現されます。</li>
</ul>
</li>
<li>
<p><strong>Ribbon表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_ribbon.png" width="40%"><br></li>
<li>タンパク質または核酸の鎖部分のみを単純な線で表現する形式です。</li>
</ul>
</li>
<li>
<p><strong>Sphere表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_sphere.png" width="40%"><br></li>
<li>各原子を大きな球体で表現します。Line, Stick表示と異なり、各原子間は直線で結ばれません。</li>
</ul>
</li>
<li>
<p><strong>Dot表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_dot.png" width="40%"><br></li>
<li>Sphere表示の表面を点で表現したような形式です。</li>
</ul>
</li>
<li>
<p><strong>Surface表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_surface.png" width="40%"><br></li>
<li>各原子の表面を滑らかに描画する形式です。分子の大きさによっては、レンダリングに少し時間がかかります。</li>
</ul>
</li>
<li>
<p><strong>Mesh表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_mesh.png" width="40%"><br></li>
<li>Surface表示と似ていますが、表面の描画を網掛けで表現します。</li>
</ul>
</li>
</ul>
<h2 id="ラベルの設定label"><a class="header" href="#ラベルの設定label">ラベルの設定(Label)</a></h2>
<p><strong>ラベル</strong>を利用することで、分子の周辺に文字を表示させることができます。活性部位周辺に存在する残基の名前と番号を表示させるだけでなく、任意の文字列を表示させることができます。</p>
<p><img src="ch02/./image/label/label1.png" width="40%"><br></p>
<p><a href="ch02/./showandhide.html">分子構造の表示形式のON/OFF (Show and Hide)</a>のときと同様に、オブジェクトパネルから各オブジェクトに対して個別にラベルの設定を行うことができます。特に、選択範囲<code>(sele)</code>に対して表示させることが多いでしょう。</p>
<img src="ch02/./image/label/labelmenu.png" width="40%">
<p><strong>ラベルの設定変更</strong>はGUIの上部メニューから、Setting -&gt; Labelのところにあり、ラベルの表示サイズやフォント指定、色の指定などが可能です。下記のサンプルではフォントサイズを28にしてあります。</p>
<p><strong>ラベルの位置変更</strong>は3-Button Editing Modeにしてから、ラベルの上でCtrl(macOSの場合はCommand)を押しながら左クリックでドラッグさせることで任意の位置に移動させることができます。下の例ではASP-101を右に移動させています。</p>
<img src="ch02/./image/label/label_res.png" width="49%">
<img src="ch02/./image/label/label_res2.png" width="49%">
<h3 id="clear"><a class="header" href="#clear">clear</a></h3>
<p>すでに表示されているそのオブジェクトについてのラベル表示を消去します。消去するのではなく表示を一時的に場合は、Hideメニューからlabelを選択しましょう。</p>
<hr>
<h3 id="residues"><a class="header" href="#residues">residues</a></h3>
<p>選択されたオブジェクトについて、アミノ酸と残基番号の情報を<code>（アミノ酸3文字表記）-（残基番号）</code>の形で表示します(例：MET-1)。Cα原子の上に表示される設定になっています。</p>
<img src="ch02/./image/label/label_res.png" width="50%">
<h3 id="residues-one-letter"><a class="header" href="#residues-one-letter">residues (one letter)</a></h3>
<p>選択されたオブジェクトについて、アミノ酸と残基番号の情報を<code>（アミノ酸1文字表記）（残基番号）</code>の形で表示します(例：M1)。Cα原子の上に表示される設定になっています。</p>
<img src="ch02/./image/label/label_resone.png" width="50%">
<h3 id="chains"><a class="header" href="#chains">chains</a></h3>
<p>選択されたオブジェクトのN末端とC末端の番号を持つ残基（リガンドが存在する場合、それも含む）のそばに<code>chain &lt;chain ID&gt;</code>の形で表示します（例： chain A）。</p>
<img src="ch02/./image/label/label_chain.png" width="50%">
<h3 id="segments"><a class="header" href="#segments">segments</a></h3>
<p>すでに使用が廃止されたsegment identifierの情報を、chainsと同様に表示します。詳しくは<a href="ch02/../append01/term.html#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88segment-identifier">Appendix: 用語#セグメント</a>を参照してください。今となってはあまり使うことはないと思います。</p>
<hr>
<h3 id="atom-name"><a class="header" href="#atom-name">atom name</a></h3>
<p>原子名の名前でラベルを作成します。<code>.pdb</code>形式ファイルの場合、<code>ATOM</code>, <code>HETATM</code>レコードの13-16列目に含まれる文字列がatom nameとして定義されており、この文字列を返します。</p>
<img src="ch02/./image/label/label_atomname.png" width="50%">
<p>タンパク質アミノ酸やDNA, RNAの場合は命名規則があるため、慣れてしまえばatom nameの意味を理解しやすいと思います。13-14列目には右詰めで原子名を表します。例えば鉄原子は13-14列目を使ってFEの文字が入っていますが、炭素原子は14列目にCの文字を入れ、13列目は空白となっています。しかし、水素原子の場合は13-16列目の4文字分を最大限使って記述する場合があり、この場合は13列目から記入することになっています。</p>
<p>以下ではよく登場するatom nameの一例です。</p>
<table><thead><tr><th align="right">atom name</th><th align="right">意味</th></tr></thead><tbody>
<tr><td align="right">CA</td><td align="right">主鎖のα位の炭素</td></tr>
<tr><td align="right">N</td><td align="right">主鎖のN末端側窒素原子</td></tr>
<tr><td align="right">C</td><td align="right">主鎖のC末端側炭素原子</td></tr>
<tr><td align="right">O</td><td align="right">主鎖のC末端側酸素原子</td></tr>
<tr><td align="right">CB</td><td align="right">側鎖のβ位の炭素</td></tr>
<tr><td align="right">CG</td><td align="right">側鎖のγ位の炭素</td></tr>
<tr><td align="right">CD</td><td align="right">側鎖のδ位の炭素</td></tr>
<tr><td align="right">CE</td><td align="right">側鎖のε位の炭素</td></tr>
<tr><td align="right">CZ</td><td align="right">側鎖のζ位の炭素（チロシンなど）</td></tr>
<tr><td align="right">OH</td><td align="right">側鎖のη位の炭素（チロシンなど）</td></tr>
</tbody></table>
<p>主鎖に近い原子の個数順にβ→γ→δ→ε→ζ→ηと付ける命名規則があります。複数原子が存在するようなアミノ酸（ヒスチジン）などはND1, CD1, CE2, NE2というふうに番号をつけて区別します。</p>
<h3 id="element-symbol"><a class="header" href="#element-symbol">element symbol</a></h3>
<p>原子名を表記します。</p>
<img src="ch02/./image/label/label_esymbol.png" width="50%">
<h3 id="residue-name"><a class="header" href="#residue-name">residue name</a></h3>
<p>3文字表記の残基名を表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの18-20列目の文字列を返します。存在しない場合は空白になります（以下同様）。</p>
<img src="ch02/./image/label/label_resn.png" width="50%">
<h3 id="one-letter-code"><a class="header" href="#one-letter-code">one letter code</a></h3>
<p>1文字表記の残基名を表記します。</p>
<img src="ch02/./image/label/label_resnone.png" width="50%">
<h3 id="residue-identifier"><a class="header" href="#residue-identifier">residue identifier</a></h3>
<p>残基のresidue IDを表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの23-26列目の文字列を返します。</p>
<img src="ch02/./image/label/label_resi.png" width="50%">
<h3 id="chain-identifier"><a class="header" href="#chain-identifier">chain identifier</a></h3>
<p>残基のChain IDを表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの22列目の文字列を返します。</p>
<img src="ch02/./image/label/label_chainid.png" width="50%">
<h3 id="segment-identifier"><a class="header" href="#segment-identifier">segment identifier</a></h3>
<p>残基のSegment IDを表記します。詳しくは<a href="ch02/../append01/term.html#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88segment-identifier">Appendix: 用語#セグメント</a>を参照してください。</p>
<hr>
<h3 id="b-factor"><a class="header" href="#b-factor">b-factor</a></h3>
<p>各原子の温度因子（b-factor; temperature facotr）を表記します。<code>.pdb</code>ファイル形式における61-66列目の文字列を返します。</p>
<img src="ch02/./image/label/label_bfactor.png" width="50%">
<h3 id="occupancy"><a class="header" href="#occupancy">occupancy</a></h3>
<p>各原子の重み因子を表記します。<code>.pdb</code>ファイル形式における55-60列目の文字列を返します。結晶中では基本的に構造は繰り返しになるため、どの場所を見ても同じ座標がループしている事が多く、この値は<code>1.00</code>であることが多いのですが、時々その繰り返し構造単位の中に、1より大きなn通りの配座を持っていることがあります。このとき、ここには0~1の小数値が入ります。例としては PDB: 1A6MのGLN-8が<code>0.57</code>, <code>0.43</code>の値を持つ2通りの配座を持ち、同様にTYR-151も<code>0.50</code>, <code>0.50</code>で2通りの配座を持っています。この場合、PyMOLの表示上でも2通りの残基配座が見えます。画像はPDB: 1A6MのGLN-8の例を示しています。</p>
<img src="ch02/./image/label/label_occupancy.png" width="50%">
<h3 id="vdw-radius"><a class="header" href="#vdw-radius">vdw radius</a></h3>
<p>各原子のファンデルワールス半径の値（Å）を表記します。基本的には原子の種類によって固定の値です。</p>
<img src="ch02/./image/label/label_vdw.png" width="50%">
<hr>
<h3 id="other-properties"><a class="header" href="#other-properties">Other properties</a></h3>
<h4 id="formal-charge"><a class="header" href="#formal-charge">formal charge</a></h4>
<p>各残基についてシステムで定義されている電荷を表記します。例としてLys, Arg残基の場合は<code>+1</code>を、Glu, Asp残基の場合には<code>-1</code>を表示します。</p>
<img src="ch02/./image/label/label_fchrg.png" width="50%">
<h4 id="partial-charge"><a class="header" href="#partial-charge">partial charge</a></h4>
<p>各原子について計算された部分電荷(partial charge)を表記します。これは通常の<code>pdb</code>, <code>mmCIF</code>といった構造ファイルには含まれていないため、<code>0.00</code>と表示されてしまいますが、<code>pqr</code>や<code>mol2</code>ファイル形式をロードしたときに真価を発揮します。</p>
<p>タンパク質構造の場合は構造ファイルをいったんロードした後、<a href="ch02/../ch04/apbs.html">APBSプラグインを使った表面電荷表示</a>の手順に従って処理を進めます。このときにオブジェクトパネルに<code>run01</code>-&gt;<code>prepared01</code>というオブジェクトが生成されるので、<code>prepared01</code>オブジェクトのラベル設定でpartial chargeを選択すると図のように部分電荷が表示されるようになります。</p>
<img src="ch02/./image/label/label_partchg.png" width="90%">
<p>より正確に言えば、これはPDB2PQRというソフトウェアによって分子動力学シミュレーションソフトウェアAMBERが配布している力場AmberFFに基づいて指定されており、各アミノ酸の原子ごとに固有の値を指定してくれます。</p>
<p>実態としてはPQRファイルの記述様式にのっとり、x, y, z座標の次にくるchargeの値を表記しています。</p>
<blockquote>
<p>参考：<a href="https://www.mdanalysis.org/docs/documentation_pages/coordinates/PQR.html">6.15. PQR file format</a></p>
</blockquote>
<p>mol2形式の場合でも対応しています。</p>
<img src="ch02/./image/label/label_partchgmol2.png" width="50%">
<p>GaussianやGAMESSなどの量子化学計算ソフトウェアで計算した部分電荷を図にして見てみたいときに特に有効です。</p>
<h4 id="elec-radius"><a class="header" href="#elec-radius">elec. radius</a></h4>
<p>partial chargeのときと同様に、PQRファイルのオブジェクトの場合に効果を発揮します。PQRファイル内のx, y, z座標, chargeの次にくるradiusの値を表記しています。vdw radiusとは異なります。</p>
<img src="ch02/./image/label/label_eradius.png" width="50%">
<h4 id="text-type-numeric-type"><a class="header" href="#text-type-numeric-type">text type, numeric type</a></h4>
<p>PyMOL 2.0以降は廃止されているらしく、使われていないようです（詳細不明）</p>
<h4 id="stereochemistry"><a class="header" href="#stereochemistry">stereochemistry</a></h4>
<p>PyMOL 2.2から実装されました。schrodingerのソフトまたはrdkitモジュールのインストールが求められるようです。不斉炭素原子の部分にラベルを置いてくれる機能？</p>
<hr>
<h3 id="atom-identifiers"><a class="header" href="#atom-identifiers">atom identifiers</a></h3>
<h4 id="rank"><a class="header" href="#rank">rank</a></h4>
<p>rankを表記します。rankとは構造ファイルの上から順に<code>ATOM</code>, <code>HETATM</code>レコードを取得したときの通し番号のことであり、これのみ<strong>0始まり</strong>となっています。</p>
<img src="ch02/./image/label/label_rank.png" width="50%">
<blockquote>
<p>“rank” selects atoms based on their position in the source file, starting with zero as the first number.</p>
</blockquote>
<h4 id="id"><a class="header" href="#id">ID</a></h4>
<p>IDを表記します。IDとは構造ファイルから忠実に取得したATOM IDのことであり、<code>pdb</code>ファイルフォーマットで言えば7-11列目に存在する番号のことを指します。この値は整数値でなければなりません。</p>
<img src="ch02/./image/label/label_id.png" width="50%">
<blockquote>
<p>“id” selects atoms based on the atom identifier number from the source file, which must be a integer.</p>
</blockquote>
<h4 id="index"><a class="header" href="#index">index</a></h4>
<p>Indexを表記します。indexはrankと似ていますが、順に表示するのとは異なり、PyMOL内部で番号を順に振り直したのがindexです。例えばある1つのアミノ酸残基があったとき、その残基の中で登場する原子の順番をどのように入れ替えても、index表記ではN→CA→C→O→CB→……の順に若い数字を付けていきます。</p>
<img src="ch02/./image/label/label_index.png" width="50%">
<blockquote>
<p>“index” selects atoms based on their internal PyMOL object atom indices starting with one as the first number.</p>
</blockquote>
<h2 id="色の設定color"><a class="header" href="#色の設定color">色の設定(Color)</a></h2>
<img src="ch02/./image/color/colormenu.png" width="25%">
<p>色の設定の仕方は自由です、センスの見せ所です……とは言うものの、<strong>実はタンパク質の構造を毎日見るであろう構造生物学専門の研究者さんにとっては、ある暗黙の了解があります</strong>。それらを踏まえた上で、PyMOLのカラーリング機能を紹介していきましょう。</p>
<h3 id="色設定の暗黙の了解"><a class="header" href="#色設定の暗黙の了解">色設定の暗黙の了解</a></h3>
<p>以下のルールだけは遵守しましょう。</p>
<ul>
<li>常に<strong>酸素原子は<span style="color:red;">赤</span>色, 窒素原子は<span style="color:blue;">青</span>色, 硫黄原子は<span style="color:#E7C640;">オリーブ（olive）</span>色</strong>で表示する。</li>
<li>存在する場合、水素原子は白色で表示。</li>
<li>よって炭素原子は、<strong>上記以外の色</strong>を使う。</li>
</ul>
<p>メチオニン残基の表示の例（炭素原子はgreen）</p>
<img src="ch02/./image/color/color1.png" width="50%">
<p>PyMOLには、酸素・窒素・窒素・水素原子を上記の色ルールで描画してくれるメニュー（&quot;<strong>by element</strong>&quot;）が存在しますので、これを使うことを強く推奨します。</p>
<p>正確には、PyMOLでは酸素原子はカラーコードで#FF7C7C (255, 76, 76) [1.0, 0.3, 0.3], 窒素原子は#3333FF (51,51,255) [0.2, 0.2, 1.0], 硫黄原子は#E7C640 (231, 198, 64) [0.9, 0.775, 0.25]がデフォルトで割り当てられているため、用意されているカラーパレットを使う限りにはこれらの色と完全にかぶることはないのですが、それでもこれらに近い色を使うと紛らわしいので、使用は控えましょう。また、以下で見るように、用意されているカラーパレットの中にはすべての原子を同一で塗るものもあるので、どうしてもそれらの色を使いたい場合は、そのカラーパレットを選択した後に&quot;<strong>by element</strong>&quot;メニューの一番上のカラーリング（通称&quot;color by hetetoatom&quot;）を選択してあげましょう。</p>
<h3 id="by-element"><a class="header" href="#by-element">by element</a></h3>
<p>メニューを開いていただけると一目瞭然、C（炭素）の色だけが変わっており、H, N, O, S, 他にも様々な原子について、「暗黙の了解」の色で固定されています。反対に炭素原子の色を自由に選べることで、多量体タンパク質や大きな複合体に対しても自由に色を塗り分けられることができます。<strong>基本的には、このカラーパレットから選びましょう</strong>。</p>
<p>見落としがちですが、下の方にある<strong>set 2</strong>〜<strong>set 6</strong>にも、様々な色が用意されています。set 6のみ水素原子の色が白色でないものが用意されていますが、あまり使うことはないでしょう。</p>
<p>一番上のメニューではCが表示されておらず、HNOSと書かれていますが、これは<strong>炭素以外の原子の色を既定色に変更する</strong>というとても便利なカラーパレットです（&quot;color by heteroatom&quot;）。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code>util.cnc 1alk # color by heteroatom
</code></pre>
<h3 id="by-chain"><a class="header" href="#by-chain">by chain</a></h3>
<h4 id="by-chain-elem-c--ca--無印"><a class="header" href="#by-chain-elem-c--ca--無印">by chain (elem C | */CA, | 無印)</a></h4>
<p>`1つの生体分子オブジェクト内に複数のchainが存在している場合、各chainごとに異なる色で塗り分けてくれます。</p>
<img src="ch02/./image/color/color2.png" width="50%">
<p><code>elem C</code>の場合、チェイン内の全炭素原子に対して色の変更を行い、他の種類の原子には色の変更を行いません。<code>*/CA</code> の場合、主鎖のCα原子のみ色の変更を行い、残りの原子には色の変更を行いません。<code>無印</code>は全原子に対して色の変更を行います。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code>util.color_chains(&quot;(1alk and elem C)&quot;) # elem C
util.color_chains(&quot;(1alk and name CA)&quot;) # */CA
util.color_chains(&quot;(1alk)&quot;) # 無印
</code></pre>
<h4 id="chainbows"><a class="header" href="#chainbows">chainbows</a></h4>
<p><strong>各chainについて</strong>、N末端（5'末端）からC末端（3'末端）にかけて青色から赤色のきれいなグラデーションができるように色を塗り分けてくれます。タンパク質の場合、この配色ならば、<strong>表示された色からアミノ酸配列の位置と構造上での位置の対応関係を把握しやすい</strong>ため、この配色になっている論文を見たことがある方も多いでしょう。</p>
<img src="ch02/./image/color/color3.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># どちらでもOK
util.chainbow 1alk
util.chainbow(&quot;(1alk)&quot;)
</code></pre>
<h4 id="by-segi-elem-c--無印"><a class="header" href="#by-segi-elem-c--無印">by segi (elem C | 無印)</a></h4>
<p>segment identifierによる色分けを行います。</p>
<img src="ch02/./image/color/color4.png" width="50%">
<p>あまり詳しく調べていないのですが、segment identifierは現在仕様が廃止されつつあるのと、カラーリングが赤・青なので、あまり使うことはないでしょう。</p>
<h3 id="by-ss-by-secondary-structure"><a class="header" href="#by-ss-by-secondary-structure">by ss (By Secondary Structure)</a></h3>
<p>タンパク質の二次構造（ヘリックス・シート・ループ）構造を基準に色分けしてくれます。自由に選びましょう。</p>
<img src="ch02/./image/color/colorss.png" width="50%">
<p>コマンドで行う場合で、ヘリックスを赤、シートを黄、それ以外を緑に塗りたいときは、以下のように打てばOKです。</p>
<pre><code>color red, ss h
color yellow, ss s
color green, ss l+''
</code></pre>
<p>または、</p>
<pre><code>util.cbss(&quot;1alk&quot;,&quot;red&quot;,&quot;yellow&quot;,&quot;green&quot;) # オブジェクト1alkについて行いたい場合
</code></pre>
<h3 id="by-rep-by-representation"><a class="header" href="#by-rep-by-representation">by rep (By Representation)</a></h3>
<p>表示形式(representation)ごとに色分けを表示させることができます。これ以外の他のメニューからの色変更は、全表示形式が一括で色変更されてしまうので、うまく使い分けましょう。例えば、by chainで緑・青に色分けをした後に[show]→[surface]としてsurface表示をした状態ですと、</p>
<img src="ch02/./image/color/color5.png" width="50%">
<p>という表示になりますが（コマンドで<code>set transparency, 0.5</code>とし、Surface表示の透明度を変更しています。）、続いて[by rep]→[surface]→[grays]→[white]とすると</p>
<img src="ch02/./image/color/color6.png" width="50%">
<p>このようにSurface表示だけ白くすることができます。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># どちらでもOK
set surface_color, white, 1alk
cmd.set(&quot;surface_color&quot;, &quot;white&quot;, '1alk', quiet=0)
</code></pre>
<p><code>quiet=1</code> とすると処理終了時にメッセージがログ欄に表示されなくなります（プログラミング用）。<code>surface_color</code> の部分を<code>line</code>や<code>cartoon</code>などに変更すればその表示形式に関わる色のみ変更できます。</p>
<h3 id="spectrum"><a class="header" href="#spectrum">spectrum</a></h3>
<h4 id="rainbow-elem-c--ca--無印"><a class="header" href="#rainbow-elem-c--ca--無印">rainbow (elem C | */CA, | 無印)</a></h4>
<p>オブジェクト全体を虹色表示してくれます。[by chain]の[chainbow]と違い、chainごとに虹色グラデーションをつけてくれるわけではないことに注意してください。<code>elem C</code>, <code>*/CA</code>, <code>無印</code>の意味は上と同様です。</p>
<img src="ch02/./image/color/color7.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># elemCの場合。どちらでもOK。
spectrum count, selection=1alk and elem C
cmd.spectrum(&quot;count&quot;,selection=&quot;(1alk)&amp;elem C&quot;)
# */CAの場合
spectrum count, selection=1alk&amp;*/CA
cmd.spectrum(&quot;count&quot;,selection=&quot;(1alk)&amp;*/CA&quot;)
# 無印
spectrum count, selection=1alk, byres=1
cmd.spectrum(&quot;count&quot;,selection=&quot;1alk&quot;,byres=1)
</code></pre>
<h4 id="b-factors-無印--ca"><a class="header" href="#b-factors-無印--ca">b-factors （無印 | */CA）</a></h4>
<p>結晶構造解析法で構造決定された構造ファイルの場合、<strong>b-factor（温度因子）</strong> という値が各原子に対して割り当てられています。簡単に言えば、この値は <strong>その原子のゆらぎやすさ</strong> を表しており、概して分子内部に存在している原子ほど値が小さく、外側に存在する原子ほど大きくなっています。この色表示ではb-factorの値が小さいほど青色に、大きいほど赤色になるよう表示されます。</p>
<img src="ch02/./image/color/color8.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># 無印の場合。どちらでもOK。
spectrum b, selection=1alk, quiet=0
cmd.spectrum(&quot;b&quot;, selection=(&quot;1alk&quot;), quiet=0)
# */CAの場合。どちらでもOK。
spectrum b, selection=1alk&amp;*/CA, quiet=0
cmd.spectrum(&quot;b&quot;, selection=&quot;((1alk)&amp;*/CA)&quot;, quiet=0)
</code></pre>
<p><a href="ch02/../ch05/preset.html#b-factor-putty">表示形式のプリセットの中には、b-factorごとに色と太さを変えてくれる</a>オプションもあります。</p>
<h4 id="area-molecular--solvent"><a class="header" href="#area-molecular--solvent">area (molecular | solvent)</a></h4>
<p>残基あたりのsurface area（表面積）を計算し、それに応じた値でグラデーション色付けをしてくれます。</p>
<img src="ch02/./image/color/color9.png" width="50%">
<p>プログラムの仕様上は<code>get_area</code>コマンドを走らせて、その値に応じた色付けを行っているようです。しかし、solventの方も含めて、かなり雑な計算なのでまったく厳密ではないようです（参考：<a href="https://pymolwiki.org/index.php/Get_Area">https://pymolwiki.org/index.php/Get_Area</a>）。Solvent accessbile surface areaを計算したい場合は、別の厳密なソフトウェアで計算した値を使うことを推奨します。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># molecularの場合（デフォルト）。
util.color_by_area(&quot;1alk&quot;,&quot;molecular&quot;)
# solventの場合
util.color_by_area(&quot;1alk&quot;,&quot;solvent&quot;)
</code></pre>
<h3 id="auto-elem-c--all--by-obj-elem-c--by-obj"><a class="header" href="#auto-elem-c--all--by-obj-elem-c--by-obj">auto (elem C | all | by obj (elem C) | by obj)</a></h3>
<p>自動で色付けをしてくれます。<strong>複数の生体分子オブジェクトがPyMOL上で開かれている場合に有効です</strong>。上2つは、押すたびに色が入れ替わっていきます。緑→シアン→黄→紫……の順に入れ替わります。</p>
<img src="ch02/./image/color/color10.png" width="80%">
<p>下2つの<code>by obj</code> がついているものはロードされている生体分子オブジェクトの上から順に色を緑→シアン→黄→紫……の順で塗り分けてくれます。特に、<strong><code>all</code> を選択して<code>by obj</code> を押せば一発で見慣れた色分けになってくれる</strong>ので便利です。</p>
<img src="ch02/./image/color/color11.png" width="80%">
<p>コマンド入力はこちら(全オブジェクトについて行う場合)</p>
<pre><code>cmd.color(&quot;auto&quot;,&quot;(all) and elem C&quot;)
cmd.color(&quot;auto&quot;,&quot;all&quot;)
util.color_objs(&quot;(all and elem C)&quot;,_self=cmd)
util.color_objs(&quot;(all)&quot;,_self=cmd)
</code></pre>
<h3 id="auto以下に存在する色分けメニューについて"><a class="header" href="#auto以下に存在する色分けメニューについて">auto以下に存在する色分けメニューについて</a></h3>
<p>autoメニューの下には様々なカラーパレットがあります。自由に選択して好きな色を選びましょう。<strong>全表示形式(line, stick, surface...)について同一の色を適用します</strong>。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について赤色で塗る場合)</p>
<pre><code># PyMOL 2.3時代まで
util.color_deep(&quot;red&quot;, '1alk', 0)
# PyMOL 2.4以降（予定）
color_deep red, 1alk
</code></pre>
<h2 id="マウス操作"><a class="header" href="#マウス操作">マウス操作</a></h2>
<p>PyMOLを含む分子描画ソフトウェアの最も重要なユーザーインターフェースが<strong>マウス操作</strong>です。何はともあれ、PyMOLを使うのであればこれを先に読んでマスターしておきましょう。</p>
<p>PyMOLのマウス操作は、外部デバイスとしてのホイール付きマウスを前提に設計されており、左クリックボタン、右クリックボタンとホイールクリックボタンの<strong>3ボタン</strong>をすべて使うことがデフォルト設定となっています。しかし、1人1台のノートパソコンを持つことも珍しくなった現在では外部のマウスを接続して使わずに、備え付けのタッチパッドを使って操作することが多くなりました。タッチパッドはPyMOLの求める3ボタン式になっていないことが多く、ホイールボタンが存在していないためPyMOLのユーザーは不便に感じることがあると思います。こうした状況に対応するべく、PyMOLには実は<strong>2ボタンモード</strong>と<strong>1ボタンモード</strong>が用意されています。これらのモードの説明を交えつつ、PyMOLのマウス操作について詳しく述べていきます。</p>
<h3 id="操作モード"><a class="header" href="#操作モード">操作モード</a></h3>
<p>PyMOLには3ボタンモード、2ボタンモード、1ボタンモードが用意されています。これらのモードは下記のようにさらに細かいモードに分かれます。</p>
<ul>
<li>3ボタンモード
<ul>
<li><strong>3 Button Viewing Mode</strong>（初期設定）</li>
<li>3 Button Editing Mode</li>
<li>3 Button Motions Mode</li>
<li>3 Button Lights Mode</li>
<li>3 Button All Mode</li>
</ul>
</li>
<li>2ボタンモード
<ul>
<li>2 Button Viewing Mode</li>
<li>2 Button Editing Mode</li>
</ul>
</li>
<li>1ボタンモード
<ul>
<li>1 Button Viewing Mode</li>
</ul>
</li>
</ul>
<p>3ボタンモードはホイールボタン付きマウスを利用している場合に最も効果を発揮します。2ボタンモードはタッチパッドのみの環境で、Macbookなどを含むノートパソコンではこの設定にしておくことを推奨します。ここで、それぞれのボタンモードの中にViewing, Editingモードなどが存在していることも覚えておきましょう。これらのモード間ではクリック時の操作が異なります。基本的に、表示した分子を観察する場合はViewingモードを、分子の座標に変更を加える場合にはEditingモードを利用します。</p>
<p>各モードがどのようなマウス操作に対応しているかを理解する前に、まずはPyMOL画面の右下のこの部分に着目します。</p>
<img src="ch02/./image/mouse/1.png">
<p>この赤い四角の部分の一番上には<strong>Mouse Mode 3-Button Viewing</strong>と書かれています。これは<strong>3 Button Viewing Mode</strong>と同じ意味です。ここで、赤い四角の範囲のどこかをクリックすると</p>
<img src="ch02/./image/mouse/2.png">
<p>Mouse Modeが<strong>3-Button Editing</strong>という表示になりました。これは<strong>3 Button Editing Mode</strong>に切り替わったことを表しています。また、青い四角の部分も、<strong>Picking Atoms (and Joints)</strong> に変化しました。最初のうちは、この<strong>Viewing Mode</strong>と<strong>Editing Mode</strong>の2つについて理解しておけば十分だと思います。Lights ModeとAll Modeについては慣れてきたら試してみましょう。2つのモードは上記の赤い四角の部分を押すことで入れ替えることができます。</p>
<p>この画面についてもう少し詳しく見ていきます。ここにはクリックするマウスボタン(L, M, R, Wheel)と補助キーとの組み合わせ(Shift, Ctrl, Ctrl+Shift...)を組み合わせることで、様々なマウス操作が行えることが英語で書かれています(macOSの場合、CtrlはCommand ⌘ キーです)。最上段は対応するキーを押しながらマウスを動かす操作を表しています。例えば、3-Button Viewing Modeにおいては左クリックを押しながらマウスを動かすことで回転操作(Rota)、ミドルクリック（ホイール）を押しながらマウスを動かすことで並進操作(Move)が行えます。ここの表記は簡単なものですが、もし忘れてしまってもここに着目すれば、操作を思い出すことができるでしょう。</p>
<h3 id="各モードにおける操作一覧"><a class="header" href="#各モードにおける操作一覧">各モードにおける操作一覧</a></h3>
<p>各操作の詳細は次項で示します。macOSではCtrlキーはCommandキー(⌘キー)になります。</p>
<p><strong>3 Button Viewing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">並進(Move)</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">スラビング(Slab)</td></tr>
<tr><td align="right">shiftキー</td><td align="right">選択範囲に追加(+Box)</td><td align="right">選択範囲から除去(-Box)</td><td align="right">クリッピング(Clip)</td><td align="right">スラブの移動(MovS)</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">並進(Move)</td><td align="right">原子ピッキング(PkAt)</td><td align="right">1原子ピッキング(Pk1)</td><td align="right">スラブに対する視点の移動(MvSZ)</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">選択(sele)</td><td align="right">Origin指定(Orig)</td><td align="right">クリッピング(Clip)</td><td align="right">ズームイン・アウト(MovZ)</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">選択範囲追加・除去(+/-)</td><td align="right">センタリング(Cent)</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">メニュー表示(Menu)</td><td align="right">-</td><td align="right">原子ピッキング(PkAt)</td><td align="right"> </td></tr>
</tbody></table>
<p><strong>3 Button Editing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">並進(Move)</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">スラビング(Slab)</td></tr>
<tr><td align="right">shiftキー</td><td align="right">オブジェクトの回転(RotO)</td><td align="right">XY軸方向への移動(MovO)</td><td align="right">Z軸方向への移動(MvOZ)</td><td align="right">スラブの移動(MovS)</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">原子の移動(MovA)</td><td align="right">選択範囲追加・除去(+/-)</td><td align="right">二面角をピッキング(PkTB)</td><td align="right">スラブに対する視点の移動(MvSZ)</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">Z軸方向への移動(MvAZ)</td><td align="right">Origin指定(Orig)</td><td align="right">クリッピング(Clip)</td><td align="right">ズームイン・アウト(MovZ)</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">原子ピッキング(PkAt)</td><td align="right">センタリング(Cent)</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">原子の移動(MovA)</td><td align="right">ドラッグモード(DrgM)</td><td align="right">二面角をピッキング(PkTB)</td><td align="right"> </td></tr>
</tbody></table>
<p><strong>2 Button Viewing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">--</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">--</td></tr>
<tr><td align="right">shiftキー</td><td align="right">1原子ピッキング(Pk1)</td><td align="right">--</td><td align="right">クリッピング(Clip)</td><td align="right">--</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">並進(Move)</td><td align="right">--</td><td align="right">原子ピッキング(PkAt)</td><td align="right">--</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">選択(sele)</td><td align="right">--</td><td align="right">センタリング(Cent)</td><td align="right">--</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">原子ピッキング(PkAt)</td><td align="right">--</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">メニュー表示(Menu)</td><td align="right">--</td><td align="right">センタリング(Cent)</td><td align="right"> </td></tr>
</tbody></table>
<h3 id="操作の詳細"><a class="header" href="#操作の詳細">操作の詳細</a></h3>
<h4 id="回転-rota"><a class="header" href="#回転-rota">回転 (Rota)</a></h4>
<p><strong>マウスの左ボタンを押しながらマウスを動かす（ドラッグ）</strong> すると、表示されている分子を回転させることができます。</p>
<video width="100%" height="100%" controls autoplay>
<source src="./image/mouse/rotate.mp4" type="video/mp4">
</video>
<h4 id="並進-move"><a class="header" href="#並進-move">並進 (Move)</a></h4>
<p><strong>マウスのホイールボタンを押しながらドラッグ</strong> すると、表示されている分子を視点に対して平行に移動させることができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/move.mp4" type="video/mp4">
</video>
<h4 id="ズームインアウト-movz"><a class="header" href="#ズームインアウト-movz">ズームイン・アウト (MovZ)</a></h4>
<p><strong>マウスの右ボタンを押しながらマウスを前後にドラッグ、またはCtrlとShiftキーを押しながらマウスのホイールを上下</strong> させると、分子構造を拡大・縮小することができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movz.mp4" type="video/mp4">
</video>
<h4 id="選択--"><a class="header" href="#選択--">選択 (+/-)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でマウスの左ボタンを押す</strong> と、四角のマークが付きます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/select.mp4" type="video/mp4">
</video>
<p>この四角マークは、現在選択されている原子の範囲を示しています。この左クリックによる選択はクリックするたびに選択範囲に追加され、もう一度押すと選択範囲から外されます。</p>
<h4 id="選択範囲に追加除去-box-box"><a class="header" href="#選択範囲に追加除去-box-box">選択範囲に追加/除去 (+Box/-Box)</a></h4>
<p>選択範囲の追加または除去を行います。<strong>+Box(Shiftを押しながらマウスの左クリック＆ドラッグ)</strong> では画面上に黒い四角が現れ、ボタンを離すと、その四角で囲まれた部分が選択範囲に追加されます。反対に、<strong>-Box(Shiftを押しながらマウスのホイールクリック＆ドラッグ)</strong> では四角で囲んだ範囲を選択範囲から除去することができます。同様の操作を繰り返すことも可能です。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/plusbox.mp4" type="video/mp4">
</video>
<h4 id="センタリング-cent"><a class="header" href="#センタリング-cent">センタリング (Cent)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でマウスのホイールボタンを押す</strong> と、その原子が画面中央に来るように視点が移動します。また、回転操作の中心もその点に移動します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/center.mp4" type="video/mp4">
</video>
<h4 id="origin指定-orig"><a class="header" href="#origin指定-orig">Origin指定 (Orig)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でCtrlとShiftを押しながらマウスのホイールボタンを押す</strong> と、その原子を回転中心の原点(origin)に指定することができます。上記センタリングのときと異なり、視点は移動しません。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/origin.mp4" type="video/mp4">
</video>
<h4 id="メニュー表示-menu"><a class="header" href="#メニュー表示-menu">メニュー表示 (Menu)</a></h4>
<p><strong>マウスの左ボタンをダブルクリック</strong> または <strong>右ボタンをクリック</strong> で、メニューを開きます。メニュー内容はクリックした位置によって内容が変化します。</p>
<p>何もない箇所でクリックすると[Main Pop-Up]メニューが表示されます。<br><img src="ch02/./image/mouse/select_menumain.png" width="20%"></p>
<p>オブジェクトの上でクリックすると、クリックした場所に存在する原子についての設定変更を行うメニューが表示されます。<br><img src="ch02/./image/mouse/select_menuatom.png" width="20%"></p>
<h4 id="原子ピッキングpkatpk1"><a class="header" href="#原子ピッキングpkatpk1">原子ピッキング（PkAt/Pk1）</a></h4>
<p>オブジェクト上の原子の上で<strong>Ctrlボタンを押しながらホイールクリック</strong>、または<strong>マウス右ボタンのダブルクリック</strong>を行うと、その原子をピッキングした状態になります(<strong>PkAt</strong>)。</p>
<p>このピッキング状態は先述の選択範囲とは異なる選択形式で、図のような球体のマーカーが付きます。このピッキングは画面上に同時に4原子まで選択することができ、各ピッキングマーカーは図のように二重、三重、四重の球体マーカーで示されます。<br><img src="ch02/./image/mouse/select_pk1.png" width="40%"><img src="ch02/./image/mouse/select_pk2.png" width="40%"></p>
<p><strong>Ctrlボタンを押しながら右クリック (Pk1)</strong> の場合では、上の操作と異なり、1つめの原子ピッキングのみを行います。ピッキングされた原子が2つ、3つ、4つになると、自動でそのピッキングされた原子についての<strong>距離(distance)</strong>、<strong>角度(angle)</strong>、<strong>二面角(dihedral)</strong> を表示してくれます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/pkatom.mp4" type="video/mp4">
</video>
<h4 id="クリッピングclip"><a class="header" href="#クリッピングclip">クリッピング（Clip）</a></h4>
<p>Viewing Modeで<strong>Shiftとマウスの右ボタン（またはCtrl+Shift+マウス右ボタン）を押しながらマウスを上下左右に動かす</strong> と、分子の内部を覗けたり霧をかけたりすることができます。分子内部の一部の領域を強調した画像を取りたいときに作ります。</p>
<p>この機能は2枚の<strong>クリッピング平面（Clipping plane）</strong> によって調節しています。マウスの上下の動きは前面のクリッピング平面(front clipping plane)の位置を、左右の動きは背面のクリッピング平面(rear clipping plane)の位置を調節できます<br>図解<br><img src="ch02/./image/mouse/select_clip1.png" width="80%"><br><strong>画面上にはこの2枚のClipping Planeの間に存在する領域だけが表示されます</strong>。</p>
<p>マウスを画面下に移動させるとfront clipping planeは視点から見て奥へ移動し、分子の内部が見えるようになります。反対に、マウスを上へ移動させると、front clipping planeは手前に移動します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/frontclip.mp4" type="video/mp4">
</video>
<p>マウスを左に移動させるとrear clipping planeが視点から見て奥へ移動します。反対に手前に移動させると、rear clipping planeが手前に移動し、分子の奥側が霧がかかって徐々に見えなくなります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/rearclip.mp4" type="video/mp4">
</video>
<p>霧は画面上部のメニューの[Display]→[Depth Cue(Fogging)]のチェックでON/OFFを選択できます（デフォルトはONです）。<br><img src="ch02/./image/mouse/select_clip5.png" width="100%"></p>
<h4 id="スラビングslab"><a class="header" href="#スラビングslab">スラビング（Slab）</a></h4>
<p>スラブとは英語で厚板、平板という名詞、または「平板にする」という動詞です。PyMOLにおいて<strong>スラブ（Slab、Visible Slabとも）とは、上述の2枚のクリッピング平面の間に挟まれた可視化領域のこと</strong>を指します。</p>
<p>Viewing Modeで<strong>マウスホイールを回転させる</strong> ことで、スラブの厚さを調節することができます。クリッピングとともに、分子構造の内部領域をみたい時に有用です。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/slab.mp4" type="video/mp4">
</video>
<p>画面上部メニューの[Display]→[Clip]には[8 Angstroam Slab]を始めとして30 Åまでの厚さのスラブを選ぶことができます。[Nothing]を選択した場合には、全原子が含まれるように自動的にスラブの厚みを調節します。</p>
<h4 id="スラブの移動movs"><a class="header" href="#スラブの移動movs">スラブの移動（MovS）</a></h4>
<p>Viewing Modeで<strong>Shiftを押しながらマウスホイールを回転させる</strong> と、スラブ領域を、その厚みを保ったまま手前・奥に移動させることができます。効果を実感したい場合は、例として[8 Angstroam Slab]設定をした直後に使ってみるとわかりやすいでしょう。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movs.mp4" type="video/mp4">
</video>
<h4 id="スラブに対する視点の移動mvsz"><a class="header" href="#スラブに対する視点の移動mvsz">スラブに対する視点の移動（MvSZ）</a></h4>
<p>Viewing Modeで<strong>Ctrlを押しながらマウスホイールを回転させる</strong> と、スラブ平面に対して視点を移動させることができます。視点がスラブ内部に入ることもできます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mvsz.mp4" type="video/mp4">
</video>
<h3 id="editing-mode専用コマンド"><a class="header" href="#editing-mode専用コマンド">Editing Mode専用コマンド</a></h3>
<p>以下ではEditing Modeで扱う操作方法について記述します。Editing Modeは<strong>オブジェクト・原子の座標自体に変更を加える</strong>ことが多いため、このモードで操作するときは注意が必要です。<strong>もし誤って座標を動かしてしまった場合、数回であればCtrl-zでUndo（もとに戻す）ことが可能です</strong>。</p>
<h4 id="オブジェクトの回転rotoxy軸方向への移動movoz軸方向への移動mvoz"><a class="header" href="#オブジェクトの回転rotoxy軸方向への移動movoz軸方向への移動mvoz">オブジェクトの回転(RotO)・XY軸方向への移動(MovO)・Z軸方向への移動(MvOZ)</a></h4>
<p>EditingモードでShiftキーとマウスの左ボタン・ホイールボタン・右ボタンを押しながらマウスを移動させることで、オブジェクトの座標に対しそれぞれ回転・XY軸への並進・Z軸へ移動操作を行うことができます。特に、複数のオブジェクトが存在する場合に効果がわかりやすいです。以下の例では緑色と青色で別々のオブジェクトとした上で、青色オブジェクトに対して操作を適用しています。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/roto.mp4" type="video/mp4">
</video>
<h4 id="原子の移動movaz軸方向への移動mvaz"><a class="header" href="#原子の移動movaz軸方向への移動mvaz">原子の移動(MovA)・Z軸方向への移動(MvAZ)</a></h4>
<p>EditingモードでCtrlキーとマウスの左ボタンを押しながらマウスを移動させることで、マウスカーソル上に存在する原子の座標を移動させることができます。Ctrl+Shiftキーとマウスの左ボタンを押しながらだとZ軸方向への移動が行えます。下の例では、オレンジ色の原子（リン酸イオンPO4のリン原子）について操作を適用しています。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mova.mp4" type="video/mp4">
</video>
<h4 id="フラグメントの回転rotf移動movfz軸方向への移動mvfz"><a class="header" href="#フラグメントの回転rotf移動movfz軸方向への移動mvfz">フラグメントの回転(RotF)・移動(MovF)・Z軸方向への移動(MvFZ)</a></h4>
<p>Editingモードで特定の原子を左クリックすると原子がピックされた状態になります。このとき操作メニューが変化して、MovF, MvFZが現れるようになります。RotF（Shift+左クリック）とMovF（Shift+ホイールクリック）はピックされた原子と結合している原子のまとまり（<strong>フラグメント</strong>）を回転させたり、平行移動させたりすることができます。この操作は必ず選択されたフラグメントの上でShiftキーとクリック入力を行う必要があります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movf.mp4" type="video/mp4">
</video>
<p>MvFZ（Shift＋右クリックしながら上下にドラッグ）はピックされたフラグメントを手前または奥に移動させることができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mvfz.mp4" type="video/mp4">
</video>
<h4 id="二面角をピッキングpktb"><a class="header" href="#二面角をピッキングpktb">二面角をピッキング(PkTB)</a></h4>
<p>Editingモードで描画されている結合に対してCtrlキーとマウスの右ボタンを押しながら移動させることで、結合の二面角を変更することができます。</p>
<p><img src="ch02/./image/mouse/pktb1.png" width="40%">　　<img src="ch02/./image/mouse/pktb2.png" width="40%"></p>
<p>2原子を結ぶ結合線上のうち、それぞれの原子に近い位置で操作を実行することで、それぞれ回転される対象が異なることに注意します。
図において、結合線の左半分にマウスカーソルを置いた状態で操作を適用した場合はこの残基の先端のみが回転します。</p>
<p><img src="ch02/./image/mouse/pktb3.png" width="40%">　　<img src="ch02/./image/mouse/pktb4.png" width="40%"></p>
<p>しかし、結合線の右半分にカーソルを置いた状態で操作を適用すると、タンパク質の方が回転します。</p>
<p><img src="ch02/./image/mouse/pktb3.png" width="40%">　　<img src="ch02/./image/mouse/pktb5.png" width="40%"></p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/pktb.mp4" type="video/mp4">
</video>
<h4 id="分子構造をドラッグモードにするdrgm"><a class="header" href="#分子構造をドラッグモードにするdrgm">分子構造をドラッグモードにする(DrgM)</a></h4>
<p>Editingモードでホイールボタンをダブルクリックすると、オブジェクト内のひとつながりの分子構造(Molecule)について&quot;drag&quot;状態にします。このドラッグモードではこれまでのカメラ操作のような感覚で分子の座標を変更することが可能になります。</p>
<p>このドラッグモードにするとオブジェクトパネルの下側に専用のメニューが現れます。PDB: 1alkの場合で図の右側の構造についてこの操作を実行すると、Mgイオンを除いた右半分のChainだけが選択された状態になります。これは上述のひとつながりの分子構造に対してのみ適用されるからです。</p>
<img src="ch02/./image/mouse/drag1.png" width="100%">
<p>さらに、このドラッグモードではShiftキーを押しながらのマウス操作方法が<strong>RotD</strong>, <strong>MovD</strong>, <strong>MvDZ</strong>に変化します。このDはDraggedを表しており、ドラッグモードとなっている選択範囲のみに対してそれぞれ<strong>回転操作</strong>・<strong>XY軸方向への移動</strong>・<strong>Z軸方向への移動</strong>を行うことができます。</p>
<h1 id="セッションの保存"><a class="header" href="#セッションの保存">セッションの保存</a></h1>
<p><strong>セッション</strong>とは、一連のインタラクティブ操作のことを指します（コンピュータ用語）。PyMOLにおいては、開いてから現在に至るまでの作業記録、と考えることができます。つまり、<strong>セッションの保存</strong>を利用すると作業状態をファイルに保存しておくことができ、あとでその状態を復元することができます。この機能を利用すれば、論文の図を作成している最中に様々な設定を試すことができたり、PyMOLの画面の状態を他の人に表示して確認してもらうということも可能になります。</p>
<p>やり方は簡単で、上部メニューの[<strong>File</strong>]から[<strong>Save Session As...</strong>]を選び、ファイル名を指定してSaveボタンを押して保存するだけです。<br><img src="ch02/./image/session/session1.png" width="250px"></p>
<p>Sessionのファイル形式には<strong>pse</strong>形式と<strong>psw</strong>形式の2つがあります。基本的にはpseファイル形式の方で保存する方がよいでしょう。pswファイルで保存した場合は、そのファイルを開くときに全画面表示が標準になります。例えばデスクトップに<code>foo.pse</code>というファイル名で保存したい場合は以下のように入力して[save]ボタンを押します。<br><img src="ch02/./image/session/session2.png" width="400px"></p>
<p>こうして保存されたセッションファイルを再度PyMOLからロードすれば、元の作業状態に戻すことができます。</p>
<p>※ 一度セッションを保存しておけば、以降は[<strong>Save Session</strong>]ボタンを押すことで同名のセッションファイルに上書きしてくれます。</p>
<h1 id="構造ファイルのエクスポート"><a class="header" href="#構造ファイルのエクスポート">構造ファイルのエクスポート</a></h1>
<p>ロードされている構造ファイルの全部または一部を書き出して保存することができます。</p>
<p>上部メニューの[<strong>File</strong>]から[<strong>Export Molecule...</strong>]を選ぶと、保存メニューが現れます。</p>
<p><strong>Selection</strong>の部分はエクスポートする構造オブジェクトの範囲を示しています。<em>enabled</em>は現在オブジェクトパネルで表示をONにしている構造オブジェクトすべてを表します。右のプルダウンメニューには他にも<em>all</em>(ロードしている全構造オブジェクト)や個別の構造ファイルのオブジェクト名が含まれています。</p>
<p><strong>State</strong>は1つのオブジェクトに複数の構造状態を持っている場合に、どの状態を保存するかを表しています。デフォルトは <em>-1 (current)</em> で、現在画面に表示されている状態のものを保存します。</p>
<h2 id="対応している出力ファイル形式"><a class="header" href="#対応している出力ファイル形式">対応している出力ファイル形式</a></h2>
<p><img src="ch02/./image/export/pdbexport4.png" width="300px"><br>
デフォルトでは<code>PDBx/mmCIF (*.cif, *.cif.gz)</code>となっていますが、他にも画像のような様々なファイル形式に出力することができます。</p>
<p>保存メニューには他にも様々なオプションがあります。</p>
<h2 id="generic-options"><a class="header" href="#generic-options">Generic Options</a></h2>
<img src="ch02/./image/export/pdbexport1.png" width="300px">
<p><input type="checkbox" checked="checked"> Original atom order (according to &quot;rank&quot;)</p>
<p>構造オブジェクトの保存時に、ATOM行の並び順を元のファイルの入力通りに並べるかどうかを設定します。例として元のファイルが</p>
<pre><code>ATOM      1  CH3 ACE A   1      33.160  24.100  12.400  1.00  0.00
ATOM      2 HH31 ACE A   1      32.860  24.830  11.650  1.00  0.00
ATOM      3 HH32 ACE A   1      33.800  23.390  11.880  1.00  0.00
ATOM      4 HH33 ACE A   1      32.250  23.650  12.770  1.00  0.00
ATOM      5  C   ACE A   1      33.910  24.800  13.510  1.00  0.00
ATOM      6  O   ACE A   1      33.760  24.560  14.700  1.00  0.00
</code></pre>
<p>だったとしたとき、設定がOFFであればこの並び順は</p>
<pre><code>ATOM      1  C   ACE A   1      33.910  24.800  13.510  1.00  0.00           C
ATOM      2  O   ACE A   1      33.760  24.560  14.700  1.00  0.00           O
ATOM      3  CH3 ACE A   1      33.160  24.100  12.400  1.00  0.00           C
ATOM      4 HH31 ACE A   1      32.860  24.830  11.650  1.00  0.00           H
ATOM      5 HH32 ACE A   1      33.800  23.390  11.880  1.00  0.00           H
ATOM      6 HH33 ACE A   1      32.250  23.650  12.770  1.00  0.00           H
</code></pre>
<p>という順に書き出されます。この並びは<code>atom identifier</code>順になっています。一方、設定がONであればこの並び順は</p>
<pre><code>ATOM      1  CH3 ACE A   1      33.160  24.100  12.400  1.00  0.00           C
ATOM      2 HH31 ACE A   1      32.860  24.830  11.650  1.00  0.00           H
ATOM      3 HH32 ACE A   1      33.800  23.390  11.880  1.00  0.00           H
ATOM      4 HH33 ACE A   1      32.250  23.650  12.770  1.00  0.00           H
ATOM      5  C   ACE A   1      33.910  24.800  13.510  1.00  0.00           C
ATOM      6  O   ACE A   1      33.760  24.560  14.700  1.00  0.00           O
</code></pre>
<p>のように、元のファイルの原子順に書き出されて保存されます。</p>
<p>コマンドラインでは <code>set retain_order, [0,1]</code>で同様の設定を指定できます（0で無効、1で有効）。</p>
<blockquote>
<p>参考： https://pymolwiki.org/index.php/Retain_order</p>
</blockquote>
<h2 id="pdb-options"><a class="header" href="#pdb-options">PDB Options</a></h2>
<p><img src="ch02/./image/export/pdbexport2.png" width="300px"><br>
これらのオプションは従来使われていた<code>pdb</code>ファイル形式で出力するときのみ対応します。</p>
<p><input type="checkbox"> Write multiple bonds as duplicate CONECT records</p>
<p>CONECTレコードを複数作成することで原子間の結合次数の情報をエンコードし、ファイルに書き出します。デフォルトではOFFです。ver. 1.6.1から実装されました。</p>
<p>コマンドラインでは <code>set pdb_conect_nodup, [0,1]</code>で無視して保存するかどうかを指定できます（0で書き出す、1で書き出さない）。</p>
<p><input type="checkbox"> Write CONECT records for all bonds</p>
<p>すべての原子間の結合の組み合わせ情報をCONECTレコードに書き出します。デフォルトではOFFです。</p>
<p>コマンドラインでは <code>set pdb_conect_all, [0,1]</code>で同様の設定を指定できます（0で無効、1で有効）。</p>
<blockquote>
<p>参考： https://pymolwiki.org/index.php/Pdb_conect_all</p>
</blockquote>
<p><input type="checkbox" checked="checked"> Write segment identifier (segi) column</p>
<p>segment identifierを書き出すかどうかを指定します。デフォルトではONです。segment identifierとはPDB formatにおいて73-76番目のカラムを利用した識別子のことです。かつて、同一chain IDにありながらある種の原子のグループごとに分けて記述したい場合に用いられましたが、今はChain IDで分けるのが主流となっています。segment identifierは現在廃止された仕様ですが、PyMOLやChimera, CHARMMなど一部のプログラムは未だにこれを利用することができます。</p>
<p>コマンドラインでは <code>set ignore_pdb_segi, [0,1]</code>で無視して保存するかどうかを指定できます（0で書き出す、1で書き出さない）。</p>
<p><input type="checkbox"> Retain atom ids</p>
<p>構造データのエクスポート時に、原子のIDを1から順になるようリナンバリングするかどうかを指定します。デフォルトではOFFです。</p>
<p>コマンドラインでは <code>set pdb_retain_ids, [0,1]</code>で同様の設定を指定できます（0で無効、1で有効）。</p>
<blockquote>
<p>参考： https://pymolwiki.org/index.php/Pdb_retain_ids</p>
</blockquote>
<p><input type="checkbox"> Write HEADER for every object</p>
<p>このオプションを指定すると、保存時に選択された各オブジェクトがHEADERレコード〜ENDレコードで区切られながら1ファイル中にまとめて書き出されます。こうして書き出されたファイルはマルチエントリPDBファイルとなり、PyMOLでこのファイルをロードしようとすると、各エントリごとに異なるオブジェクトとして表示されるようになります。</p>
<p>対称性情報が含まれている場合、CRYST1レコードも記述されます。</p>
<p>内部処理的にはpdb形式で<code>multisave</code>コマンドを使った保存方法に直接対応しています。</p>
<blockquote>
<p>参考： https://pymolwiki.org/index.php/Multisave</p>
</blockquote>
<h2 id="multi-file"><a class="header" href="#multi-file">Multi-File</a></h2>
<img src="ch02/./image/export/pdbexport3.png" width="300px">
<p>現在PyMOL上で複数表示されているオブジェクトを、複数ファイルに分けてエクスポートしたいときに使うオプションです。さらに、各オブジェクトが2以上のStateを持っている場合（例として、PDB ID:1G03などのNMR構造ファイル、またはMDトラジェクトリをロードしたオブジェクトなど）は、さらにそれらを分割して保存することができます。</p>
<p>デフォルトではone single fileが選択されています。</p>
<p><input type="radio" checked="checked"> one single file
<br>
保存したい対象オブジェクト（上部<code>Selection</code>のところで設定）を1つのファイルにまとめて保存します。保存される対象のStateはメニュー上部の<code>State</code>で変更できます。</p>
<p><input type="radio"> one file per object<br>
複数のオブジェクトが表示されている場合に、各オブジェクトごとにファイルを分割して出力します。デフォルトの出力ファイル名はオブジェクト名に相当する<code>{name}</code>が設定されます。</p>
<p><input type="radio"> one file per object-state<br>
各オブジェクトに複数のstateが存在する場合、上の設定と同様に、<code>{name}_{state}</code>の名前で出力します。</p>
<p><input type="checkbox" checked="checked"> Prompt for every file にチェックが入っている場合は、保存対象ごとにファイル名の指定画面が現れます。例えば、1つのstateを持つAと、20つのstateを持つBのオブジェクトがある場合に<input type="radio" checked="checked"> one file per object-stateを選択すると、21回画面がポップアップすることになります。</p>
<h1 id="画像の保存-3"><a class="header" href="#画像の保存-3">画像の保存</a></h1>
<p>PyMOLで表示されている画像を保存することができます。上部メニューの[<strong>File</strong>]から[<strong>Export Image As...</strong>] → [<strong>PNG</strong>]を選ぶと、保存メニューが現れます。</p>
<img src="ch02/./image/saveimage/saveimage1.png" width="300px">
<p>デフォルトでは&quot;capture current display&quot;と表示されています。</p>
<img src="ch02/./image/saveimage/saveimage2.png" width="300px">
<p>この設定で下にある&quot;Save PNG image as...&quot;を押すと、保存先を指定するメニューが表示され、名前を入れて保存することができます（画像はいずれも<code>bg_color white</code>で白背景にした場合で表示しています）。</p>
<img src="ch02/./image/saveimage/saveimage_1alk.png" width="400px">
<p>これでとりあえず上のような画像を保存することができましたが、他にも様々なメニューがあるので、状況によって使い分けると良いでしょう。まずは、&quot;capture current display&quot;のプルダウンメニューの部分を押すと、</p>
<img src="ch02/./image/saveimage/saveimage3.png" width="300px">
<p>計4つのメニューがあることがわかります。まず&quot;draw antialiased OpenGL image&quot;とすると、描画にアンチエイリアスがかかります（※なおmacOSの場合、現状OpenGL周りの処理にバグがあるためWARNINGSのメッセージが出ています。）</p>
<img src="ch02/./image/saveimage/saveimage_1alk2.png">
<p>続いて&quot;ray trace with opaque background&quot;とすると、ray traceをかけてオブジェクト全体に陰影をつけながら表示することができます。</p>
<img src="ch02/./image/saveimage/saveimage_1alk3.png">
<p>最後に、&quot;ray trace with transparent background&quot;では、ray traceによる陰影と背景の透過処理が行われます（下の画像例では市松模様になっていますが、実際に出力される画像ではきちんと背景が透明になっています）。</p>
<img src="ch02/./image/saveimage/saveimage_1alk4.png">
<p>特に最後のオプションで背景を透明化したものは、スライドに画像を載せるときなどで利用することが多いため、覚えておくと良いでしょう。</p>
<p>また、保存時のパネルには&quot;To render a sized antialiased image, use the Draw/Ray panel in the upper right.&quot;というメッセージが表示されていますが、これはPyMOLのGUI部分の右上にあるメニューのことを指しています。</p>
<img src="ch02/./image/saveimage/saveimage4.png">
<p>これをクリックすると設定メニューが表示されます。</p>
<img src="ch02/./image/saveimage/saveimage5.png" width="400px">
<p>先述のメニューでは出力される縦と横の画像サイズは指定できませんでしたが、先にここのメニューで縦(Height)と横(Width)の値を目的の値に変更しておけば指定することができます。</p>
<p>Unitsは<code>cm</code>または<code>inch</code>を設定できます。また、DPIはdot per inchのことであり、この値が大きいほど画像の解像度が上がる一方、ファイルサイズは大きくなります。論文誌によっては300 DPIを求められる場合がありますので、発表用のものは<code>300</code>にしておくと良いでしょう。</p>
<p><input type="checkbox" checked="checked"> transparent background (&quot;Ray&quot; only) では、先述の背景の透明化処理の有効・無効を設定できます。</p>
<p>出力は&quot;Draw (fast)&quot;と&quot;Ray (slow)&quot;とありますが、これは先述の&quot;draw antialiased OpenGL image&quot;と&quot;ray trace ~&quot;にそれぞれ対応しています。</p>
<p>コマンドラインで行う場合は、各オプションが以下のコマンドに対応しています。</p>
<table><thead><tr><th>オプション</th><th>コマンド</th></tr></thead><tbody>
<tr><td><em>capture current display</em></td><td><code>png foo.png, 0, 0, -1, ray=0</code></td></tr>
<tr><td><em>draw antialiased OpenGL image</em></td><td><code>draw 0, 0 ; png foo.png, 0, 0, -1, ray=0</code></td></tr>
<tr><td><em>ray trace with opaque background</em></td><td><code>set opaque_background, 1; png foo.png, 0, 0, -1, ray=1</code></td></tr>
<tr><td><em>ray trace with transparent background</em></td><td><code>set opaque_background, 0; png foo.png, 0, 0, -1, ray=1</code></td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="分子構造のロード-1"><a class="header" href="#分子構造のロード-1">分子構造のロード</a></h2>
<h3 id="構造ファイルのロード-1"><a class="header" href="#構造ファイルのロード-1">構造ファイルのロード</a></h3>
<p>メニュー左上の[File]から、[Open...]を選び、PyMOLに表示させたい構造ファイルを選択します。ここでは、先程ダウンロードした <code>1alk.cif</code> ファイルを例として、ダブルクリックして表示させてみます。</p>
<img src="ch02/./image/load/load1.png" width="25%">
<p>すると、画面に1ALKのアルカリフォスファターゼの構造が表示されました。はじめは黒背景に緑のタンパク質がオブジェクトが浮かんでいると思いますが、ここで続けて、メニューの[Display]から[Background]-&gt;[White]を選択すると、白背景にすることができます。</p>
<p><img src="ch02/./image/load/load3.png" width="40%"><br>
<img src="ch02/./image/load/load2.png" width="80%"></p>
<h3 id="サポートしている構造ファイル形式-1"><a class="header" href="#サポートしている構造ファイル形式-1">サポートしている構造ファイル形式</a></h3>
<p>PyMOLが読み込むことのできる構造ファイルフォーマットはたくさんありますが、まず以下の2つのファイル形式を覚えましょう。</p>
<ul>
<li>pdbフォーマット
<ul>
<li>ファイル名の最後に<code>.pdb</code>（<strong>拡張子</strong>）がついているのが目印です。PDBが設立された当初から使われているファイルフォーマットで、PyMOLの表示に使う座標情報だけでなく、結晶学（NMR）的情報（B-factor、 空間群、単位格子定数…）、 構造的特徴（2次構造、SS結合… ）、実験情報（解像度、回折実験情報、精密化条件、結晶化条件… ）、生物学的情報（蛋白質名、種名、生物学的単位、EC番号… ）、化学的情報（化合物の名称や構造…）、文献情報などが記載されており、慣れれば人間でも読みやすく、必要最低限の情報が記述されています。しかし、時代が下るとともにこのフォーマットでは限界や不便な点が指摘されるようになりました。特に、近年は結晶解析だけでなくクライオ電子顕微鏡などの技術の発達により、巨大タンパク質の構造決定が次々と報告されるようになりましたが、従来のPDBフォーマットの最も大きな問題点の1つには100,000原子以上からなる構造、または多数のアミノ酸鎖（63チェイン以上）から構成される複合体の構造情報の記述をほとんど想定していなかったことがあります。このため、後述の<strong>mmCIF</strong>形式の利用が推奨されるようになりました。</li>
</ul>
</li>
<li>mmCIFフォーマット
<ul>
<li>ファイル名の最後に<code>.cif</code>がついているのが目印です。元来、mmCIFファイルフォーマットは国際結晶学連合が低分子用に定めていたCIF(Crystallographic Information File)形式を高分子(macromolecular)に拡張したものです。pdbフォーマットでは1ファイル内に記述することができなかった、100,000原子数以上または63チェイン以上の構造記述が可能になっています。例えばPDB: 3J3QのHIV-1 capsidは超巨大分子であり、従来のPDBフォーマットでは配布されていません。<strong>2014年にPDBの標準フォーマットとなり、2019年7月1日からは、PDBに登録する際にmmCIF形式での構造情報登録を義務付けられるようになりました。</strong> このmmCIF形式がこれからのスタンダードとなっていくことは間違いありません。ファイルの中身はpdbフォーマットの内容の上位互換となっており、最近の構造可視化ソフトウェアはすべてこれに対応するよう調整をしています。</li>
</ul>
</li>
</ul>
<p>他のファイル形式として、以下のものがあります。多くの場合、ファイル名末尾についている拡張子で見分けることが可能です。詳細な記述文法については、ここでは本題ではないので省略します。</p>
<ul>
<li>生体高分子系・電子密度情報
<ul>
<li>
<p>CCP4フォーマット: 拡張子は<code>.ccp4</code>, <code>.map</code>, <code>.mrc</code>。電子密度マップ。</p>
</li>
<li>
<p>PDBMLフォーマット: 拡張子は<code>.xml</code>, <code>.pdbml</code>。コンピュータ間でのデータのやり取りや管理が簡単になるように設計された<strong>XMLファイルフォーマット</strong>をPDB用に特化させたものです。RCSB PDBでも配布されており、mmCIF形式とほぼ同一の情報が書き込まれています。ファイルサイズがmmCIFに比べて大きいことや、中身を見ても人間には読みにくい文法になっていますが、各プログラム言語が持っているXMLパーサ（構文解析器）にかけることでデータ構造の複合体に変換することが容易なため、インフォマティクスの専門家からは好まれるファイル形式です。</p>
</li>
<li>
<p>MMTFフォーマット: 拡張子は<code>.mmtf</code>。Macromolecular Transmission Formatの略称で、2016年頃から活発になり始めた<strong>新しいPDBファイル形式</strong>です。https://mmtf.rcsb.org/ によればMMTFの大きな特長はバイナリ化されていることであり、mmCIFフォーマットの1/3以下へのファイル縮小、そして最高で400倍以上の高速な読み込みが可能となっています。PyMOL 2.2.0以降でMMTFファイルフォーマットの読み込み・書き出しができるようになったようですが、まだ書き出しあたりには不十分なところもあります。これはViral Capsid（PDB: 3J3Q）のような超巨大タンパク質の表示にとても便利です。</p>
</li>
<li>
<p>MacroModelフォーマット: 拡張子は<code>.mmod</code>, <code>.mmd</code>。Schrödinger社のMacroModelやMaestroで使われているファイルフォーマット。</p>
</li>
</ul>
</li>
<li>小分子化合物系
<ul>
<li>MOLフォーマット: 拡張子は<code>.mol</code>。MDL Information Systems社が開発した、化学構造式を記述する標準フォーマットの1つです。詳細はCTFile formatというガイドに記載されています。</li>
<li>MOL Structure Data Fileフォーマット: 拡張子は<code>.sdf</code>。上記MOL形式を改良し、複数の構造式を1ファイルに記述でき、さらに様々な付加情報を追記することができるようになっています。</li>
<li>SYBYL MOL2フォーマット: 拡張子は<code>.mol2</code>。Tripos（現Certara）が開発した、SYBYLと呼ばれるケモインフォマティクスのソフトウェアで使われていたファイルフォーマットです。タンパク質などの巨大分子でもこのファイル形式で書くことが可能です。詳細はSYBYL MOL2 formatというガイドに記載されています。</li>
<li>XYZフォーマット: 拡張子は<code>.xyz</code>。単純に原子の種類と原子の\( xyz \)座標を記述するファイル形式です。http://openbabel.org/wiki/XYZ_(format) に説明があります。</li>
</ul>
</li>
</ul>
<p>以下の拡張子は、表のように別のファイル拡張子として認識されます。</p>
<table><thead><tr><th align="right">入力拡張子</th><th align="right">認識されるファイル拡張子</th></tr></thead><tbody>
<tr><td align="right"><code>ent</code>, <code>p5m</code></td><td align="right"><code>pdb</code></td></tr>
<tr><td align="right"><code>mmd</code>, <code>out</code>, <code>dat</code></td><td align="right"><code>mmod</code></td></tr>
<tr><td align="right"><code>map</code>, <code>mrc</code></td><td align="right"><code>ccp4</code></td></tr>
<tr><td align="right"><code>cc2</code></td><td align="right"><code>cc1</code></td></tr>
<tr><td align="right"><code>sd</code></td><td align="right"><code>sdf</code></td></tr>
<tr><td align="right"><code>rst7</code></td><td align="right"><code>rst</code></td></tr>
<tr><td align="right"><code>o</code>, <code>dsn6</code>, <code>omap</code></td><td align="right"><code>brix</code></td></tr>
<tr><td align="right"><code>ph4</code></td><td align="right"><code>moe</code></td></tr>
<tr><td align="right"><code>spi</code></td><td align="right"><code>spider</code></td></tr>
<tr><td align="right"><code>pym</code>, <code>pyc</code></td><td align="right"><code>py</code></td></tr>
<tr><td align="right"><code>p1m</code>, <code>pim</code></td><td align="right"><code>pml</code></td></tr>
<tr><td align="right"><code>xml</code></td><td align="right"><code>pdbml</code></td></tr>
</tbody></table>
<h3 id="biological-unitを考慮した分子構造のロード-1"><a class="header" href="#biological-unitを考慮した分子構造のロード-1">Biological Unitを考慮した分子構造のロード</a></h3>
<p>タンパク質は1本のアミノ酸ポリペプチド鎖が折り畳まって存在しているのがほとんどですが、タンパク質の種類によっては、多量体の形で初めて安定に存在し機能しうるものもあります。<strong>Biological Unit</strong>（Biological Assemblyとも呼ばれる）とは、実際に生物の中で機能している構造の状態のことを指します。詳しくはPDBjのウェブサイトの「<a href="https://pdbj.org/help/pdb_aubu">非対称単位と生物学的単位について</a>」も参照してください。</p>
<p>例として<code>PDB ID: 1ALK</code>（大腸菌由来アルカリフォスファターゼ）と<code>PDB ID: 1EW2</code>（ヒト由来アルカリフォスファターゼ）を比較してみましょう。各構造ファイルを取り扱うRCSB PDBのウェブサイト（ https://www.rcsb.org/structure/1ALK と https://www.rcsb.org/structure/1EW2 ）のStructure Summaryタブで画面左の方には、タンパク質の構造とともに、Global SymmetryとGlobal Stoichiometryの情報が書かれています。</p>
<img src="ch02/./image/load/bunit1.png" width="80%">
<p>Global Stoichiometryには<code>Homo 2-mer - A2</code>という情報が記されています。論文で調べてみても、このタンパク質がそれぞれホモ2量体として生物中で機能していることが示されています。しかしそれぞれのファイルをPyMOLで単純に開いてみますと、1ALKの方にはA chain、B chainの構造が含まれていますが、1EW2の方ではA chainしか含まれていません。これは、<strong>PDBに登録されている原子座標のデータには、必要最小限の「非対称単位」(assymmetric unit)のみ含まれているから</strong> です。</p>
<p>そこで、場合によっては2量体の状態でタンパク質構造を表示してみたいということがあると思います。PyMOL 1.8からはこのBiological Unitを考慮した構造のロードが簡単に行えるようになりましたので、それを<code>1EW2</code>ファイルに対してやってみます。以下の画像のように、[File]-&gt;[Get PDB...]を選び、続くウィンドウの画面でIDとAssembly情報を入力します。</p>
<p><img src="ch02/./image/load/bunit2.png" width="25%"><br>
<img src="ch02/./image/load/bunit3.png" width="40%"></p>
<p>これにより、1EW2の構造がホモ2量体構造で表示されました。</p>
<img src="ch02/./image/load/bunit4.png" width="60%">
<p>このチェインを別々に扱うためには、右側のオブジェクトパネルから<code>1EW2A</code>のAボタンをクリックし、[state] -&gt; [split]を開いてクリックします。</p>
<img src="ch02/./image/load/bunit5.png" width="30%">
<p>すると、<code>1EW2A_0001</code>, <code>1EW2A_0002</code>というオブジェクトが新たに生成されます。ここまでくれば<code>1EW2A</code>オブジェクトは不要ですので、最後に<code>1EW2A</code>のAボタンから[delete object]を押せば完了です。</p>
<img src="ch02/./image/load/bunit6.png" width="80%">
<p>以上がBiological Unitを考慮した分子構造のロード操作ですが、これは一例であり、他にも同等の操作を達成する方法があります。コマンドラインで上記の操作を達成するには</p>
<pre><code>set assembly, 1
fetch 1ew2
split_states 1ew2
delete 1ew2
</code></pre>
<p>でOKです。タイピングが早ければこちらの方が素早くできるでしょう。<code>set assembly, 1</code>に相当する設定変更は、上部メニューの[Setting] -&gt; [mmCIF File Loading] -&gt; [Load Assembly (Biological Unit)]にチェックを入れることでも可能です。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="構造ファイルのロード-2"><a class="header" href="#構造ファイルのロード-2">構造ファイルのロード</a></h3>
<p>メニュー左上の[File]から、[Open...]を選び、PyMOLに表示させたい構造ファイルを選択します。ここでは、先程ダウンロードした <code>1alk.cif</code> ファイルを例として、ダブルクリックして表示させてみます。</p>
<img src="ch02/./image/load/load1.png" width="25%">
<p>すると、画面に1ALKのアルカリフォスファターゼの構造が表示されました。はじめは黒背景に緑のタンパク質がオブジェクトが浮かんでいると思いますが、ここで続けて、メニューの[Display]から[Background]-&gt;[White]を選択すると、白背景にすることができます。</p>
<p><img src="ch02/./image/load/load3.png" width="40%"><br>
<img src="ch02/./image/load/load2.png" width="80%"></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="サポートしている構造ファイル形式-2"><a class="header" href="#サポートしている構造ファイル形式-2">サポートしている構造ファイル形式</a></h3>
<p>PyMOLが読み込むことのできる構造ファイルフォーマットはたくさんありますが、まず以下の2つのファイル形式を覚えましょう。</p>
<ul>
<li>pdbフォーマット
<ul>
<li>ファイル名の最後に<code>.pdb</code>（<strong>拡張子</strong>）がついているのが目印です。PDBが設立された当初から使われているファイルフォーマットで、PyMOLの表示に使う座標情報だけでなく、結晶学（NMR）的情報（B-factor、 空間群、単位格子定数…）、 構造的特徴（2次構造、SS結合… ）、実験情報（解像度、回折実験情報、精密化条件、結晶化条件… ）、生物学的情報（蛋白質名、種名、生物学的単位、EC番号… ）、化学的情報（化合物の名称や構造…）、文献情報などが記載されており、慣れれば人間でも読みやすく、必要最低限の情報が記述されています。しかし、時代が下るとともにこのフォーマットでは限界や不便な点が指摘されるようになりました。特に、近年は結晶解析だけでなくクライオ電子顕微鏡などの技術の発達により、巨大タンパク質の構造決定が次々と報告されるようになりましたが、従来のPDBフォーマットの最も大きな問題点の1つには100,000原子以上からなる構造、または多数のアミノ酸鎖（63チェイン以上）から構成される複合体の構造情報の記述をほとんど想定していなかったことがあります。このため、後述の<strong>mmCIF</strong>形式の利用が推奨されるようになりました。</li>
</ul>
</li>
<li>mmCIFフォーマット
<ul>
<li>ファイル名の最後に<code>.cif</code>がついているのが目印です。元来、mmCIFファイルフォーマットは国際結晶学連合が低分子用に定めていたCIF(Crystallographic Information File)形式を高分子(macromolecular)に拡張したものです。pdbフォーマットでは1ファイル内に記述することができなかった、100,000原子数以上または63チェイン以上の構造記述が可能になっています。例えばPDB: 3J3QのHIV-1 capsidは超巨大分子であり、従来のPDBフォーマットでは配布されていません。<strong>2014年にPDBの標準フォーマットとなり、2019年7月1日からは、PDBに登録する際にmmCIF形式での構造情報登録を義務付けられるようになりました。</strong> このmmCIF形式がこれからのスタンダードとなっていくことは間違いありません。ファイルの中身はpdbフォーマットの内容の上位互換となっており、最近の構造可視化ソフトウェアはすべてこれに対応するよう調整をしています。</li>
</ul>
</li>
</ul>
<p>他のファイル形式として、以下のものがあります。多くの場合、ファイル名末尾についている拡張子で見分けることが可能です。詳細な記述文法については、ここでは本題ではないので省略します。</p>
<ul>
<li>生体高分子系・電子密度情報
<ul>
<li>
<p>CCP4フォーマット: 拡張子は<code>.ccp4</code>, <code>.map</code>, <code>.mrc</code>。電子密度マップ。</p>
</li>
<li>
<p>PDBMLフォーマット: 拡張子は<code>.xml</code>, <code>.pdbml</code>。コンピュータ間でのデータのやり取りや管理が簡単になるように設計された<strong>XMLファイルフォーマット</strong>をPDB用に特化させたものです。RCSB PDBでも配布されており、mmCIF形式とほぼ同一の情報が書き込まれています。ファイルサイズがmmCIFに比べて大きいことや、中身を見ても人間には読みにくい文法になっていますが、各プログラム言語が持っているXMLパーサ（構文解析器）にかけることでデータ構造の複合体に変換することが容易なため、インフォマティクスの専門家からは好まれるファイル形式です。</p>
</li>
<li>
<p>MMTFフォーマット: 拡張子は<code>.mmtf</code>。Macromolecular Transmission Formatの略称で、2016年頃から活発になり始めた<strong>新しいPDBファイル形式</strong>です。https://mmtf.rcsb.org/ によればMMTFの大きな特長はバイナリ化されていることであり、mmCIFフォーマットの1/3以下へのファイル縮小、そして最高で400倍以上の高速な読み込みが可能となっています。PyMOL 2.2.0以降でMMTFファイルフォーマットの読み込み・書き出しができるようになったようですが、まだ書き出しあたりには不十分なところもあります。これはViral Capsid（PDB: 3J3Q）のような超巨大タンパク質の表示にとても便利です。</p>
</li>
<li>
<p>MacroModelフォーマット: 拡張子は<code>.mmod</code>, <code>.mmd</code>。Schrödinger社のMacroModelやMaestroで使われているファイルフォーマット。</p>
</li>
</ul>
</li>
<li>小分子化合物系
<ul>
<li>MOLフォーマット: 拡張子は<code>.mol</code>。MDL Information Systems社が開発した、化学構造式を記述する標準フォーマットの1つです。詳細はCTFile formatというガイドに記載されています。</li>
<li>MOL Structure Data Fileフォーマット: 拡張子は<code>.sdf</code>。上記MOL形式を改良し、複数の構造式を1ファイルに記述でき、さらに様々な付加情報を追記することができるようになっています。</li>
<li>SYBYL MOL2フォーマット: 拡張子は<code>.mol2</code>。Tripos（現Certara）が開発した、SYBYLと呼ばれるケモインフォマティクスのソフトウェアで使われていたファイルフォーマットです。タンパク質などの巨大分子でもこのファイル形式で書くことが可能です。詳細はSYBYL MOL2 formatというガイドに記載されています。</li>
<li>XYZフォーマット: 拡張子は<code>.xyz</code>。単純に原子の種類と原子の\( xyz \)座標を記述するファイル形式です。http://openbabel.org/wiki/XYZ_(format) に説明があります。</li>
</ul>
</li>
</ul>
<p>以下の拡張子は、表のように別のファイル拡張子として認識されます。</p>
<table><thead><tr><th align="right">入力拡張子</th><th align="right">認識されるファイル拡張子</th></tr></thead><tbody>
<tr><td align="right"><code>ent</code>, <code>p5m</code></td><td align="right"><code>pdb</code></td></tr>
<tr><td align="right"><code>mmd</code>, <code>out</code>, <code>dat</code></td><td align="right"><code>mmod</code></td></tr>
<tr><td align="right"><code>map</code>, <code>mrc</code></td><td align="right"><code>ccp4</code></td></tr>
<tr><td align="right"><code>cc2</code></td><td align="right"><code>cc1</code></td></tr>
<tr><td align="right"><code>sd</code></td><td align="right"><code>sdf</code></td></tr>
<tr><td align="right"><code>rst7</code></td><td align="right"><code>rst</code></td></tr>
<tr><td align="right"><code>o</code>, <code>dsn6</code>, <code>omap</code></td><td align="right"><code>brix</code></td></tr>
<tr><td align="right"><code>ph4</code></td><td align="right"><code>moe</code></td></tr>
<tr><td align="right"><code>spi</code></td><td align="right"><code>spider</code></td></tr>
<tr><td align="right"><code>pym</code>, <code>pyc</code></td><td align="right"><code>py</code></td></tr>
<tr><td align="right"><code>p1m</code>, <code>pim</code></td><td align="right"><code>pml</code></td></tr>
<tr><td align="right"><code>xml</code></td><td align="right"><code>pdbml</code></td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="biological-unitを考慮した分子構造のロード-2"><a class="header" href="#biological-unitを考慮した分子構造のロード-2">Biological Unitを考慮した分子構造のロード</a></h3>
<p>タンパク質は1本のアミノ酸ポリペプチド鎖が折り畳まって存在しているのがほとんどですが、タンパク質の種類によっては、多量体の形で初めて安定に存在し機能しうるものもあります。<strong>Biological Unit</strong>（Biological Assemblyとも呼ばれる）とは、実際に生物の中で機能している構造の状態のことを指します。詳しくはPDBjのウェブサイトの「<a href="https://pdbj.org/help/pdb_aubu">非対称単位と生物学的単位について</a>」も参照してください。</p>
<p>例として<code>PDB ID: 1ALK</code>（大腸菌由来アルカリフォスファターゼ）と<code>PDB ID: 1EW2</code>（ヒト由来アルカリフォスファターゼ）を比較してみましょう。各構造ファイルを取り扱うRCSB PDBのウェブサイト（ https://www.rcsb.org/structure/1ALK と https://www.rcsb.org/structure/1EW2 ）のStructure Summaryタブで画面左の方には、タンパク質の構造とともに、Global SymmetryとGlobal Stoichiometryの情報が書かれています。</p>
<img src="ch02/./image/load/bunit1.png" width="80%">
<p>Global Stoichiometryには<code>Homo 2-mer - A2</code>という情報が記されています。論文で調べてみても、このタンパク質がそれぞれホモ2量体として生物中で機能していることが示されています。しかしそれぞれのファイルをPyMOLで単純に開いてみますと、1ALKの方にはA chain、B chainの構造が含まれていますが、1EW2の方ではA chainしか含まれていません。これは、<strong>PDBに登録されている原子座標のデータには、必要最小限の「非対称単位」(assymmetric unit)のみ含まれているから</strong> です。</p>
<p>そこで、場合によっては2量体の状態でタンパク質構造を表示してみたいということがあると思います。PyMOL 1.8からはこのBiological Unitを考慮した構造のロードが簡単に行えるようになりましたので、それを<code>1EW2</code>ファイルに対してやってみます。以下の画像のように、[File]-&gt;[Get PDB...]を選び、続くウィンドウの画面でIDとAssembly情報を入力します。</p>
<p><img src="ch02/./image/load/bunit2.png" width="25%"><br>
<img src="ch02/./image/load/bunit3.png" width="40%"></p>
<p>これにより、1EW2の構造がホモ2量体構造で表示されました。</p>
<img src="ch02/./image/load/bunit4.png" width="60%">
<p>このチェインを別々に扱うためには、右側のオブジェクトパネルから<code>1EW2A</code>のAボタンをクリックし、[state] -&gt; [split]を開いてクリックします。</p>
<img src="ch02/./image/load/bunit5.png" width="30%">
<p>すると、<code>1EW2A_0001</code>, <code>1EW2A_0002</code>というオブジェクトが新たに生成されます。ここまでくれば<code>1EW2A</code>オブジェクトは不要ですので、最後に<code>1EW2A</code>のAボタンから[delete object]を押せば完了です。</p>
<img src="ch02/./image/load/bunit6.png" width="80%">
<p>以上がBiological Unitを考慮した分子構造のロード操作ですが、これは一例であり、他にも同等の操作を達成する方法があります。コマンドラインで上記の操作を達成するには</p>
<pre><code>set assembly, 1
fetch 1ew2
split_states 1ew2
delete 1ew2
</code></pre>
<p>でOKです。タイピングが早ければこちらの方が素早くできるでしょう。<code>set assembly, 1</code>に相当する設定変更は、上部メニューの[Setting] -&gt; [mmCIF File Loading] -&gt; [Load Assembly (Biological Unit)]にチェックを入れることでも可能です。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="配列の表示-1"><a class="header" href="#配列の表示-1">配列の表示</a></h2>
<p>分子構造をロードしたら、ここでPyMOL画面の右下に注目してみます。ここには様々な記号や文字が並んでいますが、ここのSボタンを押してみましょう。</p>
<img src="ch02/./image/viewer/seq1.png" width="40%">
<p>このSボタンを押すと、画面に分子の配列情報が現れます。もう一度Sボタンを押すと文字列が隠れます。</p>
<img src="ch02/./image/viewer/seq2.png" width="80%">
<p>ここに表示される配列の文字列は、タンパク質の場合にはA, C, Dなどアミノ酸の1文字表記、核酸構造の場合にはDA, DT, DG, DCで2文字表記となっています。RNAの場合には1文字表記ですが、タンパク質の場合と異なり、各文字にスペースが挿入されて表示されます。リガンドやその他のについては3文字表記で表されることが多いです。これらの表記は、ロードする構造ファイル内の記述に依存してします。</p>
<p>配列の表示・非表示は、上部メニューの[Display]→[Sequence]にチェックを入れたり外したりすることでも行うことができます。</p>
<p>以下に、配列表示ウィンドウ上でのマウス操作を方法を記します。macOSの場合はCtrlはCmdキーになります。</p>
<ul>
<li><strong>左クリック＋ドラッグ</strong>
<ul>
<li>分子の一部を選択した状態にできます。選択した箇所にはハイライトが付きます。タンパク質の場合は残基ごと、核酸の場合は塩基ごと、それ以外の場合は1分子ごとに選択します。</li>
</ul>
</li>
<li><strong>Shift+左クリック</strong>
<ul>
<li>上記の選択範囲を拡張・縮小することができます。クリックボタンを押し続ける必要はありません。</li>
</ul>
</li>
<li><strong>Ctrl+Shift+左クリック</strong>
<ul>
<li>選択範囲を拡張・縮小しつつ、視点を選択範囲にセンタリングしてくれます。</li>
</ul>
</li>
<li><strong>ホイールクリック</strong>
<ul>
<li>クリックした箇所に視点をセンタリングします。</li>
</ul>
</li>
<li><strong>Ctrl+ホイールクリック</strong>
<ul>
<li>クリックした箇所に視点を大きくズームします。</li>
</ul>
</li>
<li><strong>Ctrl+ホイールクリック+Shift+ドラッグ</strong>
<ul>
<li>Shift+ドラッグで選んだ選択範囲に向かって視点を大きくズームします。</li>
</ul>
</li>
<li><strong>右クリック</strong>
<ul>
<li>選択されていない箇所で右クリックをすると、その位置に存在する配列を選択し、それについての設定変更メニューを表示します。</li>
<li>すでに選択されている箇所で右クリックをすると、選択範囲に対する設定変更メニューを表示します。</li>
</ul>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="オブジェクトパネル-1"><a class="header" href="#オブジェクトパネル-1">オブジェクトパネル</a></h2>
<p>PyMOL画面の右側には、ロードしている分子構造について様々な操作を行えるパネルが表示されています。</p>
<img src="ch02/./image/viewer/objectpanel1.png" width="40%">
<p>画像の例では<code>all</code>と<code>1alk</code>が表示されています。また、画面上の分子構造をクリックし選択すると、<code>(sele)</code>という表示も追加されます。このパネルに表示されている文字のことを<strong>オブジェクト</strong>と呼びます。その右についているA, S, H, L, Cという文字のボタンには、対応するオブジェクトについての表示設定変更・編集を行うためのメニューがたくさん格納されています。それぞれの文字が表す大まかな意味は以下の通り。</p>
<ul>
<li><strong>Action(A)</strong>
<ul>
<li>視点の移動や分子についての編集、一括設定変更、構造のアラインや名前変更など、オブジェクト全体に関わる様々な設定を行うためのメニューが格納されています。</li>
</ul>
</li>
<li><strong>Show (S)</strong>
<ul>
<li>分子構造の表示形式をONにするためのメニューが格納されています。</li>
</ul>
</li>
<li><strong>Hide (H)</strong>
<ul>
<li>分子構造の表示形式をOFFにするためのメニューが格納されています。</li>
</ul>
</li>
<li><strong>Label (L)</strong>
<ul>
<li>分子構造のすぐそばに表示する文字ラベルを追加するためのメニューが格納されています。</li>
</ul>
</li>
<li><strong>Color (C)</strong>
<ul>
<li>分子構造の色変更を行うためのメニューが格納されています。</li>
</ul>
</li>
</ul>
<h2 id="分子構造の表示形式のonoff-show-and-hide-1"><a class="header" href="#分子構造の表示形式のonoff-show-and-hide-1">分子構造の表示形式のON/OFF (Show and Hide)</a></h2>
<p>タンパク質の構造情報をロードしたとき、デフォルト設定では、20種類のアミノ酸についてはCartoon表示形式と呼ばれる漫画風な表現形式になっています。このCartoon表示形式では、αヘリックスを形成している部分については大きな螺旋で描かれ、βストランド（βシート）を形成している部分については、進行方向に向かって矢印が伸びる表現で描かれています。</p>
<p>タンパク質を構成するアミノ酸を1つ1つ強調して見てみたい場合には、<strong>Cartoon</strong>, <strong>Line</strong>, <strong>Stick</strong>, <strong>Ribbon</strong>, <strong>Sphere</strong>, <strong>Dot</strong>, <strong>Surface</strong>, <strong>Mesh</strong> 表示などの、他の表示形式をONにするという操作を行います。この表示形式の設定は、各オブジェクト構造について個別に行います。例えば、先程ロードした1alkのタンパク質オブジェクトについて他の表示形式をONにしたい場合は、図のように、1alkの<strong>Sマーク部分（図の赤四角部分のボタン）</strong> をクリックします。反対に、OFFにしたい場合は<strong>Hマーク部分（図の青四角部分のボタン）</strong> を押し、各表示形式を選択することでOFFになります。</p>
<img src="ch02/./image/display/disp1.png" width="40%">
<p><img src="ch02/./image/display/disp3.png" width="40%"><br></p>
<!--
set_view (\
     0.990649223,   -0.127824500,    0.047657397,\
     0.136341795,    0.915909708,   -0.377514422,\
     0.004605473,    0.380482703,    0.924775600,\
    -0.000116501,   -0.000019159,  -50.788997650,\
    29.517896652,    2.209085464,   19.883510590,\
     0.894756913,  100.680503845,  -20.000000000 )
-->
<p>各表示形式のサンプルを以下に示します。</p>
<ul>
<li>
<p><strong>Cartoon表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_cartoon.png" width="40%">
</li>
<li>タンパク質やDNA・RNAを表示するときにおすすめです。タンパク質の場合はαヘリックスやβシートが先述のように螺旋や矢印で示されます。DNA/RNAが存在する場合には、各塩基の概形や5'末端→3'末端のつながりが強調して表示されます。</li>
</ul>
</li>
<li>
<p><strong>Line表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_line.png" width="40%"><img src="ch02/./image/display/disp_linecartoon.png" width="40%"><br></li>
<li>各原子間の結合が細い線で表示されます。上の図では、左にLine表示だけをONにしたものを、右にCartoon表示形式をLine表示とともにONにした場合を右図に示しています（以降、見やすくするためにCartoon表示をONにした上で、他の表示形式を載せます）。</li>
<li>各原子は構造情報ファイルの座標のATOMまたはHETATMレコードに書かれている座標情報（\( x, y, z \)の3次元ベクトル）をもとにプロットされ、各原子座標の距離が一定以内にあれば、自動的にその近い2点が直線で結ばれて表示される仕様となっていることに気をつけてください。</li>
</ul>
</li>
<li>
<p><strong>Stick表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_stick.png" width="40%"><br></li>
<li>各原子間の結合がLine表示よりも太いStickで表示されます。Stickは円筒状に表現されます。</li>
</ul>
</li>
<li>
<p><strong>Ribbon表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_ribbon.png" width="40%"><br></li>
<li>タンパク質または核酸の鎖部分のみを単純な線で表現する形式です。</li>
</ul>
</li>
<li>
<p><strong>Sphere表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_sphere.png" width="40%"><br></li>
<li>各原子を大きな球体で表現します。Line, Stick表示と異なり、各原子間は直線で結ばれません。</li>
</ul>
</li>
<li>
<p><strong>Dot表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_dot.png" width="40%"><br></li>
<li>Sphere表示の表面を点で表現したような形式です。</li>
</ul>
</li>
<li>
<p><strong>Surface表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_surface.png" width="40%"><br></li>
<li>各原子の表面を滑らかに描画する形式です。分子の大きさによっては、レンダリングに少し時間がかかります。</li>
</ul>
</li>
<li>
<p><strong>Mesh表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_mesh.png" width="40%"><br></li>
<li>Surface表示と似ていますが、表面の描画を網掛けで表現します。</li>
</ul>
</li>
</ul>
<h2 id="ラベルの設定label-1"><a class="header" href="#ラベルの設定label-1">ラベルの設定(Label)</a></h2>
<p><strong>ラベル</strong>を利用することで、分子の周辺に文字を表示させることができます。活性部位周辺に存在する残基の名前と番号を表示させるだけでなく、任意の文字列を表示させることができます。</p>
<p><img src="ch02/./image/label/label1.png" width="40%"><br></p>
<p><a href="ch02/./showandhide.html">分子構造の表示形式のON/OFF (Show and Hide)</a>のときと同様に、オブジェクトパネルから各オブジェクトに対して個別にラベルの設定を行うことができます。特に、選択範囲<code>(sele)</code>に対して表示させることが多いでしょう。</p>
<img src="ch02/./image/label/labelmenu.png" width="40%">
<p><strong>ラベルの設定変更</strong>はGUIの上部メニューから、Setting -&gt; Labelのところにあり、ラベルの表示サイズやフォント指定、色の指定などが可能です。下記のサンプルではフォントサイズを28にしてあります。</p>
<p><strong>ラベルの位置変更</strong>は3-Button Editing Modeにしてから、ラベルの上でCtrl(macOSの場合はCommand)を押しながら左クリックでドラッグさせることで任意の位置に移動させることができます。下の例ではASP-101を右に移動させています。</p>
<img src="ch02/./image/label/label_res.png" width="49%">
<img src="ch02/./image/label/label_res2.png" width="49%">
<h3 id="clear-1"><a class="header" href="#clear-1">clear</a></h3>
<p>すでに表示されているそのオブジェクトについてのラベル表示を消去します。消去するのではなく表示を一時的に場合は、Hideメニューからlabelを選択しましょう。</p>
<hr>
<h3 id="residues-1"><a class="header" href="#residues-1">residues</a></h3>
<p>選択されたオブジェクトについて、アミノ酸と残基番号の情報を<code>（アミノ酸3文字表記）-（残基番号）</code>の形で表示します(例：MET-1)。Cα原子の上に表示される設定になっています。</p>
<img src="ch02/./image/label/label_res.png" width="50%">
<h3 id="residues-one-letter-1"><a class="header" href="#residues-one-letter-1">residues (one letter)</a></h3>
<p>選択されたオブジェクトについて、アミノ酸と残基番号の情報を<code>（アミノ酸1文字表記）（残基番号）</code>の形で表示します(例：M1)。Cα原子の上に表示される設定になっています。</p>
<img src="ch02/./image/label/label_resone.png" width="50%">
<h3 id="chains-1"><a class="header" href="#chains-1">chains</a></h3>
<p>選択されたオブジェクトのN末端とC末端の番号を持つ残基（リガンドが存在する場合、それも含む）のそばに<code>chain &lt;chain ID&gt;</code>の形で表示します（例： chain A）。</p>
<img src="ch02/./image/label/label_chain.png" width="50%">
<h3 id="segments-1"><a class="header" href="#segments-1">segments</a></h3>
<p>すでに使用が廃止されたsegment identifierの情報を、chainsと同様に表示します。詳しくは<a href="ch02/../append01/term.html#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88segment-identifier">Appendix: 用語#セグメント</a>を参照してください。今となってはあまり使うことはないと思います。</p>
<hr>
<h3 id="atom-name-1"><a class="header" href="#atom-name-1">atom name</a></h3>
<p>原子名の名前でラベルを作成します。<code>.pdb</code>形式ファイルの場合、<code>ATOM</code>, <code>HETATM</code>レコードの13-16列目に含まれる文字列がatom nameとして定義されており、この文字列を返します。</p>
<img src="ch02/./image/label/label_atomname.png" width="50%">
<p>タンパク質アミノ酸やDNA, RNAの場合は命名規則があるため、慣れてしまえばatom nameの意味を理解しやすいと思います。13-14列目には右詰めで原子名を表します。例えば鉄原子は13-14列目を使ってFEの文字が入っていますが、炭素原子は14列目にCの文字を入れ、13列目は空白となっています。しかし、水素原子の場合は13-16列目の4文字分を最大限使って記述する場合があり、この場合は13列目から記入することになっています。</p>
<p>以下ではよく登場するatom nameの一例です。</p>
<table><thead><tr><th align="right">atom name</th><th align="right">意味</th></tr></thead><tbody>
<tr><td align="right">CA</td><td align="right">主鎖のα位の炭素</td></tr>
<tr><td align="right">N</td><td align="right">主鎖のN末端側窒素原子</td></tr>
<tr><td align="right">C</td><td align="right">主鎖のC末端側炭素原子</td></tr>
<tr><td align="right">O</td><td align="right">主鎖のC末端側酸素原子</td></tr>
<tr><td align="right">CB</td><td align="right">側鎖のβ位の炭素</td></tr>
<tr><td align="right">CG</td><td align="right">側鎖のγ位の炭素</td></tr>
<tr><td align="right">CD</td><td align="right">側鎖のδ位の炭素</td></tr>
<tr><td align="right">CE</td><td align="right">側鎖のε位の炭素</td></tr>
<tr><td align="right">CZ</td><td align="right">側鎖のζ位の炭素（チロシンなど）</td></tr>
<tr><td align="right">OH</td><td align="right">側鎖のη位の炭素（チロシンなど）</td></tr>
</tbody></table>
<p>主鎖に近い原子の個数順にβ→γ→δ→ε→ζ→ηと付ける命名規則があります。複数原子が存在するようなアミノ酸（ヒスチジン）などはND1, CD1, CE2, NE2というふうに番号をつけて区別します。</p>
<h3 id="element-symbol-1"><a class="header" href="#element-symbol-1">element symbol</a></h3>
<p>原子名を表記します。</p>
<img src="ch02/./image/label/label_esymbol.png" width="50%">
<h3 id="residue-name-1"><a class="header" href="#residue-name-1">residue name</a></h3>
<p>3文字表記の残基名を表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの18-20列目の文字列を返します。存在しない場合は空白になります（以下同様）。</p>
<img src="ch02/./image/label/label_resn.png" width="50%">
<h3 id="one-letter-code-1"><a class="header" href="#one-letter-code-1">one letter code</a></h3>
<p>1文字表記の残基名を表記します。</p>
<img src="ch02/./image/label/label_resnone.png" width="50%">
<h3 id="residue-identifier-1"><a class="header" href="#residue-identifier-1">residue identifier</a></h3>
<p>残基のresidue IDを表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの23-26列目の文字列を返します。</p>
<img src="ch02/./image/label/label_resi.png" width="50%">
<h3 id="chain-identifier-1"><a class="header" href="#chain-identifier-1">chain identifier</a></h3>
<p>残基のChain IDを表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの22列目の文字列を返します。</p>
<img src="ch02/./image/label/label_chainid.png" width="50%">
<h3 id="segment-identifier-1"><a class="header" href="#segment-identifier-1">segment identifier</a></h3>
<p>残基のSegment IDを表記します。詳しくは<a href="ch02/../append01/term.html#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88segment-identifier">Appendix: 用語#セグメント</a>を参照してください。</p>
<hr>
<h3 id="b-factor-1"><a class="header" href="#b-factor-1">b-factor</a></h3>
<p>各原子の温度因子（b-factor; temperature facotr）を表記します。<code>.pdb</code>ファイル形式における61-66列目の文字列を返します。</p>
<img src="ch02/./image/label/label_bfactor.png" width="50%">
<h3 id="occupancy-1"><a class="header" href="#occupancy-1">occupancy</a></h3>
<p>各原子の重み因子を表記します。<code>.pdb</code>ファイル形式における55-60列目の文字列を返します。結晶中では基本的に構造は繰り返しになるため、どの場所を見ても同じ座標がループしている事が多く、この値は<code>1.00</code>であることが多いのですが、時々その繰り返し構造単位の中に、1より大きなn通りの配座を持っていることがあります。このとき、ここには0~1の小数値が入ります。例としては PDB: 1A6MのGLN-8が<code>0.57</code>, <code>0.43</code>の値を持つ2通りの配座を持ち、同様にTYR-151も<code>0.50</code>, <code>0.50</code>で2通りの配座を持っています。この場合、PyMOLの表示上でも2通りの残基配座が見えます。画像はPDB: 1A6MのGLN-8の例を示しています。</p>
<img src="ch02/./image/label/label_occupancy.png" width="50%">
<h3 id="vdw-radius-1"><a class="header" href="#vdw-radius-1">vdw radius</a></h3>
<p>各原子のファンデルワールス半径の値（Å）を表記します。基本的には原子の種類によって固定の値です。</p>
<img src="ch02/./image/label/label_vdw.png" width="50%">
<hr>
<h3 id="other-properties-1"><a class="header" href="#other-properties-1">Other properties</a></h3>
<h4 id="formal-charge-1"><a class="header" href="#formal-charge-1">formal charge</a></h4>
<p>各残基についてシステムで定義されている電荷を表記します。例としてLys, Arg残基の場合は<code>+1</code>を、Glu, Asp残基の場合には<code>-1</code>を表示します。</p>
<img src="ch02/./image/label/label_fchrg.png" width="50%">
<h4 id="partial-charge-1"><a class="header" href="#partial-charge-1">partial charge</a></h4>
<p>各原子について計算された部分電荷(partial charge)を表記します。これは通常の<code>pdb</code>, <code>mmCIF</code>といった構造ファイルには含まれていないため、<code>0.00</code>と表示されてしまいますが、<code>pqr</code>や<code>mol2</code>ファイル形式をロードしたときに真価を発揮します。</p>
<p>タンパク質構造の場合は構造ファイルをいったんロードした後、<a href="ch02/../ch04/apbs.html">APBSプラグインを使った表面電荷表示</a>の手順に従って処理を進めます。このときにオブジェクトパネルに<code>run01</code>-&gt;<code>prepared01</code>というオブジェクトが生成されるので、<code>prepared01</code>オブジェクトのラベル設定でpartial chargeを選択すると図のように部分電荷が表示されるようになります。</p>
<img src="ch02/./image/label/label_partchg.png" width="90%">
<p>より正確に言えば、これはPDB2PQRというソフトウェアによって分子動力学シミュレーションソフトウェアAMBERが配布している力場AmberFFに基づいて指定されており、各アミノ酸の原子ごとに固有の値を指定してくれます。</p>
<p>実態としてはPQRファイルの記述様式にのっとり、x, y, z座標の次にくるchargeの値を表記しています。</p>
<blockquote>
<p>参考：<a href="https://www.mdanalysis.org/docs/documentation_pages/coordinates/PQR.html">6.15. PQR file format</a></p>
</blockquote>
<p>mol2形式の場合でも対応しています。</p>
<img src="ch02/./image/label/label_partchgmol2.png" width="50%">
<p>GaussianやGAMESSなどの量子化学計算ソフトウェアで計算した部分電荷を図にして見てみたいときに特に有効です。</p>
<h4 id="elec-radius-1"><a class="header" href="#elec-radius-1">elec. radius</a></h4>
<p>partial chargeのときと同様に、PQRファイルのオブジェクトの場合に効果を発揮します。PQRファイル内のx, y, z座標, chargeの次にくるradiusの値を表記しています。vdw radiusとは異なります。</p>
<img src="ch02/./image/label/label_eradius.png" width="50%">
<h4 id="text-type-numeric-type-1"><a class="header" href="#text-type-numeric-type-1">text type, numeric type</a></h4>
<p>PyMOL 2.0以降は廃止されているらしく、使われていないようです（詳細不明）</p>
<h4 id="stereochemistry-1"><a class="header" href="#stereochemistry-1">stereochemistry</a></h4>
<p>PyMOL 2.2から実装されました。schrodingerのソフトまたはrdkitモジュールのインストールが求められるようです。不斉炭素原子の部分にラベルを置いてくれる機能？</p>
<hr>
<h3 id="atom-identifiers-1"><a class="header" href="#atom-identifiers-1">atom identifiers</a></h3>
<h4 id="rank-1"><a class="header" href="#rank-1">rank</a></h4>
<p>rankを表記します。rankとは構造ファイルの上から順に<code>ATOM</code>, <code>HETATM</code>レコードを取得したときの通し番号のことであり、これのみ<strong>0始まり</strong>となっています。</p>
<img src="ch02/./image/label/label_rank.png" width="50%">
<blockquote>
<p>“rank” selects atoms based on their position in the source file, starting with zero as the first number.</p>
</blockquote>
<h4 id="id-1"><a class="header" href="#id-1">ID</a></h4>
<p>IDを表記します。IDとは構造ファイルから忠実に取得したATOM IDのことであり、<code>pdb</code>ファイルフォーマットで言えば7-11列目に存在する番号のことを指します。この値は整数値でなければなりません。</p>
<img src="ch02/./image/label/label_id.png" width="50%">
<blockquote>
<p>“id” selects atoms based on the atom identifier number from the source file, which must be a integer.</p>
</blockquote>
<h4 id="index-1"><a class="header" href="#index-1">index</a></h4>
<p>Indexを表記します。indexはrankと似ていますが、順に表示するのとは異なり、PyMOL内部で番号を順に振り直したのがindexです。例えばある1つのアミノ酸残基があったとき、その残基の中で登場する原子の順番をどのように入れ替えても、index表記ではN→CA→C→O→CB→……の順に若い数字を付けていきます。</p>
<img src="ch02/./image/label/label_index.png" width="50%">
<blockquote>
<p>“index” selects atoms based on their internal PyMOL object atom indices starting with one as the first number.</p>
</blockquote>
<h2 id="色の設定color-1"><a class="header" href="#色の設定color-1">色の設定(Color)</a></h2>
<img src="ch02/./image/color/colormenu.png" width="25%">
<p>色の設定の仕方は自由です、センスの見せ所です……とは言うものの、<strong>実はタンパク質の構造を毎日見るであろう構造生物学専門の研究者さんにとっては、ある暗黙の了解があります</strong>。それらを踏まえた上で、PyMOLのカラーリング機能を紹介していきましょう。</p>
<h3 id="色設定の暗黙の了解-1"><a class="header" href="#色設定の暗黙の了解-1">色設定の暗黙の了解</a></h3>
<p>以下のルールだけは遵守しましょう。</p>
<ul>
<li>常に<strong>酸素原子は<span style="color:red;">赤</span>色, 窒素原子は<span style="color:blue;">青</span>色, 硫黄原子は<span style="color:#E7C640;">オリーブ（olive）</span>色</strong>で表示する。</li>
<li>存在する場合、水素原子は白色で表示。</li>
<li>よって炭素原子は、<strong>上記以外の色</strong>を使う。</li>
</ul>
<p>メチオニン残基の表示の例（炭素原子はgreen）</p>
<img src="ch02/./image/color/color1.png" width="50%">
<p>PyMOLには、酸素・窒素・窒素・水素原子を上記の色ルールで描画してくれるメニュー（&quot;<strong>by element</strong>&quot;）が存在しますので、これを使うことを強く推奨します。</p>
<p>正確には、PyMOLでは酸素原子はカラーコードで#FF7C7C (255, 76, 76) [1.0, 0.3, 0.3], 窒素原子は#3333FF (51,51,255) [0.2, 0.2, 1.0], 硫黄原子は#E7C640 (231, 198, 64) [0.9, 0.775, 0.25]がデフォルトで割り当てられているため、用意されているカラーパレットを使う限りにはこれらの色と完全にかぶることはないのですが、それでもこれらに近い色を使うと紛らわしいので、使用は控えましょう。また、以下で見るように、用意されているカラーパレットの中にはすべての原子を同一で塗るものもあるので、どうしてもそれらの色を使いたい場合は、そのカラーパレットを選択した後に&quot;<strong>by element</strong>&quot;メニューの一番上のカラーリング（通称&quot;color by hetetoatom&quot;）を選択してあげましょう。</p>
<h3 id="by-element-1"><a class="header" href="#by-element-1">by element</a></h3>
<p>メニューを開いていただけると一目瞭然、C（炭素）の色だけが変わっており、H, N, O, S, 他にも様々な原子について、「暗黙の了解」の色で固定されています。反対に炭素原子の色を自由に選べることで、多量体タンパク質や大きな複合体に対しても自由に色を塗り分けられることができます。<strong>基本的には、このカラーパレットから選びましょう</strong>。</p>
<p>見落としがちですが、下の方にある<strong>set 2</strong>〜<strong>set 6</strong>にも、様々な色が用意されています。set 6のみ水素原子の色が白色でないものが用意されていますが、あまり使うことはないでしょう。</p>
<p>一番上のメニューではCが表示されておらず、HNOSと書かれていますが、これは<strong>炭素以外の原子の色を既定色に変更する</strong>というとても便利なカラーパレットです（&quot;color by heteroatom&quot;）。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code>util.cnc 1alk # color by heteroatom
</code></pre>
<h3 id="by-chain-1"><a class="header" href="#by-chain-1">by chain</a></h3>
<h4 id="by-chain-elem-c--ca--無印-1"><a class="header" href="#by-chain-elem-c--ca--無印-1">by chain (elem C | */CA, | 無印)</a></h4>
<p>`1つの生体分子オブジェクト内に複数のchainが存在している場合、各chainごとに異なる色で塗り分けてくれます。</p>
<img src="ch02/./image/color/color2.png" width="50%">
<p><code>elem C</code>の場合、チェイン内の全炭素原子に対して色の変更を行い、他の種類の原子には色の変更を行いません。<code>*/CA</code> の場合、主鎖のCα原子のみ色の変更を行い、残りの原子には色の変更を行いません。<code>無印</code>は全原子に対して色の変更を行います。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code>util.color_chains(&quot;(1alk and elem C)&quot;) # elem C
util.color_chains(&quot;(1alk and name CA)&quot;) # */CA
util.color_chains(&quot;(1alk)&quot;) # 無印
</code></pre>
<h4 id="chainbows-1"><a class="header" href="#chainbows-1">chainbows</a></h4>
<p><strong>各chainについて</strong>、N末端（5'末端）からC末端（3'末端）にかけて青色から赤色のきれいなグラデーションができるように色を塗り分けてくれます。タンパク質の場合、この配色ならば、<strong>表示された色からアミノ酸配列の位置と構造上での位置の対応関係を把握しやすい</strong>ため、この配色になっている論文を見たことがある方も多いでしょう。</p>
<img src="ch02/./image/color/color3.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># どちらでもOK
util.chainbow 1alk
util.chainbow(&quot;(1alk)&quot;)
</code></pre>
<h4 id="by-segi-elem-c--無印-1"><a class="header" href="#by-segi-elem-c--無印-1">by segi (elem C | 無印)</a></h4>
<p>segment identifierによる色分けを行います。</p>
<img src="ch02/./image/color/color4.png" width="50%">
<p>あまり詳しく調べていないのですが、segment identifierは現在仕様が廃止されつつあるのと、カラーリングが赤・青なので、あまり使うことはないでしょう。</p>
<h3 id="by-ss-by-secondary-structure-1"><a class="header" href="#by-ss-by-secondary-structure-1">by ss (By Secondary Structure)</a></h3>
<p>タンパク質の二次構造（ヘリックス・シート・ループ）構造を基準に色分けしてくれます。自由に選びましょう。</p>
<img src="ch02/./image/color/colorss.png" width="50%">
<p>コマンドで行う場合で、ヘリックスを赤、シートを黄、それ以外を緑に塗りたいときは、以下のように打てばOKです。</p>
<pre><code>color red, ss h
color yellow, ss s
color green, ss l+''
</code></pre>
<p>または、</p>
<pre><code>util.cbss(&quot;1alk&quot;,&quot;red&quot;,&quot;yellow&quot;,&quot;green&quot;) # オブジェクト1alkについて行いたい場合
</code></pre>
<h3 id="by-rep-by-representation-1"><a class="header" href="#by-rep-by-representation-1">by rep (By Representation)</a></h3>
<p>表示形式(representation)ごとに色分けを表示させることができます。これ以外の他のメニューからの色変更は、全表示形式が一括で色変更されてしまうので、うまく使い分けましょう。例えば、by chainで緑・青に色分けをした後に[show]→[surface]としてsurface表示をした状態ですと、</p>
<img src="ch02/./image/color/color5.png" width="50%">
<p>という表示になりますが（コマンドで<code>set transparency, 0.5</code>とし、Surface表示の透明度を変更しています。）、続いて[by rep]→[surface]→[grays]→[white]とすると</p>
<img src="ch02/./image/color/color6.png" width="50%">
<p>このようにSurface表示だけ白くすることができます。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># どちらでもOK
set surface_color, white, 1alk
cmd.set(&quot;surface_color&quot;, &quot;white&quot;, '1alk', quiet=0)
</code></pre>
<p><code>quiet=1</code> とすると処理終了時にメッセージがログ欄に表示されなくなります（プログラミング用）。<code>surface_color</code> の部分を<code>line</code>や<code>cartoon</code>などに変更すればその表示形式に関わる色のみ変更できます。</p>
<h3 id="spectrum-1"><a class="header" href="#spectrum-1">spectrum</a></h3>
<h4 id="rainbow-elem-c--ca--無印-1"><a class="header" href="#rainbow-elem-c--ca--無印-1">rainbow (elem C | */CA, | 無印)</a></h4>
<p>オブジェクト全体を虹色表示してくれます。[by chain]の[chainbow]と違い、chainごとに虹色グラデーションをつけてくれるわけではないことに注意してください。<code>elem C</code>, <code>*/CA</code>, <code>無印</code>の意味は上と同様です。</p>
<img src="ch02/./image/color/color7.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># elemCの場合。どちらでもOK。
spectrum count, selection=1alk and elem C
cmd.spectrum(&quot;count&quot;,selection=&quot;(1alk)&amp;elem C&quot;)
# */CAの場合
spectrum count, selection=1alk&amp;*/CA
cmd.spectrum(&quot;count&quot;,selection=&quot;(1alk)&amp;*/CA&quot;)
# 無印
spectrum count, selection=1alk, byres=1
cmd.spectrum(&quot;count&quot;,selection=&quot;1alk&quot;,byres=1)
</code></pre>
<h4 id="b-factors-無印--ca-1"><a class="header" href="#b-factors-無印--ca-1">b-factors （無印 | */CA）</a></h4>
<p>結晶構造解析法で構造決定された構造ファイルの場合、<strong>b-factor（温度因子）</strong> という値が各原子に対して割り当てられています。簡単に言えば、この値は <strong>その原子のゆらぎやすさ</strong> を表しており、概して分子内部に存在している原子ほど値が小さく、外側に存在する原子ほど大きくなっています。この色表示ではb-factorの値が小さいほど青色に、大きいほど赤色になるよう表示されます。</p>
<img src="ch02/./image/color/color8.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># 無印の場合。どちらでもOK。
spectrum b, selection=1alk, quiet=0
cmd.spectrum(&quot;b&quot;, selection=(&quot;1alk&quot;), quiet=0)
# */CAの場合。どちらでもOK。
spectrum b, selection=1alk&amp;*/CA, quiet=0
cmd.spectrum(&quot;b&quot;, selection=&quot;((1alk)&amp;*/CA)&quot;, quiet=0)
</code></pre>
<p><a href="ch02/../ch05/preset.html#b-factor-putty">表示形式のプリセットの中には、b-factorごとに色と太さを変えてくれる</a>オプションもあります。</p>
<h4 id="area-molecular--solvent-1"><a class="header" href="#area-molecular--solvent-1">area (molecular | solvent)</a></h4>
<p>残基あたりのsurface area（表面積）を計算し、それに応じた値でグラデーション色付けをしてくれます。</p>
<img src="ch02/./image/color/color9.png" width="50%">
<p>プログラムの仕様上は<code>get_area</code>コマンドを走らせて、その値に応じた色付けを行っているようです。しかし、solventの方も含めて、かなり雑な計算なのでまったく厳密ではないようです（参考：<a href="https://pymolwiki.org/index.php/Get_Area">https://pymolwiki.org/index.php/Get_Area</a>）。Solvent accessbile surface areaを計算したい場合は、別の厳密なソフトウェアで計算した値を使うことを推奨します。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># molecularの場合（デフォルト）。
util.color_by_area(&quot;1alk&quot;,&quot;molecular&quot;)
# solventの場合
util.color_by_area(&quot;1alk&quot;,&quot;solvent&quot;)
</code></pre>
<h3 id="auto-elem-c--all--by-obj-elem-c--by-obj-1"><a class="header" href="#auto-elem-c--all--by-obj-elem-c--by-obj-1">auto (elem C | all | by obj (elem C) | by obj)</a></h3>
<p>自動で色付けをしてくれます。<strong>複数の生体分子オブジェクトがPyMOL上で開かれている場合に有効です</strong>。上2つは、押すたびに色が入れ替わっていきます。緑→シアン→黄→紫……の順に入れ替わります。</p>
<img src="ch02/./image/color/color10.png" width="80%">
<p>下2つの<code>by obj</code> がついているものはロードされている生体分子オブジェクトの上から順に色を緑→シアン→黄→紫……の順で塗り分けてくれます。特に、<strong><code>all</code> を選択して<code>by obj</code> を押せば一発で見慣れた色分けになってくれる</strong>ので便利です。</p>
<img src="ch02/./image/color/color11.png" width="80%">
<p>コマンド入力はこちら(全オブジェクトについて行う場合)</p>
<pre><code>cmd.color(&quot;auto&quot;,&quot;(all) and elem C&quot;)
cmd.color(&quot;auto&quot;,&quot;all&quot;)
util.color_objs(&quot;(all and elem C)&quot;,_self=cmd)
util.color_objs(&quot;(all)&quot;,_self=cmd)
</code></pre>
<h3 id="auto以下に存在する色分けメニューについて-1"><a class="header" href="#auto以下に存在する色分けメニューについて-1">auto以下に存在する色分けメニューについて</a></h3>
<p>autoメニューの下には様々なカラーパレットがあります。自由に選択して好きな色を選びましょう。<strong>全表示形式(line, stick, surface...)について同一の色を適用します</strong>。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について赤色で塗る場合)</p>
<pre><code># PyMOL 2.3時代まで
util.color_deep(&quot;red&quot;, '1alk', 0)
# PyMOL 2.4以降（予定）
color_deep red, 1alk
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="分子構造の表示形式のonoff-show-and-hide-2"><a class="header" href="#分子構造の表示形式のonoff-show-and-hide-2">分子構造の表示形式のON/OFF (Show and Hide)</a></h2>
<p>タンパク質の構造情報をロードしたとき、デフォルト設定では、20種類のアミノ酸についてはCartoon表示形式と呼ばれる漫画風な表現形式になっています。このCartoon表示形式では、αヘリックスを形成している部分については大きな螺旋で描かれ、βストランド（βシート）を形成している部分については、進行方向に向かって矢印が伸びる表現で描かれています。</p>
<p>タンパク質を構成するアミノ酸を1つ1つ強調して見てみたい場合には、<strong>Cartoon</strong>, <strong>Line</strong>, <strong>Stick</strong>, <strong>Ribbon</strong>, <strong>Sphere</strong>, <strong>Dot</strong>, <strong>Surface</strong>, <strong>Mesh</strong> 表示などの、他の表示形式をONにするという操作を行います。この表示形式の設定は、各オブジェクト構造について個別に行います。例えば、先程ロードした1alkのタンパク質オブジェクトについて他の表示形式をONにしたい場合は、図のように、1alkの<strong>Sマーク部分（図の赤四角部分のボタン）</strong> をクリックします。反対に、OFFにしたい場合は<strong>Hマーク部分（図の青四角部分のボタン）</strong> を押し、各表示形式を選択することでOFFになります。</p>
<img src="ch02/./image/display/disp1.png" width="40%">
<p><img src="ch02/./image/display/disp3.png" width="40%"><br></p>
<!--
set_view (\
     0.990649223,   -0.127824500,    0.047657397,\
     0.136341795,    0.915909708,   -0.377514422,\
     0.004605473,    0.380482703,    0.924775600,\
    -0.000116501,   -0.000019159,  -50.788997650,\
    29.517896652,    2.209085464,   19.883510590,\
     0.894756913,  100.680503845,  -20.000000000 )
-->
<p>各表示形式のサンプルを以下に示します。</p>
<ul>
<li>
<p><strong>Cartoon表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_cartoon.png" width="40%">
</li>
<li>タンパク質やDNA・RNAを表示するときにおすすめです。タンパク質の場合はαヘリックスやβシートが先述のように螺旋や矢印で示されます。DNA/RNAが存在する場合には、各塩基の概形や5'末端→3'末端のつながりが強調して表示されます。</li>
</ul>
</li>
<li>
<p><strong>Line表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_line.png" width="40%"><img src="ch02/./image/display/disp_linecartoon.png" width="40%"><br></li>
<li>各原子間の結合が細い線で表示されます。上の図では、左にLine表示だけをONにしたものを、右にCartoon表示形式をLine表示とともにONにした場合を右図に示しています（以降、見やすくするためにCartoon表示をONにした上で、他の表示形式を載せます）。</li>
<li>各原子は構造情報ファイルの座標のATOMまたはHETATMレコードに書かれている座標情報（\( x, y, z \)の3次元ベクトル）をもとにプロットされ、各原子座標の距離が一定以内にあれば、自動的にその近い2点が直線で結ばれて表示される仕様となっていることに気をつけてください。</li>
</ul>
</li>
<li>
<p><strong>Stick表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_stick.png" width="40%"><br></li>
<li>各原子間の結合がLine表示よりも太いStickで表示されます。Stickは円筒状に表現されます。</li>
</ul>
</li>
<li>
<p><strong>Ribbon表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_ribbon.png" width="40%"><br></li>
<li>タンパク質または核酸の鎖部分のみを単純な線で表現する形式です。</li>
</ul>
</li>
<li>
<p><strong>Sphere表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_sphere.png" width="40%"><br></li>
<li>各原子を大きな球体で表現します。Line, Stick表示と異なり、各原子間は直線で結ばれません。</li>
</ul>
</li>
<li>
<p><strong>Dot表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_dot.png" width="40%"><br></li>
<li>Sphere表示の表面を点で表現したような形式です。</li>
</ul>
</li>
<li>
<p><strong>Surface表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_surface.png" width="40%"><br></li>
<li>各原子の表面を滑らかに描画する形式です。分子の大きさによっては、レンダリングに少し時間がかかります。</li>
</ul>
</li>
<li>
<p><strong>Mesh表示</strong></p>
<ul>
<li><img src="ch02/./image/display/disp_mesh.png" width="40%"><br></li>
<li>Surface表示と似ていますが、表面の描画を網掛けで表現します。</li>
</ul>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="ラベルの設定label-2"><a class="header" href="#ラベルの設定label-2">ラベルの設定(Label)</a></h2>
<p><strong>ラベル</strong>を利用することで、分子の周辺に文字を表示させることができます。活性部位周辺に存在する残基の名前と番号を表示させるだけでなく、任意の文字列を表示させることができます。</p>
<p><img src="ch02/./image/label/label1.png" width="40%"><br></p>
<p><a href="ch02/./showandhide.html">分子構造の表示形式のON/OFF (Show and Hide)</a>のときと同様に、オブジェクトパネルから各オブジェクトに対して個別にラベルの設定を行うことができます。特に、選択範囲<code>(sele)</code>に対して表示させることが多いでしょう。</p>
<img src="ch02/./image/label/labelmenu.png" width="40%">
<p><strong>ラベルの設定変更</strong>はGUIの上部メニューから、Setting -&gt; Labelのところにあり、ラベルの表示サイズやフォント指定、色の指定などが可能です。下記のサンプルではフォントサイズを28にしてあります。</p>
<p><strong>ラベルの位置変更</strong>は3-Button Editing Modeにしてから、ラベルの上でCtrl(macOSの場合はCommand)を押しながら左クリックでドラッグさせることで任意の位置に移動させることができます。下の例ではASP-101を右に移動させています。</p>
<img src="ch02/./image/label/label_res.png" width="49%">
<img src="ch02/./image/label/label_res2.png" width="49%">
<h3 id="clear-2"><a class="header" href="#clear-2">clear</a></h3>
<p>すでに表示されているそのオブジェクトについてのラベル表示を消去します。消去するのではなく表示を一時的に場合は、Hideメニューからlabelを選択しましょう。</p>
<hr>
<h3 id="residues-2"><a class="header" href="#residues-2">residues</a></h3>
<p>選択されたオブジェクトについて、アミノ酸と残基番号の情報を<code>（アミノ酸3文字表記）-（残基番号）</code>の形で表示します(例：MET-1)。Cα原子の上に表示される設定になっています。</p>
<img src="ch02/./image/label/label_res.png" width="50%">
<h3 id="residues-one-letter-2"><a class="header" href="#residues-one-letter-2">residues (one letter)</a></h3>
<p>選択されたオブジェクトについて、アミノ酸と残基番号の情報を<code>（アミノ酸1文字表記）（残基番号）</code>の形で表示します(例：M1)。Cα原子の上に表示される設定になっています。</p>
<img src="ch02/./image/label/label_resone.png" width="50%">
<h3 id="chains-2"><a class="header" href="#chains-2">chains</a></h3>
<p>選択されたオブジェクトのN末端とC末端の番号を持つ残基（リガンドが存在する場合、それも含む）のそばに<code>chain &lt;chain ID&gt;</code>の形で表示します（例： chain A）。</p>
<img src="ch02/./image/label/label_chain.png" width="50%">
<h3 id="segments-2"><a class="header" href="#segments-2">segments</a></h3>
<p>すでに使用が廃止されたsegment identifierの情報を、chainsと同様に表示します。詳しくは<a href="ch02/../append01/term.html#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88segment-identifier">Appendix: 用語#セグメント</a>を参照してください。今となってはあまり使うことはないと思います。</p>
<hr>
<h3 id="atom-name-2"><a class="header" href="#atom-name-2">atom name</a></h3>
<p>原子名の名前でラベルを作成します。<code>.pdb</code>形式ファイルの場合、<code>ATOM</code>, <code>HETATM</code>レコードの13-16列目に含まれる文字列がatom nameとして定義されており、この文字列を返します。</p>
<img src="ch02/./image/label/label_atomname.png" width="50%">
<p>タンパク質アミノ酸やDNA, RNAの場合は命名規則があるため、慣れてしまえばatom nameの意味を理解しやすいと思います。13-14列目には右詰めで原子名を表します。例えば鉄原子は13-14列目を使ってFEの文字が入っていますが、炭素原子は14列目にCの文字を入れ、13列目は空白となっています。しかし、水素原子の場合は13-16列目の4文字分を最大限使って記述する場合があり、この場合は13列目から記入することになっています。</p>
<p>以下ではよく登場するatom nameの一例です。</p>
<table><thead><tr><th align="right">atom name</th><th align="right">意味</th></tr></thead><tbody>
<tr><td align="right">CA</td><td align="right">主鎖のα位の炭素</td></tr>
<tr><td align="right">N</td><td align="right">主鎖のN末端側窒素原子</td></tr>
<tr><td align="right">C</td><td align="right">主鎖のC末端側炭素原子</td></tr>
<tr><td align="right">O</td><td align="right">主鎖のC末端側酸素原子</td></tr>
<tr><td align="right">CB</td><td align="right">側鎖のβ位の炭素</td></tr>
<tr><td align="right">CG</td><td align="right">側鎖のγ位の炭素</td></tr>
<tr><td align="right">CD</td><td align="right">側鎖のδ位の炭素</td></tr>
<tr><td align="right">CE</td><td align="right">側鎖のε位の炭素</td></tr>
<tr><td align="right">CZ</td><td align="right">側鎖のζ位の炭素（チロシンなど）</td></tr>
<tr><td align="right">OH</td><td align="right">側鎖のη位の炭素（チロシンなど）</td></tr>
</tbody></table>
<p>主鎖に近い原子の個数順にβ→γ→δ→ε→ζ→ηと付ける命名規則があります。複数原子が存在するようなアミノ酸（ヒスチジン）などはND1, CD1, CE2, NE2というふうに番号をつけて区別します。</p>
<h3 id="element-symbol-2"><a class="header" href="#element-symbol-2">element symbol</a></h3>
<p>原子名を表記します。</p>
<img src="ch02/./image/label/label_esymbol.png" width="50%">
<h3 id="residue-name-2"><a class="header" href="#residue-name-2">residue name</a></h3>
<p>3文字表記の残基名を表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの18-20列目の文字列を返します。存在しない場合は空白になります（以下同様）。</p>
<img src="ch02/./image/label/label_resn.png" width="50%">
<h3 id="one-letter-code-2"><a class="header" href="#one-letter-code-2">one letter code</a></h3>
<p>1文字表記の残基名を表記します。</p>
<img src="ch02/./image/label/label_resnone.png" width="50%">
<h3 id="residue-identifier-2"><a class="header" href="#residue-identifier-2">residue identifier</a></h3>
<p>残基のresidue IDを表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの23-26列目の文字列を返します。</p>
<img src="ch02/./image/label/label_resi.png" width="50%">
<h3 id="chain-identifier-2"><a class="header" href="#chain-identifier-2">chain identifier</a></h3>
<p>残基のChain IDを表記します。<code>.pdb</code>ファイル形式における<code>ATOM</code>, <code>HETATM</code>レコードの22列目の文字列を返します。</p>
<img src="ch02/./image/label/label_chainid.png" width="50%">
<h3 id="segment-identifier-2"><a class="header" href="#segment-identifier-2">segment identifier</a></h3>
<p>残基のSegment IDを表記します。詳しくは<a href="ch02/../append01/term.html#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88segment-identifier">Appendix: 用語#セグメント</a>を参照してください。</p>
<hr>
<h3 id="b-factor-2"><a class="header" href="#b-factor-2">b-factor</a></h3>
<p>各原子の温度因子（b-factor; temperature facotr）を表記します。<code>.pdb</code>ファイル形式における61-66列目の文字列を返します。</p>
<img src="ch02/./image/label/label_bfactor.png" width="50%">
<h3 id="occupancy-2"><a class="header" href="#occupancy-2">occupancy</a></h3>
<p>各原子の重み因子を表記します。<code>.pdb</code>ファイル形式における55-60列目の文字列を返します。結晶中では基本的に構造は繰り返しになるため、どの場所を見ても同じ座標がループしている事が多く、この値は<code>1.00</code>であることが多いのですが、時々その繰り返し構造単位の中に、1より大きなn通りの配座を持っていることがあります。このとき、ここには0~1の小数値が入ります。例としては PDB: 1A6MのGLN-8が<code>0.57</code>, <code>0.43</code>の値を持つ2通りの配座を持ち、同様にTYR-151も<code>0.50</code>, <code>0.50</code>で2通りの配座を持っています。この場合、PyMOLの表示上でも2通りの残基配座が見えます。画像はPDB: 1A6MのGLN-8の例を示しています。</p>
<img src="ch02/./image/label/label_occupancy.png" width="50%">
<h3 id="vdw-radius-2"><a class="header" href="#vdw-radius-2">vdw radius</a></h3>
<p>各原子のファンデルワールス半径の値（Å）を表記します。基本的には原子の種類によって固定の値です。</p>
<img src="ch02/./image/label/label_vdw.png" width="50%">
<hr>
<h3 id="other-properties-2"><a class="header" href="#other-properties-2">Other properties</a></h3>
<h4 id="formal-charge-2"><a class="header" href="#formal-charge-2">formal charge</a></h4>
<p>各残基についてシステムで定義されている電荷を表記します。例としてLys, Arg残基の場合は<code>+1</code>を、Glu, Asp残基の場合には<code>-1</code>を表示します。</p>
<img src="ch02/./image/label/label_fchrg.png" width="50%">
<h4 id="partial-charge-2"><a class="header" href="#partial-charge-2">partial charge</a></h4>
<p>各原子について計算された部分電荷(partial charge)を表記します。これは通常の<code>pdb</code>, <code>mmCIF</code>といった構造ファイルには含まれていないため、<code>0.00</code>と表示されてしまいますが、<code>pqr</code>や<code>mol2</code>ファイル形式をロードしたときに真価を発揮します。</p>
<p>タンパク質構造の場合は構造ファイルをいったんロードした後、<a href="ch02/../ch04/apbs.html">APBSプラグインを使った表面電荷表示</a>の手順に従って処理を進めます。このときにオブジェクトパネルに<code>run01</code>-&gt;<code>prepared01</code>というオブジェクトが生成されるので、<code>prepared01</code>オブジェクトのラベル設定でpartial chargeを選択すると図のように部分電荷が表示されるようになります。</p>
<img src="ch02/./image/label/label_partchg.png" width="90%">
<p>より正確に言えば、これはPDB2PQRというソフトウェアによって分子動力学シミュレーションソフトウェアAMBERが配布している力場AmberFFに基づいて指定されており、各アミノ酸の原子ごとに固有の値を指定してくれます。</p>
<p>実態としてはPQRファイルの記述様式にのっとり、x, y, z座標の次にくるchargeの値を表記しています。</p>
<blockquote>
<p>参考：<a href="https://www.mdanalysis.org/docs/documentation_pages/coordinates/PQR.html">6.15. PQR file format</a></p>
</blockquote>
<p>mol2形式の場合でも対応しています。</p>
<img src="ch02/./image/label/label_partchgmol2.png" width="50%">
<p>GaussianやGAMESSなどの量子化学計算ソフトウェアで計算した部分電荷を図にして見てみたいときに特に有効です。</p>
<h4 id="elec-radius-2"><a class="header" href="#elec-radius-2">elec. radius</a></h4>
<p>partial chargeのときと同様に、PQRファイルのオブジェクトの場合に効果を発揮します。PQRファイル内のx, y, z座標, chargeの次にくるradiusの値を表記しています。vdw radiusとは異なります。</p>
<img src="ch02/./image/label/label_eradius.png" width="50%">
<h4 id="text-type-numeric-type-2"><a class="header" href="#text-type-numeric-type-2">text type, numeric type</a></h4>
<p>PyMOL 2.0以降は廃止されているらしく、使われていないようです（詳細不明）</p>
<h4 id="stereochemistry-2"><a class="header" href="#stereochemistry-2">stereochemistry</a></h4>
<p>PyMOL 2.2から実装されました。schrodingerのソフトまたはrdkitモジュールのインストールが求められるようです。不斉炭素原子の部分にラベルを置いてくれる機能？</p>
<hr>
<h3 id="atom-identifiers-2"><a class="header" href="#atom-identifiers-2">atom identifiers</a></h3>
<h4 id="rank-2"><a class="header" href="#rank-2">rank</a></h4>
<p>rankを表記します。rankとは構造ファイルの上から順に<code>ATOM</code>, <code>HETATM</code>レコードを取得したときの通し番号のことであり、これのみ<strong>0始まり</strong>となっています。</p>
<img src="ch02/./image/label/label_rank.png" width="50%">
<blockquote>
<p>“rank” selects atoms based on their position in the source file, starting with zero as the first number.</p>
</blockquote>
<h4 id="id-2"><a class="header" href="#id-2">ID</a></h4>
<p>IDを表記します。IDとは構造ファイルから忠実に取得したATOM IDのことであり、<code>pdb</code>ファイルフォーマットで言えば7-11列目に存在する番号のことを指します。この値は整数値でなければなりません。</p>
<img src="ch02/./image/label/label_id.png" width="50%">
<blockquote>
<p>“id” selects atoms based on the atom identifier number from the source file, which must be a integer.</p>
</blockquote>
<h4 id="index-2"><a class="header" href="#index-2">index</a></h4>
<p>Indexを表記します。indexはrankと似ていますが、順に表示するのとは異なり、PyMOL内部で番号を順に振り直したのがindexです。例えばある1つのアミノ酸残基があったとき、その残基の中で登場する原子の順番をどのように入れ替えても、index表記ではN→CA→C→O→CB→……の順に若い数字を付けていきます。</p>
<img src="ch02/./image/label/label_index.png" width="50%">
<blockquote>
<p>“index” selects atoms based on their internal PyMOL object atom indices starting with one as the first number.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="色の設定color-2"><a class="header" href="#色の設定color-2">色の設定(Color)</a></h2>
<img src="ch02/./image/color/colormenu.png" width="25%">
<p>色の設定の仕方は自由です、センスの見せ所です……とは言うものの、<strong>実はタンパク質の構造を毎日見るであろう構造生物学専門の研究者さんにとっては、ある暗黙の了解があります</strong>。それらを踏まえた上で、PyMOLのカラーリング機能を紹介していきましょう。</p>
<h3 id="色設定の暗黙の了解-2"><a class="header" href="#色設定の暗黙の了解-2">色設定の暗黙の了解</a></h3>
<p>以下のルールだけは遵守しましょう。</p>
<ul>
<li>常に<strong>酸素原子は<span style="color:red;">赤</span>色, 窒素原子は<span style="color:blue;">青</span>色, 硫黄原子は<span style="color:#E7C640;">オリーブ（olive）</span>色</strong>で表示する。</li>
<li>存在する場合、水素原子は白色で表示。</li>
<li>よって炭素原子は、<strong>上記以外の色</strong>を使う。</li>
</ul>
<p>メチオニン残基の表示の例（炭素原子はgreen）</p>
<img src="ch02/./image/color/color1.png" width="50%">
<p>PyMOLには、酸素・窒素・窒素・水素原子を上記の色ルールで描画してくれるメニュー（&quot;<strong>by element</strong>&quot;）が存在しますので、これを使うことを強く推奨します。</p>
<p>正確には、PyMOLでは酸素原子はカラーコードで#FF7C7C (255, 76, 76) [1.0, 0.3, 0.3], 窒素原子は#3333FF (51,51,255) [0.2, 0.2, 1.0], 硫黄原子は#E7C640 (231, 198, 64) [0.9, 0.775, 0.25]がデフォルトで割り当てられているため、用意されているカラーパレットを使う限りにはこれらの色と完全にかぶることはないのですが、それでもこれらに近い色を使うと紛らわしいので、使用は控えましょう。また、以下で見るように、用意されているカラーパレットの中にはすべての原子を同一で塗るものもあるので、どうしてもそれらの色を使いたい場合は、そのカラーパレットを選択した後に&quot;<strong>by element</strong>&quot;メニューの一番上のカラーリング（通称&quot;color by hetetoatom&quot;）を選択してあげましょう。</p>
<h3 id="by-element-2"><a class="header" href="#by-element-2">by element</a></h3>
<p>メニューを開いていただけると一目瞭然、C（炭素）の色だけが変わっており、H, N, O, S, 他にも様々な原子について、「暗黙の了解」の色で固定されています。反対に炭素原子の色を自由に選べることで、多量体タンパク質や大きな複合体に対しても自由に色を塗り分けられることができます。<strong>基本的には、このカラーパレットから選びましょう</strong>。</p>
<p>見落としがちですが、下の方にある<strong>set 2</strong>〜<strong>set 6</strong>にも、様々な色が用意されています。set 6のみ水素原子の色が白色でないものが用意されていますが、あまり使うことはないでしょう。</p>
<p>一番上のメニューではCが表示されておらず、HNOSと書かれていますが、これは<strong>炭素以外の原子の色を既定色に変更する</strong>というとても便利なカラーパレットです（&quot;color by heteroatom&quot;）。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code>util.cnc 1alk # color by heteroatom
</code></pre>
<h3 id="by-chain-2"><a class="header" href="#by-chain-2">by chain</a></h3>
<h4 id="by-chain-elem-c--ca--無印-2"><a class="header" href="#by-chain-elem-c--ca--無印-2">by chain (elem C | */CA, | 無印)</a></h4>
<p>`1つの生体分子オブジェクト内に複数のchainが存在している場合、各chainごとに異なる色で塗り分けてくれます。</p>
<img src="ch02/./image/color/color2.png" width="50%">
<p><code>elem C</code>の場合、チェイン内の全炭素原子に対して色の変更を行い、他の種類の原子には色の変更を行いません。<code>*/CA</code> の場合、主鎖のCα原子のみ色の変更を行い、残りの原子には色の変更を行いません。<code>無印</code>は全原子に対して色の変更を行います。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code>util.color_chains(&quot;(1alk and elem C)&quot;) # elem C
util.color_chains(&quot;(1alk and name CA)&quot;) # */CA
util.color_chains(&quot;(1alk)&quot;) # 無印
</code></pre>
<h4 id="chainbows-2"><a class="header" href="#chainbows-2">chainbows</a></h4>
<p><strong>各chainについて</strong>、N末端（5'末端）からC末端（3'末端）にかけて青色から赤色のきれいなグラデーションができるように色を塗り分けてくれます。タンパク質の場合、この配色ならば、<strong>表示された色からアミノ酸配列の位置と構造上での位置の対応関係を把握しやすい</strong>ため、この配色になっている論文を見たことがある方も多いでしょう。</p>
<img src="ch02/./image/color/color3.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># どちらでもOK
util.chainbow 1alk
util.chainbow(&quot;(1alk)&quot;)
</code></pre>
<h4 id="by-segi-elem-c--無印-2"><a class="header" href="#by-segi-elem-c--無印-2">by segi (elem C | 無印)</a></h4>
<p>segment identifierによる色分けを行います。</p>
<img src="ch02/./image/color/color4.png" width="50%">
<p>あまり詳しく調べていないのですが、segment identifierは現在仕様が廃止されつつあるのと、カラーリングが赤・青なので、あまり使うことはないでしょう。</p>
<h3 id="by-ss-by-secondary-structure-2"><a class="header" href="#by-ss-by-secondary-structure-2">by ss (By Secondary Structure)</a></h3>
<p>タンパク質の二次構造（ヘリックス・シート・ループ）構造を基準に色分けしてくれます。自由に選びましょう。</p>
<img src="ch02/./image/color/colorss.png" width="50%">
<p>コマンドで行う場合で、ヘリックスを赤、シートを黄、それ以外を緑に塗りたいときは、以下のように打てばOKです。</p>
<pre><code>color red, ss h
color yellow, ss s
color green, ss l+''
</code></pre>
<p>または、</p>
<pre><code>util.cbss(&quot;1alk&quot;,&quot;red&quot;,&quot;yellow&quot;,&quot;green&quot;) # オブジェクト1alkについて行いたい場合
</code></pre>
<h3 id="by-rep-by-representation-2"><a class="header" href="#by-rep-by-representation-2">by rep (By Representation)</a></h3>
<p>表示形式(representation)ごとに色分けを表示させることができます。これ以外の他のメニューからの色変更は、全表示形式が一括で色変更されてしまうので、うまく使い分けましょう。例えば、by chainで緑・青に色分けをした後に[show]→[surface]としてsurface表示をした状態ですと、</p>
<img src="ch02/./image/color/color5.png" width="50%">
<p>という表示になりますが（コマンドで<code>set transparency, 0.5</code>とし、Surface表示の透明度を変更しています。）、続いて[by rep]→[surface]→[grays]→[white]とすると</p>
<img src="ch02/./image/color/color6.png" width="50%">
<p>このようにSurface表示だけ白くすることができます。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># どちらでもOK
set surface_color, white, 1alk
cmd.set(&quot;surface_color&quot;, &quot;white&quot;, '1alk', quiet=0)
</code></pre>
<p><code>quiet=1</code> とすると処理終了時にメッセージがログ欄に表示されなくなります（プログラミング用）。<code>surface_color</code> の部分を<code>line</code>や<code>cartoon</code>などに変更すればその表示形式に関わる色のみ変更できます。</p>
<h3 id="spectrum-2"><a class="header" href="#spectrum-2">spectrum</a></h3>
<h4 id="rainbow-elem-c--ca--無印-2"><a class="header" href="#rainbow-elem-c--ca--無印-2">rainbow (elem C | */CA, | 無印)</a></h4>
<p>オブジェクト全体を虹色表示してくれます。[by chain]の[chainbow]と違い、chainごとに虹色グラデーションをつけてくれるわけではないことに注意してください。<code>elem C</code>, <code>*/CA</code>, <code>無印</code>の意味は上と同様です。</p>
<img src="ch02/./image/color/color7.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># elemCの場合。どちらでもOK。
spectrum count, selection=1alk and elem C
cmd.spectrum(&quot;count&quot;,selection=&quot;(1alk)&amp;elem C&quot;)
# */CAの場合
spectrum count, selection=1alk&amp;*/CA
cmd.spectrum(&quot;count&quot;,selection=&quot;(1alk)&amp;*/CA&quot;)
# 無印
spectrum count, selection=1alk, byres=1
cmd.spectrum(&quot;count&quot;,selection=&quot;1alk&quot;,byres=1)
</code></pre>
<h4 id="b-factors-無印--ca-2"><a class="header" href="#b-factors-無印--ca-2">b-factors （無印 | */CA）</a></h4>
<p>結晶構造解析法で構造決定された構造ファイルの場合、<strong>b-factor（温度因子）</strong> という値が各原子に対して割り当てられています。簡単に言えば、この値は <strong>その原子のゆらぎやすさ</strong> を表しており、概して分子内部に存在している原子ほど値が小さく、外側に存在する原子ほど大きくなっています。この色表示ではb-factorの値が小さいほど青色に、大きいほど赤色になるよう表示されます。</p>
<img src="ch02/./image/color/color8.png" width="50%">
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># 無印の場合。どちらでもOK。
spectrum b, selection=1alk, quiet=0
cmd.spectrum(&quot;b&quot;, selection=(&quot;1alk&quot;), quiet=0)
# */CAの場合。どちらでもOK。
spectrum b, selection=1alk&amp;*/CA, quiet=0
cmd.spectrum(&quot;b&quot;, selection=&quot;((1alk)&amp;*/CA)&quot;, quiet=0)
</code></pre>
<p><a href="ch02/../ch05/preset.html#b-factor-putty">表示形式のプリセットの中には、b-factorごとに色と太さを変えてくれる</a>オプションもあります。</p>
<h4 id="area-molecular--solvent-2"><a class="header" href="#area-molecular--solvent-2">area (molecular | solvent)</a></h4>
<p>残基あたりのsurface area（表面積）を計算し、それに応じた値でグラデーション色付けをしてくれます。</p>
<img src="ch02/./image/color/color9.png" width="50%">
<p>プログラムの仕様上は<code>get_area</code>コマンドを走らせて、その値に応じた色付けを行っているようです。しかし、solventの方も含めて、かなり雑な計算なのでまったく厳密ではないようです（参考：<a href="https://pymolwiki.org/index.php/Get_Area">https://pymolwiki.org/index.php/Get_Area</a>）。Solvent accessbile surface areaを計算したい場合は、別の厳密なソフトウェアで計算した値を使うことを推奨します。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について行う場合)</p>
<pre><code># molecularの場合（デフォルト）。
util.color_by_area(&quot;1alk&quot;,&quot;molecular&quot;)
# solventの場合
util.color_by_area(&quot;1alk&quot;,&quot;solvent&quot;)
</code></pre>
<h3 id="auto-elem-c--all--by-obj-elem-c--by-obj-2"><a class="header" href="#auto-elem-c--all--by-obj-elem-c--by-obj-2">auto (elem C | all | by obj (elem C) | by obj)</a></h3>
<p>自動で色付けをしてくれます。<strong>複数の生体分子オブジェクトがPyMOL上で開かれている場合に有効です</strong>。上2つは、押すたびに色が入れ替わっていきます。緑→シアン→黄→紫……の順に入れ替わります。</p>
<img src="ch02/./image/color/color10.png" width="80%">
<p>下2つの<code>by obj</code> がついているものはロードされている生体分子オブジェクトの上から順に色を緑→シアン→黄→紫……の順で塗り分けてくれます。特に、<strong><code>all</code> を選択して<code>by obj</code> を押せば一発で見慣れた色分けになってくれる</strong>ので便利です。</p>
<img src="ch02/./image/color/color11.png" width="80%">
<p>コマンド入力はこちら(全オブジェクトについて行う場合)</p>
<pre><code>cmd.color(&quot;auto&quot;,&quot;(all) and elem C&quot;)
cmd.color(&quot;auto&quot;,&quot;all&quot;)
util.color_objs(&quot;(all and elem C)&quot;,_self=cmd)
util.color_objs(&quot;(all)&quot;,_self=cmd)
</code></pre>
<h3 id="auto以下に存在する色分けメニューについて-2"><a class="header" href="#auto以下に存在する色分けメニューについて-2">auto以下に存在する色分けメニューについて</a></h3>
<p>autoメニューの下には様々なカラーパレットがあります。自由に選択して好きな色を選びましょう。<strong>全表示形式(line, stick, surface...)について同一の色を適用します</strong>。</p>
<p>コマンド入力はこちら(オブジェクト<code>1alk</code>について赤色で塗る場合)</p>
<pre><code># PyMOL 2.3時代まで
util.color_deep(&quot;red&quot;, '1alk', 0)
# PyMOL 2.4以降（予定）
color_deep red, 1alk
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="マウス操作-1"><a class="header" href="#マウス操作-1">マウス操作</a></h2>
<p>PyMOLを含む分子描画ソフトウェアの最も重要なユーザーインターフェースが<strong>マウス操作</strong>です。何はともあれ、PyMOLを使うのであればこれを先に読んでマスターしておきましょう。</p>
<p>PyMOLのマウス操作は、外部デバイスとしてのホイール付きマウスを前提に設計されており、左クリックボタン、右クリックボタンとホイールクリックボタンの<strong>3ボタン</strong>をすべて使うことがデフォルト設定となっています。しかし、1人1台のノートパソコンを持つことも珍しくなった現在では外部のマウスを接続して使わずに、備え付けのタッチパッドを使って操作することが多くなりました。タッチパッドはPyMOLの求める3ボタン式になっていないことが多く、ホイールボタンが存在していないためPyMOLのユーザーは不便に感じることがあると思います。こうした状況に対応するべく、PyMOLには実は<strong>2ボタンモード</strong>と<strong>1ボタンモード</strong>が用意されています。これらのモードの説明を交えつつ、PyMOLのマウス操作について詳しく述べていきます。</p>
<h3 id="操作モード-1"><a class="header" href="#操作モード-1">操作モード</a></h3>
<p>PyMOLには3ボタンモード、2ボタンモード、1ボタンモードが用意されています。これらのモードは下記のようにさらに細かいモードに分かれます。</p>
<ul>
<li>3ボタンモード
<ul>
<li><strong>3 Button Viewing Mode</strong>（初期設定）</li>
<li>3 Button Editing Mode</li>
<li>3 Button Motions Mode</li>
<li>3 Button Lights Mode</li>
<li>3 Button All Mode</li>
</ul>
</li>
<li>2ボタンモード
<ul>
<li>2 Button Viewing Mode</li>
<li>2 Button Editing Mode</li>
</ul>
</li>
<li>1ボタンモード
<ul>
<li>1 Button Viewing Mode</li>
</ul>
</li>
</ul>
<p>3ボタンモードはホイールボタン付きマウスを利用している場合に最も効果を発揮します。2ボタンモードはタッチパッドのみの環境で、Macbookなどを含むノートパソコンではこの設定にしておくことを推奨します。ここで、それぞれのボタンモードの中にViewing, Editingモードなどが存在していることも覚えておきましょう。これらのモード間ではクリック時の操作が異なります。基本的に、表示した分子を観察する場合はViewingモードを、分子の座標に変更を加える場合にはEditingモードを利用します。</p>
<p>各モードがどのようなマウス操作に対応しているかを理解する前に、まずはPyMOL画面の右下のこの部分に着目します。</p>
<img src="ch02/./image/mouse/1.png">
<p>この赤い四角の部分の一番上には<strong>Mouse Mode 3-Button Viewing</strong>と書かれています。これは<strong>3 Button Viewing Mode</strong>と同じ意味です。ここで、赤い四角の範囲のどこかをクリックすると</p>
<img src="ch02/./image/mouse/2.png">
<p>Mouse Modeが<strong>3-Button Editing</strong>という表示になりました。これは<strong>3 Button Editing Mode</strong>に切り替わったことを表しています。また、青い四角の部分も、<strong>Picking Atoms (and Joints)</strong> に変化しました。最初のうちは、この<strong>Viewing Mode</strong>と<strong>Editing Mode</strong>の2つについて理解しておけば十分だと思います。Lights ModeとAll Modeについては慣れてきたら試してみましょう。2つのモードは上記の赤い四角の部分を押すことで入れ替えることができます。</p>
<p>この画面についてもう少し詳しく見ていきます。ここにはクリックするマウスボタン(L, M, R, Wheel)と補助キーとの組み合わせ(Shift, Ctrl, Ctrl+Shift...)を組み合わせることで、様々なマウス操作が行えることが英語で書かれています(macOSの場合、CtrlはCommand ⌘ キーです)。最上段は対応するキーを押しながらマウスを動かす操作を表しています。例えば、3-Button Viewing Modeにおいては左クリックを押しながらマウスを動かすことで回転操作(Rota)、ミドルクリック（ホイール）を押しながらマウスを動かすことで並進操作(Move)が行えます。ここの表記は簡単なものですが、もし忘れてしまってもここに着目すれば、操作を思い出すことができるでしょう。</p>
<h3 id="各モードにおける操作一覧-1"><a class="header" href="#各モードにおける操作一覧-1">各モードにおける操作一覧</a></h3>
<p>各操作の詳細は次項で示します。macOSではCtrlキーはCommandキー(⌘キー)になります。</p>
<p><strong>3 Button Viewing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">並進(Move)</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">スラビング(Slab)</td></tr>
<tr><td align="right">shiftキー</td><td align="right">選択範囲に追加(+Box)</td><td align="right">選択範囲から除去(-Box)</td><td align="right">クリッピング(Clip)</td><td align="right">スラブの移動(MovS)</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">並進(Move)</td><td align="right">原子ピッキング(PkAt)</td><td align="right">1原子ピッキング(Pk1)</td><td align="right">スラブに対する視点の移動(MvSZ)</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">選択(sele)</td><td align="right">Origin指定(Orig)</td><td align="right">クリッピング(Clip)</td><td align="right">ズームイン・アウト(MovZ)</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">選択範囲追加・除去(+/-)</td><td align="right">センタリング(Cent)</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">メニュー表示(Menu)</td><td align="right">-</td><td align="right">原子ピッキング(PkAt)</td><td align="right"> </td></tr>
</tbody></table>
<p><strong>3 Button Editing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">並進(Move)</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">スラビング(Slab)</td></tr>
<tr><td align="right">shiftキー</td><td align="right">オブジェクトの回転(RotO)</td><td align="right">XY軸方向への移動(MovO)</td><td align="right">Z軸方向への移動(MvOZ)</td><td align="right">スラブの移動(MovS)</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">原子の移動(MovA)</td><td align="right">選択範囲追加・除去(+/-)</td><td align="right">二面角をピッキング(PkTB)</td><td align="right">スラブに対する視点の移動(MvSZ)</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">Z軸方向への移動(MvAZ)</td><td align="right">Origin指定(Orig)</td><td align="right">クリッピング(Clip)</td><td align="right">ズームイン・アウト(MovZ)</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">原子ピッキング(PkAt)</td><td align="right">センタリング(Cent)</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">原子の移動(MovA)</td><td align="right">ドラッグモード(DrgM)</td><td align="right">二面角をピッキング(PkTB)</td><td align="right"> </td></tr>
</tbody></table>
<p><strong>2 Button Viewing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">--</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">--</td></tr>
<tr><td align="right">shiftキー</td><td align="right">1原子ピッキング(Pk1)</td><td align="right">--</td><td align="right">クリッピング(Clip)</td><td align="right">--</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">並進(Move)</td><td align="right">--</td><td align="right">原子ピッキング(PkAt)</td><td align="right">--</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">選択(sele)</td><td align="right">--</td><td align="right">センタリング(Cent)</td><td align="right">--</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">原子ピッキング(PkAt)</td><td align="right">--</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">メニュー表示(Menu)</td><td align="right">--</td><td align="right">センタリング(Cent)</td><td align="right"> </td></tr>
</tbody></table>
<h3 id="操作の詳細-1"><a class="header" href="#操作の詳細-1">操作の詳細</a></h3>
<h4 id="回転-rota-1"><a class="header" href="#回転-rota-1">回転 (Rota)</a></h4>
<p><strong>マウスの左ボタンを押しながらマウスを動かす（ドラッグ）</strong> すると、表示されている分子を回転させることができます。</p>
<video width="100%" height="100%" controls autoplay>
<source src="./image/mouse/rotate.mp4" type="video/mp4">
</video>
<h4 id="並進-move-1"><a class="header" href="#並進-move-1">並進 (Move)</a></h4>
<p><strong>マウスのホイールボタンを押しながらドラッグ</strong> すると、表示されている分子を視点に対して平行に移動させることができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/move.mp4" type="video/mp4">
</video>
<h4 id="ズームインアウト-movz-1"><a class="header" href="#ズームインアウト-movz-1">ズームイン・アウト (MovZ)</a></h4>
<p><strong>マウスの右ボタンを押しながらマウスを前後にドラッグ、またはCtrlとShiftキーを押しながらマウスのホイールを上下</strong> させると、分子構造を拡大・縮小することができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movz.mp4" type="video/mp4">
</video>
<h4 id="選択---1"><a class="header" href="#選択---1">選択 (+/-)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でマウスの左ボタンを押す</strong> と、四角のマークが付きます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/select.mp4" type="video/mp4">
</video>
<p>この四角マークは、現在選択されている原子の範囲を示しています。この左クリックによる選択はクリックするたびに選択範囲に追加され、もう一度押すと選択範囲から外されます。</p>
<h4 id="選択範囲に追加除去-box-box-1"><a class="header" href="#選択範囲に追加除去-box-box-1">選択範囲に追加/除去 (+Box/-Box)</a></h4>
<p>選択範囲の追加または除去を行います。<strong>+Box(Shiftを押しながらマウスの左クリック＆ドラッグ)</strong> では画面上に黒い四角が現れ、ボタンを離すと、その四角で囲まれた部分が選択範囲に追加されます。反対に、<strong>-Box(Shiftを押しながらマウスのホイールクリック＆ドラッグ)</strong> では四角で囲んだ範囲を選択範囲から除去することができます。同様の操作を繰り返すことも可能です。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/plusbox.mp4" type="video/mp4">
</video>
<h4 id="センタリング-cent-1"><a class="header" href="#センタリング-cent-1">センタリング (Cent)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でマウスのホイールボタンを押す</strong> と、その原子が画面中央に来るように視点が移動します。また、回転操作の中心もその点に移動します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/center.mp4" type="video/mp4">
</video>
<h4 id="origin指定-orig-1"><a class="header" href="#origin指定-orig-1">Origin指定 (Orig)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でCtrlとShiftを押しながらマウスのホイールボタンを押す</strong> と、その原子を回転中心の原点(origin)に指定することができます。上記センタリングのときと異なり、視点は移動しません。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/origin.mp4" type="video/mp4">
</video>
<h4 id="メニュー表示-menu-1"><a class="header" href="#メニュー表示-menu-1">メニュー表示 (Menu)</a></h4>
<p><strong>マウスの左ボタンをダブルクリック</strong> または <strong>右ボタンをクリック</strong> で、メニューを開きます。メニュー内容はクリックした位置によって内容が変化します。</p>
<p>何もない箇所でクリックすると[Main Pop-Up]メニューが表示されます。<br><img src="ch02/./image/mouse/select_menumain.png" width="20%"></p>
<p>オブジェクトの上でクリックすると、クリックした場所に存在する原子についての設定変更を行うメニューが表示されます。<br><img src="ch02/./image/mouse/select_menuatom.png" width="20%"></p>
<h4 id="原子ピッキングpkatpk1-1"><a class="header" href="#原子ピッキングpkatpk1-1">原子ピッキング（PkAt/Pk1）</a></h4>
<p>オブジェクト上の原子の上で<strong>Ctrlボタンを押しながらホイールクリック</strong>、または<strong>マウス右ボタンのダブルクリック</strong>を行うと、その原子をピッキングした状態になります(<strong>PkAt</strong>)。</p>
<p>このピッキング状態は先述の選択範囲とは異なる選択形式で、図のような球体のマーカーが付きます。このピッキングは画面上に同時に4原子まで選択することができ、各ピッキングマーカーは図のように二重、三重、四重の球体マーカーで示されます。<br><img src="ch02/./image/mouse/select_pk1.png" width="40%"><img src="ch02/./image/mouse/select_pk2.png" width="40%"></p>
<p><strong>Ctrlボタンを押しながら右クリック (Pk1)</strong> の場合では、上の操作と異なり、1つめの原子ピッキングのみを行います。ピッキングされた原子が2つ、3つ、4つになると、自動でそのピッキングされた原子についての<strong>距離(distance)</strong>、<strong>角度(angle)</strong>、<strong>二面角(dihedral)</strong> を表示してくれます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/pkatom.mp4" type="video/mp4">
</video>
<h4 id="クリッピングclip-1"><a class="header" href="#クリッピングclip-1">クリッピング（Clip）</a></h4>
<p>Viewing Modeで<strong>Shiftとマウスの右ボタン（またはCtrl+Shift+マウス右ボタン）を押しながらマウスを上下左右に動かす</strong> と、分子の内部を覗けたり霧をかけたりすることができます。分子内部の一部の領域を強調した画像を取りたいときに作ります。</p>
<p>この機能は2枚の<strong>クリッピング平面（Clipping plane）</strong> によって調節しています。マウスの上下の動きは前面のクリッピング平面(front clipping plane)の位置を、左右の動きは背面のクリッピング平面(rear clipping plane)の位置を調節できます<br>図解<br><img src="ch02/./image/mouse/select_clip1.png" width="80%"><br><strong>画面上にはこの2枚のClipping Planeの間に存在する領域だけが表示されます</strong>。</p>
<p>マウスを画面下に移動させるとfront clipping planeは視点から見て奥へ移動し、分子の内部が見えるようになります。反対に、マウスを上へ移動させると、front clipping planeは手前に移動します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/frontclip.mp4" type="video/mp4">
</video>
<p>マウスを左に移動させるとrear clipping planeが視点から見て奥へ移動します。反対に手前に移動させると、rear clipping planeが手前に移動し、分子の奥側が霧がかかって徐々に見えなくなります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/rearclip.mp4" type="video/mp4">
</video>
<p>霧は画面上部のメニューの[Display]→[Depth Cue(Fogging)]のチェックでON/OFFを選択できます（デフォルトはONです）。<br><img src="ch02/./image/mouse/select_clip5.png" width="100%"></p>
<h4 id="スラビングslab-1"><a class="header" href="#スラビングslab-1">スラビング（Slab）</a></h4>
<p>スラブとは英語で厚板、平板という名詞、または「平板にする」という動詞です。PyMOLにおいて<strong>スラブ（Slab、Visible Slabとも）とは、上述の2枚のクリッピング平面の間に挟まれた可視化領域のこと</strong>を指します。</p>
<p>Viewing Modeで<strong>マウスホイールを回転させる</strong> ことで、スラブの厚さを調節することができます。クリッピングとともに、分子構造の内部領域をみたい時に有用です。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/slab.mp4" type="video/mp4">
</video>
<p>画面上部メニューの[Display]→[Clip]には[8 Angstroam Slab]を始めとして30 Åまでの厚さのスラブを選ぶことができます。[Nothing]を選択した場合には、全原子が含まれるように自動的にスラブの厚みを調節します。</p>
<h4 id="スラブの移動movs-1"><a class="header" href="#スラブの移動movs-1">スラブの移動（MovS）</a></h4>
<p>Viewing Modeで<strong>Shiftを押しながらマウスホイールを回転させる</strong> と、スラブ領域を、その厚みを保ったまま手前・奥に移動させることができます。効果を実感したい場合は、例として[8 Angstroam Slab]設定をした直後に使ってみるとわかりやすいでしょう。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movs.mp4" type="video/mp4">
</video>
<h4 id="スラブに対する視点の移動mvsz-1"><a class="header" href="#スラブに対する視点の移動mvsz-1">スラブに対する視点の移動（MvSZ）</a></h4>
<p>Viewing Modeで<strong>Ctrlを押しながらマウスホイールを回転させる</strong> と、スラブ平面に対して視点を移動させることができます。視点がスラブ内部に入ることもできます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mvsz.mp4" type="video/mp4">
</video>
<h3 id="editing-mode専用コマンド-1"><a class="header" href="#editing-mode専用コマンド-1">Editing Mode専用コマンド</a></h3>
<p>以下ではEditing Modeで扱う操作方法について記述します。Editing Modeは<strong>オブジェクト・原子の座標自体に変更を加える</strong>ことが多いため、このモードで操作するときは注意が必要です。<strong>もし誤って座標を動かしてしまった場合、数回であればCtrl-zでUndo（もとに戻す）ことが可能です</strong>。</p>
<h4 id="オブジェクトの回転rotoxy軸方向への移動movoz軸方向への移動mvoz-1"><a class="header" href="#オブジェクトの回転rotoxy軸方向への移動movoz軸方向への移動mvoz-1">オブジェクトの回転(RotO)・XY軸方向への移動(MovO)・Z軸方向への移動(MvOZ)</a></h4>
<p>EditingモードでShiftキーとマウスの左ボタン・ホイールボタン・右ボタンを押しながらマウスを移動させることで、オブジェクトの座標に対しそれぞれ回転・XY軸への並進・Z軸へ移動操作を行うことができます。特に、複数のオブジェクトが存在する場合に効果がわかりやすいです。以下の例では緑色と青色で別々のオブジェクトとした上で、青色オブジェクトに対して操作を適用しています。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/roto.mp4" type="video/mp4">
</video>
<h4 id="原子の移動movaz軸方向への移動mvaz-1"><a class="header" href="#原子の移動movaz軸方向への移動mvaz-1">原子の移動(MovA)・Z軸方向への移動(MvAZ)</a></h4>
<p>EditingモードでCtrlキーとマウスの左ボタンを押しながらマウスを移動させることで、マウスカーソル上に存在する原子の座標を移動させることができます。Ctrl+Shiftキーとマウスの左ボタンを押しながらだとZ軸方向への移動が行えます。下の例では、オレンジ色の原子（リン酸イオンPO4のリン原子）について操作を適用しています。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mova.mp4" type="video/mp4">
</video>
<h4 id="フラグメントの回転rotf移動movfz軸方向への移動mvfz-1"><a class="header" href="#フラグメントの回転rotf移動movfz軸方向への移動mvfz-1">フラグメントの回転(RotF)・移動(MovF)・Z軸方向への移動(MvFZ)</a></h4>
<p>Editingモードで特定の原子を左クリックすると原子がピックされた状態になります。このとき操作メニューが変化して、MovF, MvFZが現れるようになります。RotF（Shift+左クリック）とMovF（Shift+ホイールクリック）はピックされた原子と結合している原子のまとまり（<strong>フラグメント</strong>）を回転させたり、平行移動させたりすることができます。この操作は必ず選択されたフラグメントの上でShiftキーとクリック入力を行う必要があります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movf.mp4" type="video/mp4">
</video>
<p>MvFZ（Shift＋右クリックしながら上下にドラッグ）はピックされたフラグメントを手前または奥に移動させることができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mvfz.mp4" type="video/mp4">
</video>
<h4 id="二面角をピッキングpktb-1"><a class="header" href="#二面角をピッキングpktb-1">二面角をピッキング(PkTB)</a></h4>
<p>Editingモードで描画されている結合に対してCtrlキーとマウスの右ボタンを押しながら移動させることで、結合の二面角を変更することができます。</p>
<p><img src="ch02/./image/mouse/pktb1.png" width="40%">　　<img src="ch02/./image/mouse/pktb2.png" width="40%"></p>
<p>2原子を結ぶ結合線上のうち、それぞれの原子に近い位置で操作を実行することで、それぞれ回転される対象が異なることに注意します。
図において、結合線の左半分にマウスカーソルを置いた状態で操作を適用した場合はこの残基の先端のみが回転します。</p>
<p><img src="ch02/./image/mouse/pktb3.png" width="40%">　　<img src="ch02/./image/mouse/pktb4.png" width="40%"></p>
<p>しかし、結合線の右半分にカーソルを置いた状態で操作を適用すると、タンパク質の方が回転します。</p>
<p><img src="ch02/./image/mouse/pktb3.png" width="40%">　　<img src="ch02/./image/mouse/pktb5.png" width="40%"></p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/pktb.mp4" type="video/mp4">
</video>
<h4 id="分子構造をドラッグモードにするdrgm-1"><a class="header" href="#分子構造をドラッグモードにするdrgm-1">分子構造をドラッグモードにする(DrgM)</a></h4>
<p>Editingモードでホイールボタンをダブルクリックすると、オブジェクト内のひとつながりの分子構造(Molecule)について&quot;drag&quot;状態にします。このドラッグモードではこれまでのカメラ操作のような感覚で分子の座標を変更することが可能になります。</p>
<p>このドラッグモードにするとオブジェクトパネルの下側に専用のメニューが現れます。PDB: 1alkの場合で図の右側の構造についてこの操作を実行すると、Mgイオンを除いた右半分のChainだけが選択された状態になります。これは上述のひとつながりの分子構造に対してのみ適用されるからです。</p>
<img src="ch02/./image/mouse/drag1.png" width="100%">
<p>さらに、このドラッグモードではShiftキーを押しながらのマウス操作方法が<strong>RotD</strong>, <strong>MovD</strong>, <strong>MvDZ</strong>に変化します。このDはDraggedを表しており、ドラッグモードとなっている選択範囲のみに対してそれぞれ<strong>回転操作</strong>・<strong>XY軸方向への移動</strong>・<strong>Z軸方向への移動</strong>を行うことができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="操作モード-2"><a class="header" href="#操作モード-2">操作モード</a></h3>
<p>PyMOLには3ボタンモード、2ボタンモード、1ボタンモードが用意されています。これらのモードは下記のようにさらに細かいモードに分かれます。</p>
<ul>
<li>3ボタンモード
<ul>
<li><strong>3 Button Viewing Mode</strong>（初期設定）</li>
<li>3 Button Editing Mode</li>
<li>3 Button Motions Mode</li>
<li>3 Button Lights Mode</li>
<li>3 Button All Mode</li>
</ul>
</li>
<li>2ボタンモード
<ul>
<li>2 Button Viewing Mode</li>
<li>2 Button Editing Mode</li>
</ul>
</li>
<li>1ボタンモード
<ul>
<li>1 Button Viewing Mode</li>
</ul>
</li>
</ul>
<p>3ボタンモードはホイールボタン付きマウスを利用している場合に最も効果を発揮します。2ボタンモードはタッチパッドのみの環境で、Macbookなどを含むノートパソコンではこの設定にしておくことを推奨します。ここで、それぞれのボタンモードの中にViewing, Editingモードなどが存在していることも覚えておきましょう。これらのモード間ではクリック時の操作が異なります。基本的に、表示した分子を観察する場合はViewingモードを、分子の座標に変更を加える場合にはEditingモードを利用します。</p>
<p>各モードがどのようなマウス操作に対応しているかを理解する前に、まずはPyMOL画面の右下のこの部分に着目します。</p>
<img src="ch02/./image/mouse/1.png">
<p>この赤い四角の部分の一番上には<strong>Mouse Mode 3-Button Viewing</strong>と書かれています。これは<strong>3 Button Viewing Mode</strong>と同じ意味です。ここで、赤い四角の範囲のどこかをクリックすると</p>
<img src="ch02/./image/mouse/2.png">
<p>Mouse Modeが<strong>3-Button Editing</strong>という表示になりました。これは<strong>3 Button Editing Mode</strong>に切り替わったことを表しています。また、青い四角の部分も、<strong>Picking Atoms (and Joints)</strong> に変化しました。最初のうちは、この<strong>Viewing Mode</strong>と<strong>Editing Mode</strong>の2つについて理解しておけば十分だと思います。Lights ModeとAll Modeについては慣れてきたら試してみましょう。2つのモードは上記の赤い四角の部分を押すことで入れ替えることができます。</p>
<p>この画面についてもう少し詳しく見ていきます。ここにはクリックするマウスボタン(L, M, R, Wheel)と補助キーとの組み合わせ(Shift, Ctrl, Ctrl+Shift...)を組み合わせることで、様々なマウス操作が行えることが英語で書かれています(macOSの場合、CtrlはCommand ⌘ キーです)。最上段は対応するキーを押しながらマウスを動かす操作を表しています。例えば、3-Button Viewing Modeにおいては左クリックを押しながらマウスを動かすことで回転操作(Rota)、ミドルクリック（ホイール）を押しながらマウスを動かすことで並進操作(Move)が行えます。ここの表記は簡単なものですが、もし忘れてしまってもここに着目すれば、操作を思い出すことができるでしょう。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="各モードにおける操作一覧-2"><a class="header" href="#各モードにおける操作一覧-2">各モードにおける操作一覧</a></h3>
<p>各操作の詳細は次項で示します。macOSではCtrlキーはCommandキー(⌘キー)になります。</p>
<p><strong>3 Button Viewing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">並進(Move)</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">スラビング(Slab)</td></tr>
<tr><td align="right">shiftキー</td><td align="right">選択範囲に追加(+Box)</td><td align="right">選択範囲から除去(-Box)</td><td align="right">クリッピング(Clip)</td><td align="right">スラブの移動(MovS)</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">並進(Move)</td><td align="right">原子ピッキング(PkAt)</td><td align="right">1原子ピッキング(Pk1)</td><td align="right">スラブに対する視点の移動(MvSZ)</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">選択(sele)</td><td align="right">Origin指定(Orig)</td><td align="right">クリッピング(Clip)</td><td align="right">ズームイン・アウト(MovZ)</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">選択範囲追加・除去(+/-)</td><td align="right">センタリング(Cent)</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">メニュー表示(Menu)</td><td align="right">-</td><td align="right">原子ピッキング(PkAt)</td><td align="right"> </td></tr>
</tbody></table>
<p><strong>3 Button Editing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">並進(Move)</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">スラビング(Slab)</td></tr>
<tr><td align="right">shiftキー</td><td align="right">オブジェクトの回転(RotO)</td><td align="right">XY軸方向への移動(MovO)</td><td align="right">Z軸方向への移動(MvOZ)</td><td align="right">スラブの移動(MovS)</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">原子の移動(MovA)</td><td align="right">選択範囲追加・除去(+/-)</td><td align="right">二面角をピッキング(PkTB)</td><td align="right">スラブに対する視点の移動(MvSZ)</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">Z軸方向への移動(MvAZ)</td><td align="right">Origin指定(Orig)</td><td align="right">クリッピング(Clip)</td><td align="right">ズームイン・アウト(MovZ)</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">原子ピッキング(PkAt)</td><td align="right">センタリング(Cent)</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">原子の移動(MovA)</td><td align="right">ドラッグモード(DrgM)</td><td align="right">二面角をピッキング(PkTB)</td><td align="right"> </td></tr>
</tbody></table>
<p><strong>2 Button Viewing Mode</strong></p>
<table><thead><tr><th align="right"> </th><th align="right">左ボタン</th><th align="right">ホイールボタン</th><th align="right">右ボタン</th><th align="right">ホイールスクロール</th></tr></thead><tbody>
<tr><td align="right">ボタンを押しながらドラッグ</td><td align="right">回転(Rota)</td><td align="right">--</td><td align="right">ズームイン・アウト(MovZ)</td><td align="right">--</td></tr>
<tr><td align="right">shiftキー</td><td align="right">1原子ピッキング(Pk1)</td><td align="right">--</td><td align="right">クリッピング(Clip)</td><td align="right">--</td></tr>
<tr><td align="right">Ctrlキー</td><td align="right">並進(Move)</td><td align="right">--</td><td align="right">原子ピッキング(PkAt)</td><td align="right">--</td></tr>
<tr><td align="right">Ctrl+Shiftキー</td><td align="right">選択(sele)</td><td align="right">--</td><td align="right">センタリング(Cent)</td><td align="right">--</td></tr>
<tr><td align="right">シングルクリック</td><td align="right">原子ピッキング(PkAt)</td><td align="right">--</td><td align="right">メニュー表示(Menu)</td><td align="right"> </td></tr>
<tr><td align="right">ダブルクリック</td><td align="right">メニュー表示(Menu)</td><td align="right">--</td><td align="right">センタリング(Cent)</td><td align="right"> </td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="操作の詳細-2"><a class="header" href="#操作の詳細-2">操作の詳細</a></h3>
<h4 id="回転-rota-2"><a class="header" href="#回転-rota-2">回転 (Rota)</a></h4>
<p><strong>マウスの左ボタンを押しながらマウスを動かす（ドラッグ）</strong> すると、表示されている分子を回転させることができます。</p>
<video width="100%" height="100%" controls autoplay>
<source src="./image/mouse/rotate.mp4" type="video/mp4">
</video>
<h4 id="並進-move-2"><a class="header" href="#並進-move-2">並進 (Move)</a></h4>
<p><strong>マウスのホイールボタンを押しながらドラッグ</strong> すると、表示されている分子を視点に対して平行に移動させることができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/move.mp4" type="video/mp4">
</video>
<h4 id="ズームインアウト-movz-2"><a class="header" href="#ズームインアウト-movz-2">ズームイン・アウト (MovZ)</a></h4>
<p><strong>マウスの右ボタンを押しながらマウスを前後にドラッグ、またはCtrlとShiftキーを押しながらマウスのホイールを上下</strong> させると、分子構造を拡大・縮小することができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movz.mp4" type="video/mp4">
</video>
<h4 id="選択---2"><a class="header" href="#選択---2">選択 (+/-)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でマウスの左ボタンを押す</strong> と、四角のマークが付きます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/select.mp4" type="video/mp4">
</video>
<p>この四角マークは、現在選択されている原子の範囲を示しています。この左クリックによる選択はクリックするたびに選択範囲に追加され、もう一度押すと選択範囲から外されます。</p>
<h4 id="選択範囲に追加除去-box-box-2"><a class="header" href="#選択範囲に追加除去-box-box-2">選択範囲に追加/除去 (+Box/-Box)</a></h4>
<p>選択範囲の追加または除去を行います。<strong>+Box(Shiftを押しながらマウスの左クリック＆ドラッグ)</strong> では画面上に黒い四角が現れ、ボタンを離すと、その四角で囲まれた部分が選択範囲に追加されます。反対に、<strong>-Box(Shiftを押しながらマウスのホイールクリック＆ドラッグ)</strong> では四角で囲んだ範囲を選択範囲から除去することができます。同様の操作を繰り返すことも可能です。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/plusbox.mp4" type="video/mp4">
</video>
<h4 id="センタリング-cent-2"><a class="header" href="#センタリング-cent-2">センタリング (Cent)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でマウスのホイールボタンを押す</strong> と、その原子が画面中央に来るように視点が移動します。また、回転操作の中心もその点に移動します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/center.mp4" type="video/mp4">
</video>
<h4 id="origin指定-orig-2"><a class="header" href="#origin指定-orig-2">Origin指定 (Orig)</a></h4>
<p><strong>表示されているオブジェクトの原子の上でCtrlとShiftを押しながらマウスのホイールボタンを押す</strong> と、その原子を回転中心の原点(origin)に指定することができます。上記センタリングのときと異なり、視点は移動しません。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/origin.mp4" type="video/mp4">
</video>
<h4 id="メニュー表示-menu-2"><a class="header" href="#メニュー表示-menu-2">メニュー表示 (Menu)</a></h4>
<p><strong>マウスの左ボタンをダブルクリック</strong> または <strong>右ボタンをクリック</strong> で、メニューを開きます。メニュー内容はクリックした位置によって内容が変化します。</p>
<p>何もない箇所でクリックすると[Main Pop-Up]メニューが表示されます。<br><img src="ch02/./image/mouse/select_menumain.png" width="20%"></p>
<p>オブジェクトの上でクリックすると、クリックした場所に存在する原子についての設定変更を行うメニューが表示されます。<br><img src="ch02/./image/mouse/select_menuatom.png" width="20%"></p>
<h4 id="原子ピッキングpkatpk1-2"><a class="header" href="#原子ピッキングpkatpk1-2">原子ピッキング（PkAt/Pk1）</a></h4>
<p>オブジェクト上の原子の上で<strong>Ctrlボタンを押しながらホイールクリック</strong>、または<strong>マウス右ボタンのダブルクリック</strong>を行うと、その原子をピッキングした状態になります(<strong>PkAt</strong>)。</p>
<p>このピッキング状態は先述の選択範囲とは異なる選択形式で、図のような球体のマーカーが付きます。このピッキングは画面上に同時に4原子まで選択することができ、各ピッキングマーカーは図のように二重、三重、四重の球体マーカーで示されます。<br><img src="ch02/./image/mouse/select_pk1.png" width="40%"><img src="ch02/./image/mouse/select_pk2.png" width="40%"></p>
<p><strong>Ctrlボタンを押しながら右クリック (Pk1)</strong> の場合では、上の操作と異なり、1つめの原子ピッキングのみを行います。ピッキングされた原子が2つ、3つ、4つになると、自動でそのピッキングされた原子についての<strong>距離(distance)</strong>、<strong>角度(angle)</strong>、<strong>二面角(dihedral)</strong> を表示してくれます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/pkatom.mp4" type="video/mp4">
</video>
<h4 id="クリッピングclip-2"><a class="header" href="#クリッピングclip-2">クリッピング（Clip）</a></h4>
<p>Viewing Modeで<strong>Shiftとマウスの右ボタン（またはCtrl+Shift+マウス右ボタン）を押しながらマウスを上下左右に動かす</strong> と、分子の内部を覗けたり霧をかけたりすることができます。分子内部の一部の領域を強調した画像を取りたいときに作ります。</p>
<p>この機能は2枚の<strong>クリッピング平面（Clipping plane）</strong> によって調節しています。マウスの上下の動きは前面のクリッピング平面(front clipping plane)の位置を、左右の動きは背面のクリッピング平面(rear clipping plane)の位置を調節できます<br>図解<br><img src="ch02/./image/mouse/select_clip1.png" width="80%"><br><strong>画面上にはこの2枚のClipping Planeの間に存在する領域だけが表示されます</strong>。</p>
<p>マウスを画面下に移動させるとfront clipping planeは視点から見て奥へ移動し、分子の内部が見えるようになります。反対に、マウスを上へ移動させると、front clipping planeは手前に移動します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/frontclip.mp4" type="video/mp4">
</video>
<p>マウスを左に移動させるとrear clipping planeが視点から見て奥へ移動します。反対に手前に移動させると、rear clipping planeが手前に移動し、分子の奥側が霧がかかって徐々に見えなくなります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/rearclip.mp4" type="video/mp4">
</video>
<p>霧は画面上部のメニューの[Display]→[Depth Cue(Fogging)]のチェックでON/OFFを選択できます（デフォルトはONです）。<br><img src="ch02/./image/mouse/select_clip5.png" width="100%"></p>
<h4 id="スラビングslab-2"><a class="header" href="#スラビングslab-2">スラビング（Slab）</a></h4>
<p>スラブとは英語で厚板、平板という名詞、または「平板にする」という動詞です。PyMOLにおいて<strong>スラブ（Slab、Visible Slabとも）とは、上述の2枚のクリッピング平面の間に挟まれた可視化領域のこと</strong>を指します。</p>
<p>Viewing Modeで<strong>マウスホイールを回転させる</strong> ことで、スラブの厚さを調節することができます。クリッピングとともに、分子構造の内部領域をみたい時に有用です。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/slab.mp4" type="video/mp4">
</video>
<p>画面上部メニューの[Display]→[Clip]には[8 Angstroam Slab]を始めとして30 Åまでの厚さのスラブを選ぶことができます。[Nothing]を選択した場合には、全原子が含まれるように自動的にスラブの厚みを調節します。</p>
<h4 id="スラブの移動movs-2"><a class="header" href="#スラブの移動movs-2">スラブの移動（MovS）</a></h4>
<p>Viewing Modeで<strong>Shiftを押しながらマウスホイールを回転させる</strong> と、スラブ領域を、その厚みを保ったまま手前・奥に移動させることができます。効果を実感したい場合は、例として[8 Angstroam Slab]設定をした直後に使ってみるとわかりやすいでしょう。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movs.mp4" type="video/mp4">
</video>
<h4 id="スラブに対する視点の移動mvsz-2"><a class="header" href="#スラブに対する視点の移動mvsz-2">スラブに対する視点の移動（MvSZ）</a></h4>
<p>Viewing Modeで<strong>Ctrlを押しながらマウスホイールを回転させる</strong> と、スラブ平面に対して視点を移動させることができます。視点がスラブ内部に入ることもできます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mvsz.mp4" type="video/mp4">
</video>
<h3 id="editing-mode専用コマンド-2"><a class="header" href="#editing-mode専用コマンド-2">Editing Mode専用コマンド</a></h3>
<p>以下ではEditing Modeで扱う操作方法について記述します。Editing Modeは<strong>オブジェクト・原子の座標自体に変更を加える</strong>ことが多いため、このモードで操作するときは注意が必要です。<strong>もし誤って座標を動かしてしまった場合、数回であればCtrl-zでUndo（もとに戻す）ことが可能です</strong>。</p>
<h4 id="オブジェクトの回転rotoxy軸方向への移動movoz軸方向への移動mvoz-2"><a class="header" href="#オブジェクトの回転rotoxy軸方向への移動movoz軸方向への移動mvoz-2">オブジェクトの回転(RotO)・XY軸方向への移動(MovO)・Z軸方向への移動(MvOZ)</a></h4>
<p>EditingモードでShiftキーとマウスの左ボタン・ホイールボタン・右ボタンを押しながらマウスを移動させることで、オブジェクトの座標に対しそれぞれ回転・XY軸への並進・Z軸へ移動操作を行うことができます。特に、複数のオブジェクトが存在する場合に効果がわかりやすいです。以下の例では緑色と青色で別々のオブジェクトとした上で、青色オブジェクトに対して操作を適用しています。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/roto.mp4" type="video/mp4">
</video>
<h4 id="原子の移動movaz軸方向への移動mvaz-2"><a class="header" href="#原子の移動movaz軸方向への移動mvaz-2">原子の移動(MovA)・Z軸方向への移動(MvAZ)</a></h4>
<p>EditingモードでCtrlキーとマウスの左ボタンを押しながらマウスを移動させることで、マウスカーソル上に存在する原子の座標を移動させることができます。Ctrl+Shiftキーとマウスの左ボタンを押しながらだとZ軸方向への移動が行えます。下の例では、オレンジ色の原子（リン酸イオンPO4のリン原子）について操作を適用しています。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mova.mp4" type="video/mp4">
</video>
<h4 id="フラグメントの回転rotf移動movfz軸方向への移動mvfz-2"><a class="header" href="#フラグメントの回転rotf移動movfz軸方向への移動mvfz-2">フラグメントの回転(RotF)・移動(MovF)・Z軸方向への移動(MvFZ)</a></h4>
<p>Editingモードで特定の原子を左クリックすると原子がピックされた状態になります。このとき操作メニューが変化して、MovF, MvFZが現れるようになります。RotF（Shift+左クリック）とMovF（Shift+ホイールクリック）はピックされた原子と結合している原子のまとまり（<strong>フラグメント</strong>）を回転させたり、平行移動させたりすることができます。この操作は必ず選択されたフラグメントの上でShiftキーとクリック入力を行う必要があります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/movf.mp4" type="video/mp4">
</video>
<p>MvFZ（Shift＋右クリックしながら上下にドラッグ）はピックされたフラグメントを手前または奥に移動させることができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/mvfz.mp4" type="video/mp4">
</video>
<h4 id="二面角をピッキングpktb-2"><a class="header" href="#二面角をピッキングpktb-2">二面角をピッキング(PkTB)</a></h4>
<p>Editingモードで描画されている結合に対してCtrlキーとマウスの右ボタンを押しながら移動させることで、結合の二面角を変更することができます。</p>
<p><img src="ch02/./image/mouse/pktb1.png" width="40%">　　<img src="ch02/./image/mouse/pktb2.png" width="40%"></p>
<p>2原子を結ぶ結合線上のうち、それぞれの原子に近い位置で操作を実行することで、それぞれ回転される対象が異なることに注意します。
図において、結合線の左半分にマウスカーソルを置いた状態で操作を適用した場合はこの残基の先端のみが回転します。</p>
<p><img src="ch02/./image/mouse/pktb3.png" width="40%">　　<img src="ch02/./image/mouse/pktb4.png" width="40%"></p>
<p>しかし、結合線の右半分にカーソルを置いた状態で操作を適用すると、タンパク質の方が回転します。</p>
<p><img src="ch02/./image/mouse/pktb3.png" width="40%">　　<img src="ch02/./image/mouse/pktb5.png" width="40%"></p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/pktb.mp4" type="video/mp4">
</video>
<h4 id="分子構造をドラッグモードにするdrgm-2"><a class="header" href="#分子構造をドラッグモードにするdrgm-2">分子構造をドラッグモードにする(DrgM)</a></h4>
<p>Editingモードでホイールボタンをダブルクリックすると、オブジェクト内のひとつながりの分子構造(Molecule)について&quot;drag&quot;状態にします。このドラッグモードではこれまでのカメラ操作のような感覚で分子の座標を変更することが可能になります。</p>
<p>このドラッグモードにするとオブジェクトパネルの下側に専用のメニューが現れます。PDB: 1alkの場合で図の右側の構造についてこの操作を実行すると、Mgイオンを除いた右半分のChainだけが選択された状態になります。これは上述のひとつながりの分子構造に対してのみ適用されるからです。</p>
<img src="ch02/./image/mouse/drag1.png" width="100%">
<p>さらに、このドラッグモードではShiftキーを押しながらのマウス操作方法が<strong>RotD</strong>, <strong>MovD</strong>, <strong>MvDZ</strong>に変化します。このDはDraggedを表しており、ドラッグモードとなっている選択範囲のみに対してそれぞれ<strong>回転操作</strong>・<strong>XY軸方向への移動</strong>・<strong>Z軸方向への移動</strong>を行うことができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="セッションの保存-1"><a class="header" href="#セッションの保存-1">セッションの保存</a></h1>
<p><strong>セッション</strong>とは、一連のインタラクティブ操作のことを指します（コンピュータ用語）。PyMOLにおいては、開いてから現在に至るまでの作業記録、と考えることができます。つまり、<strong>セッションの保存</strong>を利用すると作業状態をファイルに保存しておくことができ、あとでその状態を復元することができます。この機能を利用すれば、論文の図を作成している最中に様々な設定を試すことができたり、PyMOLの画面の状態を他の人に表示して確認してもらうということも可能になります。</p>
<p>やり方は簡単で、上部メニューの[<strong>File</strong>]から[<strong>Save Session As...</strong>]を選び、ファイル名を指定してSaveボタンを押して保存するだけです。<br><img src="ch02/./image/session/session1.png" width="250px"></p>
<p>Sessionのファイル形式には<strong>pse</strong>形式と<strong>psw</strong>形式の2つがあります。基本的にはpseファイル形式の方で保存する方がよいでしょう。pswファイルで保存した場合は、そのファイルを開くときに全画面表示が標準になります。例えばデスクトップに<code>foo.pse</code>というファイル名で保存したい場合は以下のように入力して[save]ボタンを押します。<br><img src="ch02/./image/session/session2.png" width="400px"></p>
<p>こうして保存されたセッションファイルを再度PyMOLからロードすれば、元の作業状態に戻すことができます。</p>
<p>※ 一度セッションを保存しておけば、以降は[<strong>Save Session</strong>]ボタンを押すことで同名のセッションファイルに上書きしてくれます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="構造ファイルのエクスポート-1"><a class="header" href="#構造ファイルのエクスポート-1">構造ファイルのエクスポート</a></h1>
<p>ロードされている構造ファイルの全部または一部を書き出して保存することができます。</p>
<p>上部メニューの[<strong>File</strong>]から[<strong>Export Molecule...</strong>]を選ぶと、保存メニューが現れます。</p>
<p><strong>Selection</strong>の部分はエクスポートする構造オブジェクトの範囲を示しています。<em>enabled</em>は現在オブジェクトパネルで表示をONにしている構造オブジェクトすべてを表します。右のプルダウンメニューには他にも<em>all</em>(ロードしている全構造オブジェクト)や個別の構造ファイルのオブジェクト名が含まれています。</p>
<p><strong>State</strong>は1つのオブジェクトに複数の構造状態を持っている場合に、どの状態を保存するかを表しています。デフォルトは <em>-1 (current)</em> で、現在画面に表示されている状態のものを保存します。</p>
<h2 id="対応している出力ファイル形式-1"><a class="header" href="#対応している出力ファイル形式-1">対応している出力ファイル形式</a></h2>
<p><img src="ch02/./image/export/pdbexport4.png" width="300px"><br>
デフォルトでは<code>PDBx/mmCIF (*.cif, *.cif.gz)</code>となっていますが、他にも画像のような様々なファイル形式に出力することができます。</p>
<p>保存メニューには他にも様々なオプションがあります。</p>
<h2 id="generic-options-1"><a class="header" href="#generic-options-1">Generic Options</a></h2>
<img src="ch02/./image/export/pdbexport1.png" width="300px">
<p><input type="checkbox" checked="checked"> Original atom order (according to &quot;rank&quot;)</p>
<p>構造オブジェクトの保存時に、ATOM行の並び順を元のファイルの入力通りに並べるかどうかを設定します。例として元のファイルが</p>
<pre><code>ATOM      1  CH3 ACE A   1      33.160  24.100  12.400  1.00  0.00
ATOM      2 HH31 ACE A   1      32.860  24.830  11.650  1.00  0.00
ATOM      3 HH32 ACE A   1      33.800  23.390  11.880  1.00  0.00
ATOM      4 HH33 ACE A   1      32.250  23.650  12.770  1.00  0.00
ATOM      5  C   ACE A   1      33.910  24.800  13.510  1.00  0.00
ATOM      6  O   ACE A   1      33.760  24.560  14.700  1.00  0.00
</code></pre>
<p>だったとしたとき、設定がOFFであればこの並び順は</p>
<pre><code>ATOM      1  C   ACE A   1      33.910  24.800  13.510  1.00  0.00           C
ATOM      2  O   ACE A   1      33.760  24.560  14.700  1.00  0.00           O
ATOM      3  CH3 ACE A   1      33.160  24.100  12.400  1.00  0.00           C
ATOM      4 HH31 ACE A   1      32.860  24.830  11.650  1.00  0.00           H
ATOM      5 HH32 ACE A   1      33.800  23.390  11.880  1.00  0.00           H
ATOM      6 HH33 ACE A   1      32.250  23.650  12.770  1.00  0.00           H
</code></pre>
<p>という順に書き出されます。この並びは<code>atom identifier</code>順になっています。一方、設定がONであればこの並び順は</p>
<pre><code>ATOM      1  CH3 ACE A   1      33.160  24.100  12.400  1.00  0.00           C
ATOM      2 HH31 ACE A   1      32.860  24.830  11.650  1.00  0.00           H
ATOM      3 HH32 ACE A   1      33.800  23.390  11.880  1.00  0.00           H
ATOM      4 HH33 ACE A   1      32.250  23.650  12.770  1.00  0.00           H
ATOM      5  C   ACE A   1      33.910  24.800  13.510  1.00  0.00           C
ATOM      6  O   ACE A   1      33.760  24.560  14.700  1.00  0.00           O
</code></pre>
<p>のように、元のファイルの原子順に書き出されて保存されます。</p>
<p>コマンドラインでは <code>set retain_order, [0,1]</code>で同様の設定を指定できます（0で無効、1で有効）。</p>
<blockquote>
<p>参考： https://pymolwiki.org/index.php/Retain_order</p>
</blockquote>
<h2 id="pdb-options-1"><a class="header" href="#pdb-options-1">PDB Options</a></h2>
<p><img src="ch02/./image/export/pdbexport2.png" width="300px"><br>
これらのオプションは従来使われていた<code>pdb</code>ファイル形式で出力するときのみ対応します。</p>
<p><input type="checkbox"> Write multiple bonds as duplicate CONECT records</p>
<p>CONECTレコードを複数作成することで原子間の結合次数の情報をエンコードし、ファイルに書き出します。デフォルトではOFFです。ver. 1.6.1から実装されました。</p>
<p>コマンドラインでは <code>set pdb_conect_nodup, [0,1]</code>で無視して保存するかどうかを指定できます（0で書き出す、1で書き出さない）。</p>
<p><input type="checkbox"> Write CONECT records for all bonds</p>
<p>すべての原子間の結合の組み合わせ情報をCONECTレコードに書き出します。デフォルトではOFFです。</p>
<p>コマンドラインでは <code>set pdb_conect_all, [0,1]</code>で同様の設定を指定できます（0で無効、1で有効）。</p>
<blockquote>
<p>参考： https://pymolwiki.org/index.php/Pdb_conect_all</p>
</blockquote>
<p><input type="checkbox" checked="checked"> Write segment identifier (segi) column</p>
<p>segment identifierを書き出すかどうかを指定します。デフォルトではONです。segment identifierとはPDB formatにおいて73-76番目のカラムを利用した識別子のことです。かつて、同一chain IDにありながらある種の原子のグループごとに分けて記述したい場合に用いられましたが、今はChain IDで分けるのが主流となっています。segment identifierは現在廃止された仕様ですが、PyMOLやChimera, CHARMMなど一部のプログラムは未だにこれを利用することができます。</p>
<p>コマンドラインでは <code>set ignore_pdb_segi, [0,1]</code>で無視して保存するかどうかを指定できます（0で書き出す、1で書き出さない）。</p>
<p><input type="checkbox"> Retain atom ids</p>
<p>構造データのエクスポート時に、原子のIDを1から順になるようリナンバリングするかどうかを指定します。デフォルトではOFFです。</p>
<p>コマンドラインでは <code>set pdb_retain_ids, [0,1]</code>で同様の設定を指定できます（0で無効、1で有効）。</p>
<blockquote>
<p>参考： https://pymolwiki.org/index.php/Pdb_retain_ids</p>
</blockquote>
<p><input type="checkbox"> Write HEADER for every object</p>
<p>このオプションを指定すると、保存時に選択された各オブジェクトがHEADERレコード〜ENDレコードで区切られながら1ファイル中にまとめて書き出されます。こうして書き出されたファイルはマルチエントリPDBファイルとなり、PyMOLでこのファイルをロードしようとすると、各エントリごとに異なるオブジェクトとして表示されるようになります。</p>
<p>対称性情報が含まれている場合、CRYST1レコードも記述されます。</p>
<p>内部処理的にはpdb形式で<code>multisave</code>コマンドを使った保存方法に直接対応しています。</p>
<blockquote>
<p>参考： https://pymolwiki.org/index.php/Multisave</p>
</blockquote>
<h2 id="multi-file-1"><a class="header" href="#multi-file-1">Multi-File</a></h2>
<img src="ch02/./image/export/pdbexport3.png" width="300px">
<p>現在PyMOL上で複数表示されているオブジェクトを、複数ファイルに分けてエクスポートしたいときに使うオプションです。さらに、各オブジェクトが2以上のStateを持っている場合（例として、PDB ID:1G03などのNMR構造ファイル、またはMDトラジェクトリをロードしたオブジェクトなど）は、さらにそれらを分割して保存することができます。</p>
<p>デフォルトではone single fileが選択されています。</p>
<p><input type="radio" checked="checked"> one single file
<br>
保存したい対象オブジェクト（上部<code>Selection</code>のところで設定）を1つのファイルにまとめて保存します。保存される対象のStateはメニュー上部の<code>State</code>で変更できます。</p>
<p><input type="radio"> one file per object<br>
複数のオブジェクトが表示されている場合に、各オブジェクトごとにファイルを分割して出力します。デフォルトの出力ファイル名はオブジェクト名に相当する<code>{name}</code>が設定されます。</p>
<p><input type="radio"> one file per object-state<br>
各オブジェクトに複数のstateが存在する場合、上の設定と同様に、<code>{name}_{state}</code>の名前で出力します。</p>
<p><input type="checkbox" checked="checked"> Prompt for every file にチェックが入っている場合は、保存対象ごとにファイル名の指定画面が現れます。例えば、1つのstateを持つAと、20つのstateを持つBのオブジェクトがある場合に<input type="radio" checked="checked"> one file per object-stateを選択すると、21回画面がポップアップすることになります。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="画像の保存-4"><a class="header" href="#画像の保存-4">画像の保存</a></h1>
<p>PyMOLで表示されている画像を保存することができます。上部メニューの[<strong>File</strong>]から[<strong>Export Image As...</strong>] → [<strong>PNG</strong>]を選ぶと、保存メニューが現れます。</p>
<img src="ch02/./image/saveimage/saveimage1.png" width="300px">
<p>デフォルトでは&quot;capture current display&quot;と表示されています。</p>
<img src="ch02/./image/saveimage/saveimage2.png" width="300px">
<p>この設定で下にある&quot;Save PNG image as...&quot;を押すと、保存先を指定するメニューが表示され、名前を入れて保存することができます（画像はいずれも<code>bg_color white</code>で白背景にした場合で表示しています）。</p>
<img src="ch02/./image/saveimage/saveimage_1alk.png" width="400px">
<p>これでとりあえず上のような画像を保存することができましたが、他にも様々なメニューがあるので、状況によって使い分けると良いでしょう。まずは、&quot;capture current display&quot;のプルダウンメニューの部分を押すと、</p>
<img src="ch02/./image/saveimage/saveimage3.png" width="300px">
<p>計4つのメニューがあることがわかります。まず&quot;draw antialiased OpenGL image&quot;とすると、描画にアンチエイリアスがかかります（※なおmacOSの場合、現状OpenGL周りの処理にバグがあるためWARNINGSのメッセージが出ています。）</p>
<img src="ch02/./image/saveimage/saveimage_1alk2.png">
<p>続いて&quot;ray trace with opaque background&quot;とすると、ray traceをかけてオブジェクト全体に陰影をつけながら表示することができます。</p>
<img src="ch02/./image/saveimage/saveimage_1alk3.png">
<p>最後に、&quot;ray trace with transparent background&quot;では、ray traceによる陰影と背景の透過処理が行われます（下の画像例では市松模様になっていますが、実際に出力される画像ではきちんと背景が透明になっています）。</p>
<img src="ch02/./image/saveimage/saveimage_1alk4.png">
<p>特に最後のオプションで背景を透明化したものは、スライドに画像を載せるときなどで利用することが多いため、覚えておくと良いでしょう。</p>
<p>また、保存時のパネルには&quot;To render a sized antialiased image, use the Draw/Ray panel in the upper right.&quot;というメッセージが表示されていますが、これはPyMOLのGUI部分の右上にあるメニューのことを指しています。</p>
<img src="ch02/./image/saveimage/saveimage4.png">
<p>これをクリックすると設定メニューが表示されます。</p>
<img src="ch02/./image/saveimage/saveimage5.png" width="400px">
<p>先述のメニューでは出力される縦と横の画像サイズは指定できませんでしたが、先にここのメニューで縦(Height)と横(Width)の値を目的の値に変更しておけば指定することができます。</p>
<p>Unitsは<code>cm</code>または<code>inch</code>を設定できます。また、DPIはdot per inchのことであり、この値が大きいほど画像の解像度が上がる一方、ファイルサイズは大きくなります。論文誌によっては300 DPIを求められる場合がありますので、発表用のものは<code>300</code>にしておくと良いでしょう。</p>
<p><input type="checkbox" checked="checked"> transparent background (&quot;Ray&quot; only) では、先述の背景の透明化処理の有効・無効を設定できます。</p>
<p>出力は&quot;Draw (fast)&quot;と&quot;Ray (slow)&quot;とありますが、これは先述の&quot;draw antialiased OpenGL image&quot;と&quot;ray trace ~&quot;にそれぞれ対応しています。</p>
<p>コマンドラインで行う場合は、各オプションが以下のコマンドに対応しています。</p>
<table><thead><tr><th>オプション</th><th>コマンド</th></tr></thead><tbody>
<tr><td><em>capture current display</em></td><td><code>png foo.png, 0, 0, -1, ray=0</code></td></tr>
<tr><td><em>draw antialiased OpenGL image</em></td><td><code>draw 0, 0 ; png foo.png, 0, 0, -1, ray=0</code></td></tr>
<tr><td><em>ray trace with opaque background</em></td><td><code>set opaque_background, 1; png foo.png, 0, 0, -1, ray=1</code></td></tr>
<tr><td><em>ray trace with transparent background</em></td><td><code>set opaque_background, 0; png foo.png, 0, 0, -1, ray=1</code></td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="第3章-external-guiの使い方"><a class="header" href="#第3章-external-guiの使い方">第3章 External GUIの使い方</a></h1>
<h1 id="file"><a class="header" href="#file">File</a></h1>
<img src="ch03/./image/file/filemenu.png" width="30%">
<h2 id="new-pymol-window"><a class="header" href="#new-pymol-window">New PyMOL Window</a></h2>
<p><strong>新しくPyMOLのウィンドウを別に立ち上げることができます</strong>。ある構造ファイルを開いている時にまったく別の構造ファイルを開く必要があるときには、このNew PyMOL Windowを使って立ち上げると良いでしょう。一方で類似構造のファイルと比較したいという場合には、新しいPyMOL Windowを開かずに1つのPyMOLウィンドウの中で開くと、構造比較する上で便利です。</p>
<p><code>Default</code>では新しいPyMOL Windowを開くと同時に、ユーザー独自の初期設定ファイルである<code>.pymolrc</code>（存在する場合）とインストールしたプラグインをともに読み込んでくれます。</p>
<p><code>ignore .pymolrc and plugins (-k)</code>の方では、この機能を無効にし、PyMOLのインストール時の初期設定のまま利用できるようになります。ターミナルから<code>pymol -k</code>で起動した場合と同じ効果です。</p>
<h2 id="open"><a class="header" href="#open">Open...</a></h2>
<p>構造ファイルを読み込むことができます。これを選択すると読み込みたいファイルを選択する画面に移行します。ロード可能な構造ファイルを選択することでInternal GUIのViewer部分に構造が表示されます。</p>
<h2 id="open-recent"><a class="header" href="#open-recent">Open Recent...</a></h2>
<p>最近ロードしたことのある構造ファイルの履歴を表示しています。ここから構造ファイルをロードすることも可能です。</p>
<h2 id="get-pdb"><a class="header" href="#get-pdb">Get PDB...</a></h2>
<p>PDBに登録されている構造ファイルや電子密度ファイルのIDを指定することで、インターネットから直接ダウンロードして開くことができます。これはまずこのメニューを選択すると次のような別メニューが開きます。</p>
<img src="ch03/../ch02/image/load/bunit3.png" width="30%">
<p>PDB IDのところにデータベースのIDを入力します。また、下の方にはPDB Structure Optionsが存在し、chain nameの箇所で表示したいChainを指定できます。A chainのみを表示したい場合はAを入力します（指定しない場合はすべて表示されます）。</p>
<p>その構造ファイルに固有のAssemblyを考慮した表示も可能となっています。Biological assemblyを考慮して表示させたい場合は<code>1</code>を、非対称ユニットをロードしたい場合は何も指定しないでおきます。これについては第2章の<a href="ch03/../ch02/loadmol.html">分子構造のロード</a>のページも参考にしてください。</p>
<p>構造ファイルはworking directory上にダウンロードされます。デフォルトの構造ファイル形式は<code>mmCIF</code>となっています。working directoryについては<a href="ch03/index.html#Working-Directory">こちら</a>も参照してください。</p>
<h2 id="save-session--save-session-as"><a class="header" href="#save-session--save-session-as">Save Session &amp; Save Session as...</a></h2>
<p><strong>現在開いている表示状態をセッションファイルに保存します</strong>。ショートカットキーは<code>Ctrl-SまたはCommand + S</code>です。スライド作成や論文のために生体分子の表示形式を保存しておくととても便利なので、ぜひこの機能は活用していきましょう。</p>
<p><code>Save Session</code>はいわゆる「上書き保存」と同じで、<code>Save Session as...</code>は「ファイル名を指定して保存」と同じ機能です。一度もセッションファイルを作成していない状態で<code>Save Session</code>を押すと自動的に「ファイル名を指定して保存」に切り替わります。</p>
<p>拡張子はPyMOL Session File（<code>.pse</code>）とPyMOL Show File（<code>.psw</code>）の2つを選ぶことができます。<code>pse</code>ファイル形式で保存すると、再びこのファイルを開いたときにPyMOLの作業状態をそのまま復元するのに対し、<code>psw</code>ファイル形式で保存した場合は、このファイルを開くと全画面表示＋Internal GUIとExternal GUIが表示されない状態で開かれます。つまり、pswファイルは編集用というよりは完全に表示用に向いています。</p>
<img src="ch03/../ch03/image/file/psw.png" width="30%">
<p>pswファイルを開いたときの例。Internal GUIとExternal GUIが表示されません。</p>
<p>一応、この状態からでも上部メニューの[Display] -&gt; [Internal GUI]と[External GUI] -&gt; [Visible]をクリックすればいつものGUIが表示されるようになるので覚えておくと良いでしょう。</p>
<h2 id="export-molecule"><a class="header" href="#export-molecule">Export molecule...</a></h2>
<p>現在画面上に開いている生体分子オブジェクトをファイルとして出力します。詳細は<a href="ch03/../ch02/export.html">第2章 構造ファイルのエクスポート</a> を御覧ください。</p>
<h2 id="export-map"><a class="header" href="#export-map">Export map...</a></h2>
<p><code>.ccp4</code>などの電子密度マップなどを出力します。電子密度マップについては<a href="ch03/../ch05/xtal_elecmap.html">第5章 結晶構造の電子密度マップを表示する</a>などで参照してください。マップオブジェクトがロードされた状態で選択すると以下のようなダイアログが現れます。</p>
<img src="ch03/../ch03/image/file/savemap.png" width="30%">
<p>保存したいマップオブジェクトを選びSaveボタンを押してファイル名を入力することで保存されます。デフォルト拡張子は<code>.ccp4</code>です。</p>
<h2 id="export-alignment"><a class="header" href="#export-alignment">Export alignment...</a></h2>
<p>この機能を利用するためには類似のタンパク質間での<strong>アライメントオブジェクト</strong>を生成しておく必要があります。アライメントオブジェクトについては<a href="ch03/../ch04/cmd_super.html">第4章 オブジェクトの重ね合わせ</a>を参照してください。</p>
<h2 id="export-image-as"><a class="header" href="#export-image-as">Export Image As...</a></h2>
<p>画像を保存するだけでなく、3Dモデリングへの出力にも対応しています。</p>
<h3 id="png"><a class="header" href="#png">PNG...</a></h3>
<p>PNG形式の画像を保存することができます。これについての詳細は第2章の<a href="ch03/../ch02/saveimage.html">画像の保存</a>を参照してください。</p>
<h3 id="vrml-2"><a class="header" href="#vrml-2">VRML 2...</a></h3>
<p>表示しているモデルをwireframe/VRMLの形式で座標情報をエクスポートすることができます。mesh表示やSurface表示にも対応しています。
タンパク質の3Dプリンタでの出力のときに利用できますが、PyMOLだけでなく他のソフトウェアとの様々な工程を経る必要があるため、詳細はここでは割愛します。</p>
<p>クオリティを上げたい場合は、以下のオプションを利用すると良いそうです。</p>
<pre><code>set surface_quality, 1
set cartoon_sampling, 20
</code></pre>
<h3 id="collada"><a class="header" href="#collada">COLLADA...</a></h3>
<p>COLLADAというXMLベースのオープン3Dグラフィック形式で出力することができます。PyMOLのcartoon, stick, line, sphere, surfaceなどのスタンダードな表示形式に対応して出力することができます。PyMOL 1.7.3.2から正式実装されました。拡張子は<code>.dae</code>です。</p>
<p>上記VRML 2の後発ですが、こちらの形式で出力して3Dプリンタ出力やBlenderなどでの編集も行えるようになるかもしれません。PyMOL 2.4からはglTF (GL Transmission Format)という形式でも出力できるようになるそうです。VRML 2のときのクオリティオプションコマンドも利用できます。</p>
<h3 id="pov-ray"><a class="header" href="#pov-ray">POV-Ray...</a></h3>
<p><a href="http://www.povray.org/">POV-Ray</a>で読み込めるように拡張子<code>.pov</code>で出力します。</p>
<h2 id="export-movie-as"><a class="header" href="#export-movie-as">Export Movie As...</a></h2>
<p>動画を出力することができます。</p>
<h3 id="mpeg"><a class="header" href="#mpeg">MPEG...</a></h3>
<h3 id="quick-time"><a class="header" href="#quick-time">Quick time...</a></h3>
<h3 id="png-images"><a class="header" href="#png-images">PNG Images...</a></h3>
<h2 id="log-file"><a class="header" href="#log-file">Log File</a></h2>
<p>PyMOLで操作記録を取ることができます。</p>
<h3 id="open-1"><a class="header" href="#open-1">Open...</a></h3>
<h3 id="resume"><a class="header" href="#resume">Resume...</a></h3>
<h3 id="append"><a class="header" href="#append">Append...</a></h3>
<h3 id="close"><a class="header" href="#close">Close</a></h3>
<h2 id="run-script"><a class="header" href="#run-script">Run Script...</a></h2>
<h2 id="working-directory"><a class="header" href="#working-directory">Working Directory</a></h2>
<p>作業ディレクトリのパスを変更します。macOSでアプリケーションからPyMOLを起動させた場合、デフォルトの作業ディレクトリ(以降wd)はホームディレクトリ、ターミナルからコマンドでPyMOLを起動させた場合には、そのターミナル上での作業ディレクトリになっています。</p>
<p><a href="ch03/index.html#Get-PDB...">Get PDB...</a>を利用する場合など、ファイルの読み込み・書き出しは、この作業ディレクトリのパスを基準に考慮する必要があります。Linuxまたはターミナルの操作に慣れている方にとっては言うまでもない概念でしょう。</p>
<p>PyMOLのコマンドラインからは<code>cd</code>コマンドを使うことで変更することができます。</p>
<pre><code># Working Directoryをデスクトップに設定する
# (Linux, macOSの場合)
cd ~/Desktop
</code></pre>
<h2 id="edit-pymolrc"><a class="header" href="#edit-pymolrc">Edit pymolrc</a></h2>
<p>PyMOLを起動したときに自動的に実行される設定である<code>pymolrc</code>ファイルを編集することができます。bash, zshで言うところの<code>.bashrc</code>, <code>.zshrc</code>と同様に、<code>pymolrc</code>に設定を書き込んでおけば、描画に関する設定やPATH設定などを上書きしておくことができます。macOS, Linuxの場合は<code>pymolrc</code>ファイルはホームディレクトリ上に生成されます。</p>
<img src="ch03/./image/file/editpymolrc.png" width="80%">
<pre><code>set sphere_scale, .22
set sphere_scale, .13, elem H
set dash_gap, 0
set dash_gap, .15
set dash_length, .05
set dash_round_ends, 0
set dash_radius, .05
set label_size, 18
set cartoon_loop_radius, 0.1
set cartoon_putty_radius, 0.2
set cartoon_oval_length, 0.8
set label_digits, 3
set ray_opaque_background, 0
set dash_length, 0.2500
set cartoon_gap_cutoff, 0
</code></pre>
<p>設定はPyMOLコマンド形式で記述する必要があります。</p>
<h2 id="reinitialize"><a class="header" href="#reinitialize">Reinitialize</a></h2>
<p>Reinitializeはその名の通りPyMOLを再初期化してくれます。表示されているオブジェクトを含め再起動したかのようにしてくれるEverythingと、設定値だけを再起動するもののsettings系のどちらかを選ぶことができます。</p>
<h3 id="everything"><a class="header" href="#everything">Everything</a></h3>
<p>Everythingを選ぶと、PyMOLで現在開いているすべての生体分子オブジェクトは消去され、完全にPyMOLを再起動したような状態になります。<strong>それまで保存していなかった作業内容も予告内容なしに消えてしまう</strong>ので、慎重にこのボタンを押してください。</p>
<h3 id="original-settings"><a class="header" href="#original-settings">Original Settings</a></h3>
<p>これらのOriginal Settings, Stored Settingsのメニューでは、現在表示されている生体分子オブジェクトは消去されません。こちらで再初期化してくれるのは<strong>PyMOLの描画の設定値</strong>です。例えばPyMOLのヘリックスの描画の太さ(<code>set cartoon_oval_length, 0.8</code>)やループの太さ(<code>set cartoon_loop_radius, 0.1</code>)、ミッシング領域の描画の有無(<code>set cartoon_gap_cutoff, 0</code>)……などといった、PyMOLの描画全体に影響を及ぼす値を初期値に修正した状態で再び描画し直してくれるのがこの<code>Original Settings</code>です。</p>
<p>上の<code>Edit pymolrc</code>で描画設定を変更していた場合でも、この<code>Original Settings</code>を押すとPyMOL内部の設定値で上書きされてしまうので注意してください。</p>
<h3 id="stored-settings"><a class="header" href="#stored-settings">Stored Settings</a></h3>
<p>保存しておいた描画の設定値を呼び出してくれます。これは下記の<code>Store Current Settings</code>の機能と対応しています。</p>
<h3 id="store-current-settings"><a class="header" href="#store-current-settings">Store Current Settings</a></h3>
<p>現在の描画の設定値を保存しておいてくれます。これを一度しておけば、以降PyMOLのプログラムを終了するまで上記の<code>Stored Settings</code>からその設定値を呼び出すことができます。</p>
<p>これら<code>Reinitialize</code>についてPyMOLのコマンドラインから行う場合は以下の通りです。</p>
<pre><code>reinitialize [ what [, object ]]
</code></pre>
<p>whatには<code>everything</code>または<code>settings</code>が入ります。settings部分には<code>settings</code>, <code>original_settings</code>, <code>stored_settings</code>が選べるようです。defaultはeverything。
objectにはオブジェクト名を入れることができます。</p>
<h1 id="build"><a class="header" href="#build">Build</a></h1>
<p>Buildのメニューからは、PyMOLに内蔵されている化合物のフラグメントやアミノ酸残基のデータを利用して任意の化合物またはポリペプチド鎖の構造モデルを生成することができるようになっています。主な利用方法としては、既存のタンパク質構造をロードしたあとに、その末端に長い人工ペプチドを取り付けたモデル構造を作成することや、0から任意のポリペプチド鎖を作成して計算科学の研究の初期構造に利用するという使い方があります。</p>
<p>Buildメニューは以下の通りです。</p>
<img src="ch03/./image/build/ch3_build1.png" width="40%" height="40%">
<h2 id="fragment"><a class="header" href="#fragment">Fragment</a></h2>
<p>ここでは主要な化学小分子の骨格を、フラグメントをつなぎ合わせるような感覚で構築することができます。使い方の例を動画で見てみましょう。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/build/fragment1.mp4" type="video/mp4">
</video>
<p>このように、何もない状態から様々な化学骨格を持った分子を作っていくことができます。……ただ、結構癖があって、任意に小分子を作るというのには慣れが必要で、構造最適化部分も含めて他のソフトウェアを使った方がいいような気もします。</p>
<p>やり方としては、まずこのFragmentメニューからベースとなる化合物骨格を選んできます（しかしこの時点でベンゼン環がないので結構アレなんですけれど……。）
その後、マウスのPkAt機能（参考：<a href="ch03/../ch02/buttonaction.html#%E5%8E%9F%E5%AD%90%E3%83%94%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0pkatpk1">マウス操作の詳細,原子ピッキング</a>）を使って原子を1つピッキングした状態にします。この状態でさらにFragmentメニューからフラグメントを選ぶと、そのピックされた原子部分に選択された化学骨格が生えていきます。これを繰り返していくことで、任意の化合物を作ることが理論上可能です。</p>
<p>化合物の二面角や角度を手動で調整したい場合は、マウス操作で調節して作り出してください（参考：<a href="ch03/../ch02/buttonaction.html#%E4%BA%8C%E9%9D%A2%E8%A7%92%E3%82%92%E3%83%94%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0pktb">マウス操作の詳細,二面角をピッキング</a>）。また、一応お気持ち程度ですが、後で紹介する<strong>Sculpting</strong>という機能を使うと、簡単な化合物の構造最適化をかけてくれて、無理のない構造に落ち着かせることができます。</p>
<h2 id="residue"><a class="header" href="#residue">Residue</a></h2>
<p>このメニューは20種類の正準アミノ酸の残基のデータの他に、N末端キャッピング用のAcetylとC末端キャッピング用のN-Methylが存在しています。キャッピングとはMDシミュレーション上で使われる人工的な修飾で、末端部分の電荷をニュートラルにするために使われます。それ以外の方はあまり利用することがないでしょう。</p>
<p>AltキーとA~Zの文字を組み合わせて入力することでマウスを使わずに簡単にポリペプチド鎖を作成していくことができます。例えば、PyMOLを開き、BuildメニューからResidue -&gt; Helixを選び、Internal GUI画面上でAltキーを押しながら<code>ACDVAARHK</code>と連続して押すと</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/build/residue1.mp4" type="video/mp4">
</video>
<p>このようにαヘリックス様のタンパク質フラグメントが簡単に生成されました。同様にして、antiparallel, parallelのβシート構造も作り出すことができます。ただしループ構造は自動で生成してくれませんので、手動で任意の二面角を調節して作り出してください。（参考：<a href="ch03/../ch02/buttonaction.html#%E4%BA%8C%E9%9D%A2%E8%A7%92%E3%82%92%E3%83%94%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0pktb">マウス操作の詳細,二面角をピッキング</a>）</p>
<p>また、プログラミングしたいときに便利な点として、<code>cmd._alt(chr(XX))</code>を入力することでそのキーを入力した扱いにすることができます。XXにはASCII CODEが入ります（A: 65, B: 66, C: 67, ... 88: X, Y: 89, Z: 90）。</p>
<table><thead><tr><th align="left">表示</th><th align="center">残基名</th><th align="center">cmd</th><th align="left">ショートカットキー</th></tr></thead><tbody>
<tr><td align="left">Acetyl</td><td align="center">アセチル基</td><td align="center"><code>cmd._alt(chr(66))</code></td><td align="left">Alt-B</td></tr>
<tr><td align="left">Alanine</td><td align="center">アラニン</td><td align="center"><code>cmd._alt(chr(65))</code></td><td align="left">Alt-A</td></tr>
<tr><td align="left">Amine</td><td align="center">アミン</td><td align="center">-</td><td align="left"></td></tr>
<tr><td align="left">Aspartate</td><td align="center">アスパラギン酸</td><td align="center"><code>cmd._alt(chr(68))</code></td><td align="left">Alt-D</td></tr>
<tr><td align="left">Asparagine</td><td align="center">アスパラギン</td><td align="center"><code>cmd._alt(chr(78))</code></td><td align="left">Alt-N</td></tr>
<tr><td align="left">Arginine</td><td align="center">アルギニン</td><td align="center"><code>cmd._alt(chr(82))</code></td><td align="left">Alt-R</td></tr>
<tr><td align="left">Cysteine</td><td align="center">システイン</td><td align="center"><code>cmd._alt(chr(67))</code></td><td align="left">Alt-C</td></tr>
<tr><td align="left">Glutamate</td><td align="center">グルタミン酸</td><td align="center"><code>cmd._alt(chr(69))</code></td><td align="left">Alt-E</td></tr>
<tr><td align="left">Glutamine</td><td align="center">グルタミン</td><td align="center"><code>cmd._alt(chr(81))</code></td><td align="left">Alt-Q</td></tr>
<tr><td align="left">Glycine</td><td align="center">グリシン</td><td align="center"><code>cmd._alt(chr(71))</code></td><td align="left">Alt-G</td></tr>
<tr><td align="left">Histidine</td><td align="center">ヒスチジン</td><td align="center"><code>cmd._alt(chr(72))</code></td><td align="left">Alt-H</td></tr>
<tr><td align="left">Isoleucine</td><td align="center">イソロイシン</td><td align="center"><code>cmd._alt(chr(73))</code></td><td align="left">Alt-I</td></tr>
<tr><td align="left">Leucine</td><td align="center">ロイシン</td><td align="center"><code>cmd._alt(chr(76))</code></td><td align="left">Alt-L</td></tr>
<tr><td align="left">Lysine</td><td align="center">リジン</td><td align="center"><code>cmd._alt(chr(75))</code></td><td align="left">Alt-K</td></tr>
<tr><td align="left">Methionine</td><td align="center">メチオニン</td><td align="center"><code>cmd._alt(chr(77))</code></td><td align="left">Alt-M</td></tr>
<tr><td align="left">N-Methyl</td><td align="center">N-メチル</td><td align="center"><code>cmd._alt(chr(90))</code></td><td align="left">Alt-Z</td></tr>
<tr><td align="left">Phenylalanine</td><td align="center">フェニルアラニン</td><td align="center"><code>cmd._alt(chr(70))</code></td><td align="left">Alt-F</td></tr>
<tr><td align="left">Proline</td><td align="center">プロリン</td><td align="center"><code>cmd._alt(chr(80))</code></td><td align="left">Alt-P</td></tr>
<tr><td align="left">Serine</td><td align="center">セリン</td><td align="center"><code>cmd._alt(chr(83))</code></td><td align="left">Alt-S</td></tr>
<tr><td align="left">Threonine</td><td align="center">スレオニン</td><td align="center"><code>cmd._alt(chr(84))</code></td><td align="left">Alt-T</td></tr>
<tr><td align="left">Tryptophan</td><td align="center">トリプトファン</td><td align="center"><code>cmd._alt(chr(87))</code></td><td align="left">Alt-W</td></tr>
<tr><td align="left">Tyrosine</td><td align="center">チロシン</td><td align="center"><code>cmd._alt(chr(89))</code></td><td align="left">Alt-Y</td></tr>
<tr><td align="left">Valine</td><td align="center">バリン</td><td align="center"><code>cmd._alt(chr(86))</code></td><td align="left">Alt-V</td></tr>
</tbody></table>
<h2 id="sculpting"><a class="header" href="#sculpting">Sculpting</a></h2>
<p>Sculptingは「彫刻する」というような意味ですが、PyMOLのこの機能では、上で生成したような小分子またはポリペプチド鎖について<strong>簡単な構造最適化</strong>をかけてくれるようです。</p>
<p>ただし、この機能は現在PyMOLの開発者としてはサポートの対象外とされているようで、現時点ではこの機能が改善されることや発見されたバグの修正が行われることはないとされています（参考：<a href="https://pymol.org/dokuwiki/doku.php?id=unsupported">PyMOL: Unsupported Features</a>）。したがって、ここでは簡単な使い方の紹介を留める程度にしておきます。</p>
<p>まずSculptingメニューの先にあるサブメニューの2段めにあるSculptingにチェックを入れます（この操作はコマンドで<code>set sculpting, on</code>とすることでもできます）。そしてその下にあるactivateをクリックすると、表示されている分子の構造最適化が自動的に始まります。ただし、この操作は画面に表示されている分子に対して行われてしまうことに注意してください。コマンドでは<code>sculpt_activate all</code> とします。途中で止めたい場合は<code>sculpt_deactivate all</code>と入力します。<code>all</code>の部分を生体分子のオブジェクト名にすればその分子のみを構造最適化させることができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/build/sculpting1.mp4" type="video/mp4">
</video>
<h2 id="cycle-bond-valence-ctrl-shift-w"><a class="header" href="#cycle-bond-valence-ctrl-shift-w">Cycle Bond Valence [Ctrl-Shift-W]</a></h2>
<p>現在選択中の「結合」に対して、その結合を芳香環のような結合として設定させます。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Wの同時押しです。</p>
<p>結合を選択する方法は<a href="ch03/../ch02/buttonaction.html#%E4%BA%8C%E9%9D%A2%E8%A7%92%E3%82%92%E3%83%94%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0pktb">マウス操作の詳細,二面角をピッキング</a>と同じです。この機能で結合を選択したあと、Ctrl-Shift-Wキーを同時押しすることで、その結合が芳香環様結合として設定させることができます。例えばFragmentメニューに存在するCyclohexyl[Alt-6]にこの機能を適用してベンゼン環に変更したいという場合、6つすべての炭素-炭素結合についてこの操作を行う必要があります。このとき水素原子は自動で増減します。こののち、上記のSculptingによる構造最適化を行えばすべての炭素原子が同一平面上に位置するようになったベンゼン環構造が得られます（が、水素原子の位置がきれいな構造じゃない気がします）。</p>
<h2 id="fill-hydrogens-on-pk1-ctrl-shift-r"><a class="header" href="#fill-hydrogens-on-pk1-ctrl-shift-r">Fill Hydrogens on (Pk1) [Ctrl-Shift-R]</a></h2>
<p>Pk1で選択されている「原子」に対して、その原子につながっている結合数に応じて水素原子を取り付けてくれます。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Rの同時押しです。コマンドは<code>h_fill</code>です。</p>
<h2 id="invert-pk2-pk1-pk3-ctrl-shift-e"><a class="header" href="#invert-pk2-pk1-pk3-ctrl-shift-e">invert (pk2)-(pk1)-(pk3) [Ctrl-Shift-E]</a></h2>
<p>PkAt機能で原子を3つ選んだ状態、すなわちPk1, Pk2, Pk3が存在している状態でこのコマンドを選択すると、Pk1から先のフラグメントがPk1-Pk2軸回りに180度反転した位置に変化します。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Eの同時押しです。コマンドは<code>invert</code>です。</p>
<h2 id="create-bond-pk1-pk2-ctrl-shift-t"><a class="header" href="#create-bond-pk1-pk2-ctrl-shift-t">create bond (pk1)-(pk2) [Ctrl-Shift-T]</a></h2>
<p>PkAt機能で原子を2つ選んだ状態、すなわちPk1, Pk2が存在する状態でこのコマンドを選択すると、2原子の間に結合が形成されます。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Tの同時押しです。内部コマンドの処理としては<code>bond ; unpick</code>が働いています。</p>
<p>これは環を閉じたいときに有用だったり、描画上の問題で離れている2原子を結合したような状態に見せたいときに有用です。</p>
<p>ちなみにコマンド専用ですが、bondコマンドを使うときに<code>bond order=2</code>とすると二重結合として結合を表示させられます。三重結合のときは<code>bond order=3</code>、芳香環様結合のときは<code>bond order=4</code>とします。</p>
<h2 id="remove-pk1-ctrl-shift-d"><a class="header" href="#remove-pk1-ctrl-shift-d">Remove (pk1) [Ctrl-Shift-D]</a></h2>
<p>Pk1で選択されている原子を削除します。また、PkTbで選択されている結合についても削除することができます。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Dの同時押しです。コマンドは<code>remove_picked</code>です。</p>
<h2 id="make-pk1-positive-ctrl-shift-k--make-pk1-negative-ctrl-shift-j--make-pk1-neurtral-ctrl-shift-u"><a class="header" href="#make-pk1-positive-ctrl-shift-k--make-pk1-negative-ctrl-shift-j--make-pk1-neurtral-ctrl-shift-u">Make (Pk1) positive [Ctrl-Shift-K] / Make (Pk1) negative [Ctrl-Shift-J] / Make (Pk1) neurtral [Ctrl-Shift-U]</a></h2>
<p>Pk1で選択されている原子の電荷を+1, -1, 0にそれぞれ設定させることができます。設定値はLabel機能のother properties, formal chargeを押すと確認することができます。</p>
<h1 id="edit"><a class="header" href="#edit">Edit</a></h1>
<p>主にUndo, Redo機能を取り扱います。注意していただきたいのは、この機能は主に<a href="ch03/./build.html">3.3 Build</a>で<strong>原子の座標に変更を加えたもの</strong>に対してのみ適用される仕様であり、<strong>分子のカラーリングや視点の変更、表示形式の変更</strong>には対応していません。</p>
<h2 id="undo-ctrl-z"><a class="header" href="#undo-ctrl-z">Undo [Ctrl-Z]</a></h2>
<p>Buildメニューから行った原子の座標変更や原子＆結合の生成・消去についての操作を取り消すことができます。ショートカットキーはCtrl（Macの方はCommandでも可）-Zの同時押しです。下記の&quot;Max Atom Count for Undo/Redo&quot;で設定した値までは何度も操作を取り消すことができます。</p>
<h2 id="redo-ctrl-y"><a class="header" href="#redo-ctrl-y">Redo [Ctrl-Y]</a></h2>
<p>Undoで取り消した操作を再び呼び戻すことができます。ショートカットキーはCtrl（Macの方はCommandでも可）-Yの同時押しです。</p>
<h2 id="max-atom-count-for-undoredo"><a class="header" href="#max-atom-count-for-undoredo">Max Atom Count for Undo/Redo</a></h2>
<p>Undo/Redoで戻せる操作の数を設定できます。デフォルトでは1000となっています。設定値は他に10000, 100000のほか、Unlimited（制限なし）やDisable Undo(実質0)を選ぶことができます。設定値を超えた分の操作は消去され、呼び出すことができなくなります。</p>
<p>一見無制限が良いように思えますが、PyMOLを動かしているマシンのメモリをオーバーして保存しようとするとPyMOLがクラッシュしてしまいます。現実的には1000で問題ないと思います。</p>
<p>コマンドは<code>set suspend_undo_atom_count, 1000</code>です。<code>1000</code>の部分は任意のint値を入れることができます。</p>
<h2 id="auto-copy-images"><a class="header" href="#auto-copy-images">Auto-Copy Images</a></h2>
<p>PyMOL 1.8には遅くとも実装されていたようですが、Incentive版のPyMOL 2.1から全プラットフォームで実装されたようです。マニュアルによれば</p>
<blockquote>
<p>auto_copy_images (boolean, default: on) controls whether or not PyMOL automatically copies images from the OpenGL viewport into the system’s clipboard.</p>
</blockquote>
<p>とあるのですが、使い方がよくわかりませんでした。</p>
<h1 id="setting"><a class="header" href="#setting">Setting</a></h1>
<h1 id="scene"><a class="header" href="#scene">Scene</a></h1>
<img src="ch03/./image/scene/scenemenu.png" width="200px">
<p><strong>Externalメニューに存在するScene機能は論文・ポスター発表や動画作成の時にとても重宝します</strong>。PyMOLに表示したタンパク質の構造を色んな角度から撮影したり、色んなカラーリングや設定値を試したり、それらをつなげて動画にまとめて出力したいという試行錯誤は、読み手に分かりやすい論文・ポスター用の図を作成する上で必要な作業だと思われます。そんなとき、1つの作業セッションファイル中に複数の表示状態を保存することができるこの<strong>Scene</strong>機能をぜひ活用しましょう。</p>
<video controls autoplay loop>
<source src="./image/scene/scene1.mp4" type="video/mp4">
</video>
<p>この動画で示しているように、左下に<code>001</code>, <code>002</code>, <code>003</code>という小さなボタンが現れています。ここをクリックすることで、<strong>前もって保存しておいたカメラ角度(view/camera)、色使い(color)、表示形式（rep/representations）に戻って表示させる</strong>ことができます。</p>
<p>このボタンはSceneの<code>append</code>または<code>Store</code>機能によって生成することができます。内容を上書きするには<code>Update</code>を、削除するには<code>Delete</code>を用います。<code>Recall</code>, <code>Store</code>, <code>Clear</code>の3つは、<code>Append</code>, <code>Delete</code>の使い方に似ていますが、キーボードのF1〜F12を使ったショートカットキーと自動的に結びつけてくれるため使い勝手が良くなります。</p>
<p><strong>Sceneボタンをマウスでクリックして白くなっているときを<code>active</code>状態と呼びます。</strong></p>
<h2 id="next-pgdn--previous-pgup"><a class="header" href="#next-pgdn--previous-pgup">Next [PgDn] / Previous [PgUp]</a></h2>
<p>すでに複数のSceneボタンが存在しているときに動作します。Nextで次の、Previousで前のSceneを表示させることができます。Next, Previousはそれぞれキーボードの[PgDn], [PgUp]ボタンにショートカットキーが割り当てられているので、マウスを使わずにSceneを切り替えることができます。</p>
<hr>
<h2 id="append-1"><a class="header" href="#append-1">Append</a></h2>
<p><strong>現在の表示状態をSceneに追加します</strong>。デフォルトではSceneオブジェクト名は自動的に<code>001</code>からの連番になります。</p>
<p>内部処理としては、コマンドで<code>scene new, store</code>が作動します。<code>new</code>は自動的に連番のIDを割り振ります。<code>new</code>以外の文字を入力すると、そのオブジェクト名でSceneが生成されます。</p>
<h3 id="append-camera-color-reps-repscolor"><a class="header" href="#append-camera-color-reps-repscolor">Append (Camera, Color, Reps, Reps+Color)</a></h3>
<p>Camera (view), Color, Repsはそれぞれ撮影角度、表示されている分子のカラーリング、表示された分子の表示形式を表しています。上述の<code>Append</code>ではこれらをすべて保存してSceneに登録するのに対して、こちらのサブメニューではその一部のみをSceneに登録します。</p>
<p>内部処理としては、コマンドで<code>scene new, store, view=0/1, color=0/1, rep=0/1</code>としており、<code>0</code>
のとき各情報を保存しない、<code>1</code>のときに情報を保存する、としています。</p>
<h2 id="insert-before--after"><a class="header" href="#insert-before--after">Insert Before / After</a></h2>
<p>現在表示している画面の状態のScene登録を、現在ActiveになっているSceneの上(before)または下(after)に登録させます。これによって、上述の Next [PgDn] / Previous [PgUp] との円滑な連携を図ることができます。</p>
<p>内部処理としては、コマンドで<code>scene &lt;scene_name&gt;, insert_before/insert_after</code>としています。</p>
<h2 id="update"><a class="header" href="#update">Update</a></h2>
<p>現在表示している画面の状態を、ActiveになっているSceneボタンの上に上書きします。内部処理としては、コマンドで<code>scene &lt;scene_name&gt;, update</code>としています。</p>
<hr>
<h2 id="delete"><a class="header" href="#delete">Delete</a></h2>
<p>現在ActiveになっているSceneボタンを削除します。内部処理としては、コマンドで<code>scene &lt;scene_name&gt;, clear</code>としています。</p>
<hr>
<h2 id="recall"><a class="header" href="#recall">Recall</a></h2>
<p>下記の<code>Store</code>で保存されたSceneを呼び出すことができます。
上で見たような連番のSceneボタンと異なり、F1〜F12ボタンと自動的に結びつけて操作することが可能です。例えば、<code>F1</code>でStoreされたSceneをF1キーを押すだけで呼び出すことができます。</p>
<h2 id="store"><a class="header" href="#store">Store</a></h2>
<p>F1〜F12ボタンと自動的に結びつけられたSceneボタンを生成することができます。使い方は<code>Append</code>と似ています。</p>
<p><strong>Windows/Linuxの場合はCtrlキーと, macOSの場合はCommandキーとF1〜F12とすることで現在表示されている画面をSceneに登録することができます</strong>。</p>
<h2 id="clear-3"><a class="header" href="#clear-3">Clear</a></h2>
<p>F1〜F12ボタンと自動的に結びつけられたSceneボタンを削除します。</p>
<hr>
<h2 id="buttons"><a class="header" href="#buttons">Buttons</a></h2>
<p>画面左下にSceneのボタンを表示するかしないかを設定できます。</p>
<p>コマンドでは<code>set scene_buttons, 0/1</code>でそれぞれ表示しない（<code>0</code>）、表示する（<code>1</code>）を設定できます。</p>
<h2 id="cache"><a class="header" href="#cache">Cache</a></h2>
<p>現在ActiveになっているSceneに対し、<code>enable</code>または<code>optimize</code>を選択することでそのSceneのキャッシュを生成します。通常、Scene間の表示形式の切り替え時には再度新たに描画のON/OFFを内部で行っているため、わずかに切り替えに時間がかかりますが、キャッシュを生成しておくとあらかじめ最適化された描画を記憶しておくためにSceneの切り替え時間が短くなります。これは特に分子表面の表示のON/OFFが関係している時に有効です。しかしその反面多量のメモリを確保する必要があるので、初回の操作は重くなります。
<code>disable</code>とするとキャッシュ機能を無効化します。（<code>read_only</code>はちょっとわかりませんでした……。）</p>
<p>cacheを<code>optimize</code>にすると、今ActiveになっているSceneに対して現在登録されている他のSceneからの切り替えをすべて計算するため、かなり重い処理になります。</p>
<p>コマンドでは<code>cache action [, scenes [, state ]]</code>となります。<code>scenes</code>はスペース区切りで複数指定できます。使用例は以下の通りです。</p>
<pre><code>cache enable
cache optimize
cache optimize, F1 F2 F5
</code></pre>
<h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<img src="ch03/./image/mouse/mousemenu.png" width="30%">
<p>ここではマウス操作についてのメニューを表示しています。マウス操作については<a href="ch03/../ch02/mouse.html">2.4 マウス操作</a>を適宜参照することをおすすめします。</p>
<h2 id="selection-mode"><a class="header" href="#selection-mode">Selection Mode</a></h2>
<p><a href="ch03/../ch02/buttonaction.html#%E9%81%B8%E6%8A%9E--">+/-機能</a>（デフォルト設定では3-Button Viewingモードで左のシングルクリック）で選択範囲を増減させるときの、選択範囲の単位を変更します。デフォルトは<code>Residues</code>で、他にも<code>Atoms</code>, <code>Chains</code>, <code>Segments</code>, <code>Objects</code>, <code>Molecules</code>, <code>C-alphas</code>から選択することができます。</p>
<p>GUI上では、右下のメニューからSelectingの部分をクリックすることで、選択範囲を変更することができます。</p>
<p>コマンドからは<code>set mouse_selection_mode, (value)</code>で変更できます。設定値0, 1, 2, 3 ,4, 5, 6がそれぞれ<code>atoms</code>, <code>residues</code>, <code>chains</code>, <code>segments</code>, <code>objects</code>, <code>molecules</code>, <code>C-alphas</code>に対応します。</p>
<h2 id="mouse-mode"><a class="header" href="#mouse-mode">Mouse Mode</a></h2>
<p><a href="ch03/../ch02/buttonmode.html">2.4.1 操作モード</a>も参照して下さい。マウスのボタン配置と操作方法を、3 Button Motions, 3 Button Editing, 3 Button Viewing, 3 Button Lights, 3 Button All Modes, 2 Button Editing, 2 Button Viewing, 1 Button Viewing Mode, Emulate Maestroの中から選択することができます。</p>
<p>デスクトップ型パソコンを使っていて、左クリック、ホイールクリック（ミドルクリック）、右クリックが揃ったマウスを使える環境であれば、3 Button式を選ぶと機能を最大限活用することができます。一方、最近はホイールクリックのないタイプのタッチパッド（Macbookなど）もありますので、そういった方は2 Button式のメニューを選ぶことをおすすめします。</p>
<p>Emulate Maestroは<a href="https://www.schrodinger.com/maestro">Schrödinger Maestro</a>のマウス操作感覚とほぼ同じような設定になっています。</p>
<p>コマンドからも設定できるように思えるのですが、見かけだけ変わるようで実際の操作が変わっていないように見えます……。素直にGUIメニューから設定変更した方がよいと思われます。</p>
<h2 id="virtual-trackball"><a class="header" href="#virtual-trackball">Virtual Trackball</a></h2>
<p>この機能をONにすると（デフォルトはON）、分子が写っている画面の中央に見えないトラックボールが置かれてあるような状態になります。</p>
<img src="ch03/./image/mouse/mouse_virtual.jpg" width="80%">
<p>このトラックボールの外にマウスカーソルをあわせて視点を変更しようとしたときの挙動が、Virtual Trackballの設定値によって変動します（トラックボール内部はON/OFFともに同じです）。ONのときにトラックボールの外で視点を変更しようとすると、Z軸だけが回転するような動きになります。OFFのときは全体がトラックボールの上にあるような動きになります。</p>
<p>コマンドからは<code>set virtual_trackball, (value)</code>で変更できます。<code>0</code>がOFF, <code>1</code>がONです。</p>
<blockquote>
<p>The virtual trackball works as if there is an invisible ball in the center of the scene. When you click and drag on the screen, it is as if you put your finger on the sphere and rotated it in approximately the same manner. If you click outside the sphere, then you get rotation about the Z-axis only.</p>
</blockquote>
<h2 id="show-mouse-grid"><a class="header" href="#show-mouse-grid">Show Mouse Grid</a></h2>
<p>GUIメニュー右下のマウスの操作方法メニューの表示をON/OFFにします。</p>
<p><img src="ch03/./image/mouse/mouse2.png" width="45%"> <img src="ch03/./image/mouse/mouse3.png" width="45%"></p>
<h2 id="roving-origin"><a class="header" href="#roving-origin">Roving Origin</a></h2>
<p>Originの位置を、視点の移動とともに追従するかそうでないかを設定します。デフォルトはONです。Originとは回転操作を行いたいときの回転中心のことです。Originの位置は任意の選択範囲に対してActionパネルから<code>Origin</code>を選ぶことで設定できます。これがONのとき、視点を平行移動（<a href="ch03/../ch02/mouse.html#%E4%B8%A6%E9%80%B2-move">マウス操作のMove</a>参照）させてもOriginの位置が画面に対して同じ位置に留まるよう更新されますが、OFFにすると視点を平行移動させてもOrigin位置を自動で更新しなくなります。
この効果は、PyMOL上で分子を画面の端っこに置いた状態で設定値を変えて視点の変更しようとすると分かりやすいと思います。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/roving.mp4" type="video/mp4">
</video>
<p>コマンドからは<code>set roving_origin, (value)</code>で変更できます。<code>0</code>がOFF, <code>1</code>がONです。</p>
<h1 id="wizard"><a class="header" href="#wizard">Wizard</a></h1>
<p>Wizardは複雑な操作をユーザーとの対話形式で行えるようにしてくれるためのツール群です。Wizardには以下の種類が用意されており、選択することでInternal GUI画面にマウスで操作できるメニューが現れます。特に、<strong>Mutagenesis</strong>と<strong>Density</strong>のWizardは重宝することでしょう。</p>
<h2 id="appearance"><a class="header" href="#appearance">Appearance</a></h2>
<h2 id="measurement"><a class="header" href="#measurement">Measurement</a></h2>
<h2 id="mutagenesis"><a class="header" href="#mutagenesis">Mutagenesis</a></h2>
<p>タンパク質の任意のアミノ酸の場所にアミノ酸点変異を導入したモデルを作成してくれます。実験科学者が「もしここに変異を入れたら隣り合うアミノ酸と干渉するだろうか？」ということを簡単に試してみたり、計算科学者が点変異を加えたタンパク質の分子動力学シミュレーションの初期座標として用いたりすることができます。また各アミノ酸にはrotamerと呼ばれる、エネルギー的に安定ないくつかのコンフォメーションのライブラリが内蔵されている上、周囲のアミノ酸の座標を検知した上で最もエネルギー的に安定なrotamerを自動的に選択してくれます。</p>
<p>詳細は第5章で。</p>
<h2 id="pair-fitting"><a class="header" href="#pair-fitting">Pair Fitting</a></h2>
<h2 id="density"><a class="header" href="#density">Density</a></h2>
<p>タンパク質の構造決定法がX線結晶構造解析法, 中性子回折法, クライオ電子顕微鏡によるものだった場合、その電子密度を表示させることができます。</p>
<h2 id="filter"><a class="header" href="#filter">Filter</a></h2>
<h2 id="sculpting-1"><a class="header" href="#sculpting-1">Sculpting</a></h2>
<h2 id="label"><a class="header" href="#label">Label</a></h2>
<h2 id="charge"><a class="header" href="#charge">Charge</a></h2>
<h2 id="demo"><a class="header" href="#demo">Demo</a></h2>
<h1 id="plugin"><a class="header" href="#plugin">Plugin</a></h1>
<h1 id="help"><a class="header" href="#help">help</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file-1"><a class="header" href="#file-1">File</a></h1>
<img src="ch03/./image/file/filemenu.png" width="30%">
<h2 id="new-pymol-window-1"><a class="header" href="#new-pymol-window-1">New PyMOL Window</a></h2>
<p><strong>新しくPyMOLのウィンドウを別に立ち上げることができます</strong>。ある構造ファイルを開いている時にまったく別の構造ファイルを開く必要があるときには、このNew PyMOL Windowを使って立ち上げると良いでしょう。一方で類似構造のファイルと比較したいという場合には、新しいPyMOL Windowを開かずに1つのPyMOLウィンドウの中で開くと、構造比較する上で便利です。</p>
<p><code>Default</code>では新しいPyMOL Windowを開くと同時に、ユーザー独自の初期設定ファイルである<code>.pymolrc</code>（存在する場合）とインストールしたプラグインをともに読み込んでくれます。</p>
<p><code>ignore .pymolrc and plugins (-k)</code>の方では、この機能を無効にし、PyMOLのインストール時の初期設定のまま利用できるようになります。ターミナルから<code>pymol -k</code>で起動した場合と同じ効果です。</p>
<h2 id="open-2"><a class="header" href="#open-2">Open...</a></h2>
<p>構造ファイルを読み込むことができます。これを選択すると読み込みたいファイルを選択する画面に移行します。ロード可能な構造ファイルを選択することでInternal GUIのViewer部分に構造が表示されます。</p>
<h2 id="open-recent-1"><a class="header" href="#open-recent-1">Open Recent...</a></h2>
<p>最近ロードしたことのある構造ファイルの履歴を表示しています。ここから構造ファイルをロードすることも可能です。</p>
<h2 id="get-pdb-1"><a class="header" href="#get-pdb-1">Get PDB...</a></h2>
<p>PDBに登録されている構造ファイルや電子密度ファイルのIDを指定することで、インターネットから直接ダウンロードして開くことができます。これはまずこのメニューを選択すると次のような別メニューが開きます。</p>
<img src="ch03/../ch02/image/load/bunit3.png" width="30%">
<p>PDB IDのところにデータベースのIDを入力します。また、下の方にはPDB Structure Optionsが存在し、chain nameの箇所で表示したいChainを指定できます。A chainのみを表示したい場合はAを入力します（指定しない場合はすべて表示されます）。</p>
<p>その構造ファイルに固有のAssemblyを考慮した表示も可能となっています。Biological assemblyを考慮して表示させたい場合は<code>1</code>を、非対称ユニットをロードしたい場合は何も指定しないでおきます。これについては第2章の<a href="ch03/../ch02/loadmol.html">分子構造のロード</a>のページも参考にしてください。</p>
<p>構造ファイルはworking directory上にダウンロードされます。デフォルトの構造ファイル形式は<code>mmCIF</code>となっています。working directoryについては<a href="ch03/file.html#Working-Directory">こちら</a>も参照してください。</p>
<h2 id="save-session--save-session-as-1"><a class="header" href="#save-session--save-session-as-1">Save Session &amp; Save Session as...</a></h2>
<p><strong>現在開いている表示状態をセッションファイルに保存します</strong>。ショートカットキーは<code>Ctrl-SまたはCommand + S</code>です。スライド作成や論文のために生体分子の表示形式を保存しておくととても便利なので、ぜひこの機能は活用していきましょう。</p>
<p><code>Save Session</code>はいわゆる「上書き保存」と同じで、<code>Save Session as...</code>は「ファイル名を指定して保存」と同じ機能です。一度もセッションファイルを作成していない状態で<code>Save Session</code>を押すと自動的に「ファイル名を指定して保存」に切り替わります。</p>
<p>拡張子はPyMOL Session File（<code>.pse</code>）とPyMOL Show File（<code>.psw</code>）の2つを選ぶことができます。<code>pse</code>ファイル形式で保存すると、再びこのファイルを開いたときにPyMOLの作業状態をそのまま復元するのに対し、<code>psw</code>ファイル形式で保存した場合は、このファイルを開くと全画面表示＋Internal GUIとExternal GUIが表示されない状態で開かれます。つまり、pswファイルは編集用というよりは完全に表示用に向いています。</p>
<img src="ch03/../ch03/image/file/psw.png" width="30%">
<p>pswファイルを開いたときの例。Internal GUIとExternal GUIが表示されません。</p>
<p>一応、この状態からでも上部メニューの[Display] -&gt; [Internal GUI]と[External GUI] -&gt; [Visible]をクリックすればいつものGUIが表示されるようになるので覚えておくと良いでしょう。</p>
<h2 id="export-molecule-1"><a class="header" href="#export-molecule-1">Export molecule...</a></h2>
<p>現在画面上に開いている生体分子オブジェクトをファイルとして出力します。詳細は<a href="ch03/../ch02/export.html">第2章 構造ファイルのエクスポート</a> を御覧ください。</p>
<h2 id="export-map-1"><a class="header" href="#export-map-1">Export map...</a></h2>
<p><code>.ccp4</code>などの電子密度マップなどを出力します。電子密度マップについては<a href="ch03/../ch05/xtal_elecmap.html">第5章 結晶構造の電子密度マップを表示する</a>などで参照してください。マップオブジェクトがロードされた状態で選択すると以下のようなダイアログが現れます。</p>
<img src="ch03/../ch03/image/file/savemap.png" width="30%">
<p>保存したいマップオブジェクトを選びSaveボタンを押してファイル名を入力することで保存されます。デフォルト拡張子は<code>.ccp4</code>です。</p>
<h2 id="export-alignment-1"><a class="header" href="#export-alignment-1">Export alignment...</a></h2>
<p>この機能を利用するためには類似のタンパク質間での<strong>アライメントオブジェクト</strong>を生成しておく必要があります。アライメントオブジェクトについては<a href="ch03/../ch04/cmd_super.html">第4章 オブジェクトの重ね合わせ</a>を参照してください。</p>
<h2 id="export-image-as-1"><a class="header" href="#export-image-as-1">Export Image As...</a></h2>
<p>画像を保存するだけでなく、3Dモデリングへの出力にも対応しています。</p>
<h3 id="png-1"><a class="header" href="#png-1">PNG...</a></h3>
<p>PNG形式の画像を保存することができます。これについての詳細は第2章の<a href="ch03/../ch02/saveimage.html">画像の保存</a>を参照してください。</p>
<h3 id="vrml-2-1"><a class="header" href="#vrml-2-1">VRML 2...</a></h3>
<p>表示しているモデルをwireframe/VRMLの形式で座標情報をエクスポートすることができます。mesh表示やSurface表示にも対応しています。
タンパク質の3Dプリンタでの出力のときに利用できますが、PyMOLだけでなく他のソフトウェアとの様々な工程を経る必要があるため、詳細はここでは割愛します。</p>
<p>クオリティを上げたい場合は、以下のオプションを利用すると良いそうです。</p>
<pre><code>set surface_quality, 1
set cartoon_sampling, 20
</code></pre>
<h3 id="collada-1"><a class="header" href="#collada-1">COLLADA...</a></h3>
<p>COLLADAというXMLベースのオープン3Dグラフィック形式で出力することができます。PyMOLのcartoon, stick, line, sphere, surfaceなどのスタンダードな表示形式に対応して出力することができます。PyMOL 1.7.3.2から正式実装されました。拡張子は<code>.dae</code>です。</p>
<p>上記VRML 2の後発ですが、こちらの形式で出力して3Dプリンタ出力やBlenderなどでの編集も行えるようになるかもしれません。PyMOL 2.4からはglTF (GL Transmission Format)という形式でも出力できるようになるそうです。VRML 2のときのクオリティオプションコマンドも利用できます。</p>
<h3 id="pov-ray-1"><a class="header" href="#pov-ray-1">POV-Ray...</a></h3>
<p><a href="http://www.povray.org/">POV-Ray</a>で読み込めるように拡張子<code>.pov</code>で出力します。</p>
<h2 id="export-movie-as-1"><a class="header" href="#export-movie-as-1">Export Movie As...</a></h2>
<p>動画を出力することができます。</p>
<h3 id="mpeg-1"><a class="header" href="#mpeg-1">MPEG...</a></h3>
<h3 id="quick-time-1"><a class="header" href="#quick-time-1">Quick time...</a></h3>
<h3 id="png-images-1"><a class="header" href="#png-images-1">PNG Images...</a></h3>
<h2 id="log-file-1"><a class="header" href="#log-file-1">Log File</a></h2>
<p>PyMOLで操作記録を取ることができます。</p>
<h3 id="open-3"><a class="header" href="#open-3">Open...</a></h3>
<h3 id="resume-1"><a class="header" href="#resume-1">Resume...</a></h3>
<h3 id="append-2"><a class="header" href="#append-2">Append...</a></h3>
<h3 id="close-1"><a class="header" href="#close-1">Close</a></h3>
<h2 id="run-script-1"><a class="header" href="#run-script-1">Run Script...</a></h2>
<h2 id="working-directory-1"><a class="header" href="#working-directory-1">Working Directory</a></h2>
<p>作業ディレクトリのパスを変更します。macOSでアプリケーションからPyMOLを起動させた場合、デフォルトの作業ディレクトリ(以降wd)はホームディレクトリ、ターミナルからコマンドでPyMOLを起動させた場合には、そのターミナル上での作業ディレクトリになっています。</p>
<p><a href="ch03/file.html#Get-PDB...">Get PDB...</a>を利用する場合など、ファイルの読み込み・書き出しは、この作業ディレクトリのパスを基準に考慮する必要があります。Linuxまたはターミナルの操作に慣れている方にとっては言うまでもない概念でしょう。</p>
<p>PyMOLのコマンドラインからは<code>cd</code>コマンドを使うことで変更することができます。</p>
<pre><code># Working Directoryをデスクトップに設定する
# (Linux, macOSの場合)
cd ~/Desktop
</code></pre>
<h2 id="edit-pymolrc-1"><a class="header" href="#edit-pymolrc-1">Edit pymolrc</a></h2>
<p>PyMOLを起動したときに自動的に実行される設定である<code>pymolrc</code>ファイルを編集することができます。bash, zshで言うところの<code>.bashrc</code>, <code>.zshrc</code>と同様に、<code>pymolrc</code>に設定を書き込んでおけば、描画に関する設定やPATH設定などを上書きしておくことができます。macOS, Linuxの場合は<code>pymolrc</code>ファイルはホームディレクトリ上に生成されます。</p>
<img src="ch03/./image/file/editpymolrc.png" width="80%">
<pre><code>set sphere_scale, .22
set sphere_scale, .13, elem H
set dash_gap, 0
set dash_gap, .15
set dash_length, .05
set dash_round_ends, 0
set dash_radius, .05
set label_size, 18
set cartoon_loop_radius, 0.1
set cartoon_putty_radius, 0.2
set cartoon_oval_length, 0.8
set label_digits, 3
set ray_opaque_background, 0
set dash_length, 0.2500
set cartoon_gap_cutoff, 0
</code></pre>
<p>設定はPyMOLコマンド形式で記述する必要があります。</p>
<h2 id="reinitialize-1"><a class="header" href="#reinitialize-1">Reinitialize</a></h2>
<p>Reinitializeはその名の通りPyMOLを再初期化してくれます。表示されているオブジェクトを含め再起動したかのようにしてくれるEverythingと、設定値だけを再起動するもののsettings系のどちらかを選ぶことができます。</p>
<h3 id="everything-1"><a class="header" href="#everything-1">Everything</a></h3>
<p>Everythingを選ぶと、PyMOLで現在開いているすべての生体分子オブジェクトは消去され、完全にPyMOLを再起動したような状態になります。<strong>それまで保存していなかった作業内容も予告内容なしに消えてしまう</strong>ので、慎重にこのボタンを押してください。</p>
<h3 id="original-settings-1"><a class="header" href="#original-settings-1">Original Settings</a></h3>
<p>これらのOriginal Settings, Stored Settingsのメニューでは、現在表示されている生体分子オブジェクトは消去されません。こちらで再初期化してくれるのは<strong>PyMOLの描画の設定値</strong>です。例えばPyMOLのヘリックスの描画の太さ(<code>set cartoon_oval_length, 0.8</code>)やループの太さ(<code>set cartoon_loop_radius, 0.1</code>)、ミッシング領域の描画の有無(<code>set cartoon_gap_cutoff, 0</code>)……などといった、PyMOLの描画全体に影響を及ぼす値を初期値に修正した状態で再び描画し直してくれるのがこの<code>Original Settings</code>です。</p>
<p>上の<code>Edit pymolrc</code>で描画設定を変更していた場合でも、この<code>Original Settings</code>を押すとPyMOL内部の設定値で上書きされてしまうので注意してください。</p>
<h3 id="stored-settings-1"><a class="header" href="#stored-settings-1">Stored Settings</a></h3>
<p>保存しておいた描画の設定値を呼び出してくれます。これは下記の<code>Store Current Settings</code>の機能と対応しています。</p>
<h3 id="store-current-settings-1"><a class="header" href="#store-current-settings-1">Store Current Settings</a></h3>
<p>現在の描画の設定値を保存しておいてくれます。これを一度しておけば、以降PyMOLのプログラムを終了するまで上記の<code>Stored Settings</code>からその設定値を呼び出すことができます。</p>
<p>これら<code>Reinitialize</code>についてPyMOLのコマンドラインから行う場合は以下の通りです。</p>
<pre><code>reinitialize [ what [, object ]]
</code></pre>
<p>whatには<code>everything</code>または<code>settings</code>が入ります。settings部分には<code>settings</code>, <code>original_settings</code>, <code>stored_settings</code>が選べるようです。defaultはeverything。
objectにはオブジェクト名を入れることができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="edit-1"><a class="header" href="#edit-1">Edit</a></h1>
<p>主にUndo, Redo機能を取り扱います。注意していただきたいのは、この機能は主に<a href="ch03/./build.html">3.3 Build</a>で<strong>原子の座標に変更を加えたもの</strong>に対してのみ適用される仕様であり、<strong>分子のカラーリングや視点の変更、表示形式の変更</strong>には対応していません。</p>
<h2 id="undo-ctrl-z-1"><a class="header" href="#undo-ctrl-z-1">Undo [Ctrl-Z]</a></h2>
<p>Buildメニューから行った原子の座標変更や原子＆結合の生成・消去についての操作を取り消すことができます。ショートカットキーはCtrl（Macの方はCommandでも可）-Zの同時押しです。下記の&quot;Max Atom Count for Undo/Redo&quot;で設定した値までは何度も操作を取り消すことができます。</p>
<h2 id="redo-ctrl-y-1"><a class="header" href="#redo-ctrl-y-1">Redo [Ctrl-Y]</a></h2>
<p>Undoで取り消した操作を再び呼び戻すことができます。ショートカットキーはCtrl（Macの方はCommandでも可）-Yの同時押しです。</p>
<h2 id="max-atom-count-for-undoredo-1"><a class="header" href="#max-atom-count-for-undoredo-1">Max Atom Count for Undo/Redo</a></h2>
<p>Undo/Redoで戻せる操作の数を設定できます。デフォルトでは1000となっています。設定値は他に10000, 100000のほか、Unlimited（制限なし）やDisable Undo(実質0)を選ぶことができます。設定値を超えた分の操作は消去され、呼び出すことができなくなります。</p>
<p>一見無制限が良いように思えますが、PyMOLを動かしているマシンのメモリをオーバーして保存しようとするとPyMOLがクラッシュしてしまいます。現実的には1000で問題ないと思います。</p>
<p>コマンドは<code>set suspend_undo_atom_count, 1000</code>です。<code>1000</code>の部分は任意のint値を入れることができます。</p>
<h2 id="auto-copy-images-1"><a class="header" href="#auto-copy-images-1">Auto-Copy Images</a></h2>
<p>PyMOL 1.8には遅くとも実装されていたようですが、Incentive版のPyMOL 2.1から全プラットフォームで実装されたようです。マニュアルによれば</p>
<blockquote>
<p>auto_copy_images (boolean, default: on) controls whether or not PyMOL automatically copies images from the OpenGL viewport into the system’s clipboard.</p>
</blockquote>
<p>とあるのですが、使い方がよくわかりませんでした。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="build-1"><a class="header" href="#build-1">Build</a></h1>
<p>Buildのメニューからは、PyMOLに内蔵されている化合物のフラグメントやアミノ酸残基のデータを利用して任意の化合物またはポリペプチド鎖の構造モデルを生成することができるようになっています。主な利用方法としては、既存のタンパク質構造をロードしたあとに、その末端に長い人工ペプチドを取り付けたモデル構造を作成することや、0から任意のポリペプチド鎖を作成して計算科学の研究の初期構造に利用するという使い方があります。</p>
<p>Buildメニューは以下の通りです。</p>
<img src="ch03/./image/build/ch3_build1.png" width="40%" height="40%">
<h2 id="fragment-1"><a class="header" href="#fragment-1">Fragment</a></h2>
<p>ここでは主要な化学小分子の骨格を、フラグメントをつなぎ合わせるような感覚で構築することができます。使い方の例を動画で見てみましょう。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/build/fragment1.mp4" type="video/mp4">
</video>
<p>このように、何もない状態から様々な化学骨格を持った分子を作っていくことができます。……ただ、結構癖があって、任意に小分子を作るというのには慣れが必要で、構造最適化部分も含めて他のソフトウェアを使った方がいいような気もします。</p>
<p>やり方としては、まずこのFragmentメニューからベースとなる化合物骨格を選んできます（しかしこの時点でベンゼン環がないので結構アレなんですけれど……。）
その後、マウスのPkAt機能（参考：<a href="ch03/../ch02/buttonaction.html#%E5%8E%9F%E5%AD%90%E3%83%94%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0pkatpk1">マウス操作の詳細,原子ピッキング</a>）を使って原子を1つピッキングした状態にします。この状態でさらにFragmentメニューからフラグメントを選ぶと、そのピックされた原子部分に選択された化学骨格が生えていきます。これを繰り返していくことで、任意の化合物を作ることが理論上可能です。</p>
<p>化合物の二面角や角度を手動で調整したい場合は、マウス操作で調節して作り出してください（参考：<a href="ch03/../ch02/buttonaction.html#%E4%BA%8C%E9%9D%A2%E8%A7%92%E3%82%92%E3%83%94%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0pktb">マウス操作の詳細,二面角をピッキング</a>）。また、一応お気持ち程度ですが、後で紹介する<strong>Sculpting</strong>という機能を使うと、簡単な化合物の構造最適化をかけてくれて、無理のない構造に落ち着かせることができます。</p>
<h2 id="residue-1"><a class="header" href="#residue-1">Residue</a></h2>
<p>このメニューは20種類の正準アミノ酸の残基のデータの他に、N末端キャッピング用のAcetylとC末端キャッピング用のN-Methylが存在しています。キャッピングとはMDシミュレーション上で使われる人工的な修飾で、末端部分の電荷をニュートラルにするために使われます。それ以外の方はあまり利用することがないでしょう。</p>
<p>AltキーとA~Zの文字を組み合わせて入力することでマウスを使わずに簡単にポリペプチド鎖を作成していくことができます。例えば、PyMOLを開き、BuildメニューからResidue -&gt; Helixを選び、Internal GUI画面上でAltキーを押しながら<code>ACDVAARHK</code>と連続して押すと</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/build/residue1.mp4" type="video/mp4">
</video>
<p>このようにαヘリックス様のタンパク質フラグメントが簡単に生成されました。同様にして、antiparallel, parallelのβシート構造も作り出すことができます。ただしループ構造は自動で生成してくれませんので、手動で任意の二面角を調節して作り出してください。（参考：<a href="ch03/../ch02/buttonaction.html#%E4%BA%8C%E9%9D%A2%E8%A7%92%E3%82%92%E3%83%94%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0pktb">マウス操作の詳細,二面角をピッキング</a>）</p>
<p>また、プログラミングしたいときに便利な点として、<code>cmd._alt(chr(XX))</code>を入力することでそのキーを入力した扱いにすることができます。XXにはASCII CODEが入ります（A: 65, B: 66, C: 67, ... 88: X, Y: 89, Z: 90）。</p>
<table><thead><tr><th align="left">表示</th><th align="center">残基名</th><th align="center">cmd</th><th align="left">ショートカットキー</th></tr></thead><tbody>
<tr><td align="left">Acetyl</td><td align="center">アセチル基</td><td align="center"><code>cmd._alt(chr(66))</code></td><td align="left">Alt-B</td></tr>
<tr><td align="left">Alanine</td><td align="center">アラニン</td><td align="center"><code>cmd._alt(chr(65))</code></td><td align="left">Alt-A</td></tr>
<tr><td align="left">Amine</td><td align="center">アミン</td><td align="center">-</td><td align="left"></td></tr>
<tr><td align="left">Aspartate</td><td align="center">アスパラギン酸</td><td align="center"><code>cmd._alt(chr(68))</code></td><td align="left">Alt-D</td></tr>
<tr><td align="left">Asparagine</td><td align="center">アスパラギン</td><td align="center"><code>cmd._alt(chr(78))</code></td><td align="left">Alt-N</td></tr>
<tr><td align="left">Arginine</td><td align="center">アルギニン</td><td align="center"><code>cmd._alt(chr(82))</code></td><td align="left">Alt-R</td></tr>
<tr><td align="left">Cysteine</td><td align="center">システイン</td><td align="center"><code>cmd._alt(chr(67))</code></td><td align="left">Alt-C</td></tr>
<tr><td align="left">Glutamate</td><td align="center">グルタミン酸</td><td align="center"><code>cmd._alt(chr(69))</code></td><td align="left">Alt-E</td></tr>
<tr><td align="left">Glutamine</td><td align="center">グルタミン</td><td align="center"><code>cmd._alt(chr(81))</code></td><td align="left">Alt-Q</td></tr>
<tr><td align="left">Glycine</td><td align="center">グリシン</td><td align="center"><code>cmd._alt(chr(71))</code></td><td align="left">Alt-G</td></tr>
<tr><td align="left">Histidine</td><td align="center">ヒスチジン</td><td align="center"><code>cmd._alt(chr(72))</code></td><td align="left">Alt-H</td></tr>
<tr><td align="left">Isoleucine</td><td align="center">イソロイシン</td><td align="center"><code>cmd._alt(chr(73))</code></td><td align="left">Alt-I</td></tr>
<tr><td align="left">Leucine</td><td align="center">ロイシン</td><td align="center"><code>cmd._alt(chr(76))</code></td><td align="left">Alt-L</td></tr>
<tr><td align="left">Lysine</td><td align="center">リジン</td><td align="center"><code>cmd._alt(chr(75))</code></td><td align="left">Alt-K</td></tr>
<tr><td align="left">Methionine</td><td align="center">メチオニン</td><td align="center"><code>cmd._alt(chr(77))</code></td><td align="left">Alt-M</td></tr>
<tr><td align="left">N-Methyl</td><td align="center">N-メチル</td><td align="center"><code>cmd._alt(chr(90))</code></td><td align="left">Alt-Z</td></tr>
<tr><td align="left">Phenylalanine</td><td align="center">フェニルアラニン</td><td align="center"><code>cmd._alt(chr(70))</code></td><td align="left">Alt-F</td></tr>
<tr><td align="left">Proline</td><td align="center">プロリン</td><td align="center"><code>cmd._alt(chr(80))</code></td><td align="left">Alt-P</td></tr>
<tr><td align="left">Serine</td><td align="center">セリン</td><td align="center"><code>cmd._alt(chr(83))</code></td><td align="left">Alt-S</td></tr>
<tr><td align="left">Threonine</td><td align="center">スレオニン</td><td align="center"><code>cmd._alt(chr(84))</code></td><td align="left">Alt-T</td></tr>
<tr><td align="left">Tryptophan</td><td align="center">トリプトファン</td><td align="center"><code>cmd._alt(chr(87))</code></td><td align="left">Alt-W</td></tr>
<tr><td align="left">Tyrosine</td><td align="center">チロシン</td><td align="center"><code>cmd._alt(chr(89))</code></td><td align="left">Alt-Y</td></tr>
<tr><td align="left">Valine</td><td align="center">バリン</td><td align="center"><code>cmd._alt(chr(86))</code></td><td align="left">Alt-V</td></tr>
</tbody></table>
<h2 id="sculpting-2"><a class="header" href="#sculpting-2">Sculpting</a></h2>
<p>Sculptingは「彫刻する」というような意味ですが、PyMOLのこの機能では、上で生成したような小分子またはポリペプチド鎖について<strong>簡単な構造最適化</strong>をかけてくれるようです。</p>
<p>ただし、この機能は現在PyMOLの開発者としてはサポートの対象外とされているようで、現時点ではこの機能が改善されることや発見されたバグの修正が行われることはないとされています（参考：<a href="https://pymol.org/dokuwiki/doku.php?id=unsupported">PyMOL: Unsupported Features</a>）。したがって、ここでは簡単な使い方の紹介を留める程度にしておきます。</p>
<p>まずSculptingメニューの先にあるサブメニューの2段めにあるSculptingにチェックを入れます（この操作はコマンドで<code>set sculpting, on</code>とすることでもできます）。そしてその下にあるactivateをクリックすると、表示されている分子の構造最適化が自動的に始まります。ただし、この操作は画面に表示されている分子に対して行われてしまうことに注意してください。コマンドでは<code>sculpt_activate all</code> とします。途中で止めたい場合は<code>sculpt_deactivate all</code>と入力します。<code>all</code>の部分を生体分子のオブジェクト名にすればその分子のみを構造最適化させることができます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/build/sculpting1.mp4" type="video/mp4">
</video>
<h2 id="cycle-bond-valence-ctrl-shift-w-1"><a class="header" href="#cycle-bond-valence-ctrl-shift-w-1">Cycle Bond Valence [Ctrl-Shift-W]</a></h2>
<p>現在選択中の「結合」に対して、その結合を芳香環のような結合として設定させます。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Wの同時押しです。</p>
<p>結合を選択する方法は<a href="ch03/../ch02/buttonaction.html#%E4%BA%8C%E9%9D%A2%E8%A7%92%E3%82%92%E3%83%94%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0pktb">マウス操作の詳細,二面角をピッキング</a>と同じです。この機能で結合を選択したあと、Ctrl-Shift-Wキーを同時押しすることで、その結合が芳香環様結合として設定させることができます。例えばFragmentメニューに存在するCyclohexyl[Alt-6]にこの機能を適用してベンゼン環に変更したいという場合、6つすべての炭素-炭素結合についてこの操作を行う必要があります。このとき水素原子は自動で増減します。こののち、上記のSculptingによる構造最適化を行えばすべての炭素原子が同一平面上に位置するようになったベンゼン環構造が得られます（が、水素原子の位置がきれいな構造じゃない気がします）。</p>
<h2 id="fill-hydrogens-on-pk1-ctrl-shift-r-1"><a class="header" href="#fill-hydrogens-on-pk1-ctrl-shift-r-1">Fill Hydrogens on (Pk1) [Ctrl-Shift-R]</a></h2>
<p>Pk1で選択されている「原子」に対して、その原子につながっている結合数に応じて水素原子を取り付けてくれます。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Rの同時押しです。コマンドは<code>h_fill</code>です。</p>
<h2 id="invert-pk2-pk1-pk3-ctrl-shift-e-1"><a class="header" href="#invert-pk2-pk1-pk3-ctrl-shift-e-1">invert (pk2)-(pk1)-(pk3) [Ctrl-Shift-E]</a></h2>
<p>PkAt機能で原子を3つ選んだ状態、すなわちPk1, Pk2, Pk3が存在している状態でこのコマンドを選択すると、Pk1から先のフラグメントがPk1-Pk2軸回りに180度反転した位置に変化します。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Eの同時押しです。コマンドは<code>invert</code>です。</p>
<h2 id="create-bond-pk1-pk2-ctrl-shift-t-1"><a class="header" href="#create-bond-pk1-pk2-ctrl-shift-t-1">create bond (pk1)-(pk2) [Ctrl-Shift-T]</a></h2>
<p>PkAt機能で原子を2つ選んだ状態、すなわちPk1, Pk2が存在する状態でこのコマンドを選択すると、2原子の間に結合が形成されます。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Tの同時押しです。内部コマンドの処理としては<code>bond ; unpick</code>が働いています。</p>
<p>これは環を閉じたいときに有用だったり、描画上の問題で離れている2原子を結合したような状態に見せたいときに有用です。</p>
<p>ちなみにコマンド専用ですが、bondコマンドを使うときに<code>bond order=2</code>とすると二重結合として結合を表示させられます。三重結合のときは<code>bond order=3</code>、芳香環様結合のときは<code>bond order=4</code>とします。</p>
<h2 id="remove-pk1-ctrl-shift-d-1"><a class="header" href="#remove-pk1-ctrl-shift-d-1">Remove (pk1) [Ctrl-Shift-D]</a></h2>
<p>Pk1で選択されている原子を削除します。また、PkTbで選択されている結合についても削除することができます。ショートカットキーはCtrl（Macの場合はCommandでも可）とShift-Dの同時押しです。コマンドは<code>remove_picked</code>です。</p>
<h2 id="make-pk1-positive-ctrl-shift-k--make-pk1-negative-ctrl-shift-j--make-pk1-neurtral-ctrl-shift-u-1"><a class="header" href="#make-pk1-positive-ctrl-shift-k--make-pk1-negative-ctrl-shift-j--make-pk1-neurtral-ctrl-shift-u-1">Make (Pk1) positive [Ctrl-Shift-K] / Make (Pk1) negative [Ctrl-Shift-J] / Make (Pk1) neurtral [Ctrl-Shift-U]</a></h2>
<p>Pk1で選択されている原子の電荷を+1, -1, 0にそれぞれ設定させることができます。設定値はLabel機能のother properties, formal chargeを押すと確認することができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="movie"><a class="header" href="#movie">Movie</a></h2>
<img src="ch03/./image/movie/moviemenu.png" width="30%">
<p>PyMOLのMovie機能を使うことでカメラまたは分子自体の動き・表示に時限式のプログラムを施し、分子を様々な角度から映すことができるようになります。</p>
<h3 id="append-3"><a class="header" href="#append-3">Append</a></h3>
<p>この機能は指定した秒数分の<strong>フレーム</strong>を確保するのに使います。メニュー上では<code>0.25</code>〜<code>60</code> secondの延長が可能です。このとき、設定されている<a href="ch03/movie.html#FPS">FPS</a>の値（後述）に応じて延長されるフレーム数が増加します。つまり、30FPSに設定されているときに2 second延長しようとすると、60フレーム分追加されることになります。</p>
<p>コマンドでは、60フレーム分の枠を確保する場合には<code>mset 1x60</code>のような形で入力します。この60フレームは30FPSに設定しているときですと2秒に相当します。</p>
<hr>
<h3 id="program"><a class="header" href="#program">Program</a></h3>
<p>ムービーに登録する動きのプログラミングを行います。視点を変更する（つまり分子自体の座標は変化しない）<strong>Camera Loop</strong>, 登録しておいたScene（<a href="ch03/scene.html">Scene</a>のページを参照）の入れ替えを制御する<strong>Scene Loop</strong>, 表示された分子オブジェクトにstateがある状態（NMR構造やMDシミュレーションの動きのデータが入ったオブジェクトなど）での動きの再生を行う<strong>State Loop</strong>, Stateをすべて再生した後に逆再生を行う<strong>State Sweep</strong>が用意されています。</p>
<p>Program機能を使うと、PyMOLの画面下にFrameのインジケータが出現します。これを<strong>ムービーパネル</strong>と呼びます。ここには現在どのフレームにいるか、そのフレームにカメラが設定されているかどうかを示す小さなアイコンが表示されます。</p>
<p>以下に示す動きのプログラムは複数連結させることも可能で、Camera Loop Nutate の後に State Loopを行い、Camera Loop X-Rockを行う……という設定にすることも可能です。</p>
<h4 id="camera-loop"><a class="header" href="#camera-loop">Camera Loop</a></h4>
<p>カメラ視点を制御するメニューです。中には<strong>Nutate</strong>, <strong>X-Rock</strong>, <strong>X-Roll</strong>, <strong>Y-Rock</strong>, <strong>Y-Roll</strong>のメニューがあります。それぞれどういった動きをするものなのかを以下で紹介していきます。</p>
<h5 id="nutate"><a class="header" href="#nutate">Nutate</a></h5>
<p>Nutateは<a href="https://ja.wikipedia.org/wiki/%E7%AB%A0%E5%8B%95">章動</a>のことで、物体の回転運動において、歳差運動をする回転軸の動きの短周期で微小な成分を指します。以下の動画のようなカメラの動きを行います。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/cameranutate1.mp4" type="video/mp4">
</video>
<p>GUIメニューからは動きの秒数と歳差運動の角度をいくつか選ぶことができます。
コマンドでは<code>movie.add_nutate(4,15,start=1)</code>となっています（4秒間、角度15度設定の場合）。<code>start=</code>の値にはこのプログラムを付け加えるFrameの開始番号を入力します。</p>
<h5 id="x-rock-y-rock"><a class="header" href="#x-rock-y-rock">X-Rock, Y-Rock</a></h5>
<p>X-Rock, Y-Rockは画面\(x\)軸または\(y\)軸に対してカメラ角度を指定した値の範囲分だけ傾ける運動を繰り返します。以下の動画のようなカメラの動きを行います。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/xrock1.mp4" type="video/mp4">
</video>
<p>コマンドでは<code>movie.add_rock(2,30,axis='x',start=1)</code>となっています（2秒間、角度30度、\(x\)軸rock設定の場合）。<code>start=</code>の値にはこのプログラムを付け加えるFrameの開始番号を入力します。</p>
<h5 id="x-roll-y-roll"><a class="header" href="#x-roll-y-roll">X-Roll, Y-Roll</a></h5>
<p>X-Roll, Y-Rollは画面\(x\)軸または\(y\)軸に、指定された時間で1周して戻ってくるように回転させます。以下の動画のようなカメラの動きを行います。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/xroll1.mp4" type="video/mp4">
</video>
<p>コマンドでは<code>movie.add_roll(4.0,axis='x',start=1)</code>となっています（4秒間、\(x\)軸回転設定の場合）。<code>start=</code>の値にはこのプログラムを付け加えるFrameの開始番号を入力します。</p>
<h4 id="scene-loop"><a class="header" href="#scene-loop">Scene Loop</a></h4>
<p>この機能を使うためには、<a href="ch03/./scene.html">Scene機能</a>によっていくつかのSceneを事前に用意しておく必要があります。このScene間でカメラの動きをシームレスにつなげてムービーパネルに登録してくれます。</p>
<p>下の動画の例では先にF1, F2, F3の3つのSceneが登録された状態で示しています。</p>
<h5 id="nutate-1"><a class="header" href="#nutate-1">nutate</a></h5>
<p>登録されているSceneを順番に移動しながら、各Sceneについて指定した秒数分のnutateを行っていきます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/scenenutate1.mp4" type="video/mp4">
</video>
<p>コマンドでは<code>set sweep_angle 30; cmd.movie.add_scenes(None, 2, rock=4, start=1)</code>となっています（角度30度、2秒間動作、nutate設定の場合）。<code>start=</code>の値にはこのプログラムを付け加えるFrameの開始番号を入力します。</p>
<h5 id="x-rock-y-rock-1"><a class="header" href="#x-rock-y-rock-1">X-Rock, Y-Rock</a></h5>
<p>登録されているSceneを順番に移動しながら、各Sceneについて指定した秒数分のX-Rock/Y-Rockを行っていきます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/scenexrock1.mp4" type="video/mp4">
</video>
<p>コマンドでは<code>set sweep_angle 30; cmd.movie.add_scenes(None, 2, rock=2, start=1)</code>となっています（角度30度、2秒間動作、\(x\)軸Rockの場合）。\(y\)軸Rockの場合は<code>rock=1</code>に設定します。<code>start=</code>の値にはこのプログラムを付け加えるFrameの開始番号を入力します。</p>
<h5 id="steady"><a class="header" href="#steady">Steady</a></h5>
<p>登録されているSceneを順番に移動しながら、各Sceneについて指定した秒数分だけ静止します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/scenesteady1.mp4" type="video/mp4">
</video>
<p>コマンドでは<code>cmd.movie.add_scenes(None, 1.0, rock=0, start=1)</code>となっています（角度30度、1秒間静止の場合）。</p>
<h4 id="state-loop"><a class="header" href="#state-loop">State Loop</a></h4>
<p>この機能を使うためには、すでに1つ以上のロード済みの生体分子オブジェクトに複数のStateが入っている状態である必要があります。PDBに登録されている構造のうち、NMRで構造が決定されたものはたいてい複数のStateが入っていますが、結晶構造には通常複数のStateは入っていません。または、MDシミュレーションのトラジェクトリデータをロードすることで、複数のStateをもたせることもできます。</p>
<p>以下の例ではNMRで構造決定された<a href="https://www.rcsb.org/structure/1G03">PDB: 1G03</a>の構造オブジェクトを利用しています。State loop機能は、このState間での動きをムービーパネルに登録してくれます。</p>
<p>State Loopは全Stateを順に再生します。<code>n second pause</code>で停止時間を指定した場合、Stateの再生前、再生後に指定した時間分の停止フレームが設定されます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/stateloop1.mp4" type="video/mp4">
</video>
<p>コマンドでは<code>movie.add_state_loop(n, m, start=1)</code>です（1/<em>n</em>倍速、<em>m</em>秒pauseを挟む場合）。動画では1倍速、1秒pause設定にしています。<code>start=</code>の値にはこのプログラムを付け加えるFrameの開始番号を入力します。</p>
<h4 id="state-sweep"><a class="header" href="#state-sweep">State Sweep</a></h4>
<p>この機能もStateが複数ある構造オブジェクトがロードされていることを前提としています。全Stateを順に再生させて最後のStateまで到達した後、Stateを逆再生します。<code>n second pause</code>で停止時間を指定した場合、最後のstateに到達した後に逆再生を始めるまでと、最初と最後にもそれぞれ停止フレームが設定されます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/statesweep1.mp4" type="video/mp4">
</video>
<p>コマンドでは<code>movie.add_state_sweep(n, m, start=1)</code>です（1/<em>n</em>倍速、<em>m</em>秒pauseを挟む場合）。動画では1/2倍速、1秒pause設定にしています。<code>start=</code>の値にはこのプログラムを付け加えるFrameの開始番号を入力します。</p>
<h3 id="update-last-program"><a class="header" href="#update-last-program">Update last program</a></h3>
<p><strong>最後にGUIメニューから行った</strong>動作プログラムを再実行させます。コマンドでプログラムしたものはこの<code>Update last program</code>を押しても再実行されないので注意してください。</p>
<h3 id="remove-last-program"><a class="header" href="#remove-last-program">Remove last program</a></h3>
<p><strong>最後にGUIメニューから行った</strong>動作プログラムを削除することができます。コマンドからプログラムしたものについては無効のようです。</p>
<h3 id="reset"><a class="header" href="#reset">Reset</a></h3>
<p>作成しているすべてのMovieのフレーム情報をすべて消去します。コマンドは<code>mset; rewind</code>です。</p>
<hr>
<h3 id="frame-rate"><a class="header" href="#frame-rate">Frame Rate</a></h3>
<p>1秒あたりの動き（フレーム）の数に関する設定です。</p>
<h4 id="fps"><a class="header" href="#fps">FPS</a></h4>
<p>Frame per second(FPS, 1秒あたりのフレーム)を設定します。デフォルトは<code>30</code>FPSに設定されており、1秒あたり最大で30枚の静止画像数（いわゆる「コマ」）を処理するようになっています。GUIからは<code>30</code>, <code>15</code>, <code>5</code>, <code>1</code>, <code>0.3</code>を選べるようになっていますが、コマンドからは任意の値を設定できます。</p>
<p>動画として後々出力し他の方に見せる場合、FPSの値は配信するマシン環境やネットワークなどによっても上限を制限されるので、現実的には<code>30</code>が主流の値、よくて<code>60</code>FPSです。</p>
<p>コマンドでは<code>set movie_fps, (value)</code>です。<code>(value)</code>にはFPSのfloat値を入力します（デフォルトでは<code>30</code>）。</p>
<h4 id="input-typecheckbox-show-frame-rate"><a class="header" href="#input-typecheckbox-show-frame-rate"><input type="checkbox"> Show Frame Rate</a></h4>
<p>Internal GUIの右下部分の再生ボタンの上に、Frame Rateが表示されるようになります。デフォルトでは<code>OFF</code>です。</p>
<p>コマンドでは<code>set show_frame_rate, (value)</code>です。<code>(value)</code>の部分は<code>1</code>, <code>0</code>を指定でき, <code>1</code>でON, <code>0</code>でOFFとなります。(value)の部分に<code>on</code>, <code>off</code>と入れても有効です。</p>
<h4 id="reset-meter"><a class="header" href="#reset-meter">Reset meter</a></h4>
<p>コマンドは<code>meter_reset</code>で、PyMOLのドキュメントによれば</p>
<blockquote>
<p><strong>meter_reset</strong> resets the frames per second counter.</p>
</blockquote>
<p>とのこと。Show Frame RateをONにした状態でこのボタンを押すとHzの数字が現在の値にアップデートされる。実際には表示形式の変更などの内部処理時に自動的に呼び出されているくらいで、人間が明示的に使う機会はあまりなさそう。</p>
<hr>
<h3 id="input-typecheckbox-checked-auto-interpolate"><a class="header" href="#input-typecheckbox-checked-auto-interpolate"><input type="checkbox" checked> Auto Interpolate</a></h3>
<p>プログラム動作を指定するタイミングのフレーム（<strong>キーフレーム</strong>と呼びます）が新たに設定されたときに、その前後のカメラの動きを自動的に補間してくれます。デフォルトでは<code>ON</code>です。</p>
<p>この機能は上記のようなGUIによるキーフレームの設定を使っているときにはすでに補間が働いていることもあって、あまり効果をなしません。コマンドベースでムービーのプログラミングを行っているときには効果がよくわかります。</p>
<p>例として以下のムービー作成コマンドを、Auto InterpolateがONのときとOFFのときで比較してみます。</p>
<pre><code>fetch 1rx1, async=0
as cartoon
as sticks, organic
mset 1x70
orient
mview store, 1
mview store, 70
orient organic
mview store, 30
mview store, 40
mplay
</code></pre>
<p>これはタンパク質1rx1をロードし、<code>mset 1x70</code>で70フレーム分の枠を用意した後、1フレームめと70フレームめにはタンパク質全体の様子を見せる<code>orient</code>の状態でキーフレームを設定し、30フレームめと40フレームめでは<code>orient organic</code>によってリガンド部分にズームした状態のキーフレームを設定しています。</p>
<p>Auto Interpolateが<code>on</code>の場合は以下のような動画が作られます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/autoinp1.mp4" type="video/mp4">
</video>
<p>Auto Interpolateが<code>off</code>の場合は以下のようになります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/autoinp2.mp4" type="video/mp4">
</video>
<p>このように動きを設定したフレーム間でのカメラの補間が働いていないことがわかります。</p>
<p>コマンドは<code>set movie_auto_interpolate, on</code>または<code>off</code>です。</p>
<h3 id="input-typecheckbox-checked-show-panel"><a class="header" href="#input-typecheckbox-checked-show-panel"><input type="checkbox" checked> Show Panel</a></h3>
<p>ムービーパネルの表示・非表示を設定します。コマンドでは<code>set movie_panel, 1</code>で表示となります（<code>0</code>で非表示）。デフォルトでは<code>1</code>になっています。</p>
<h3 id="input-typecheckbox-checked-loop-frames"><a class="header" href="#input-typecheckbox-checked-loop-frames"><input type="checkbox" checked> Loop Frames</a></h3>
<p>ムービーを構成するフレームが再生し終わったときに自動的にループして再生するか、それとも停止するかを設定できます。コマンドでは<code>set movie_loop, 1</code>でループ再生となります（<code>0</code>で停止）。デフォルトでは<code>1</code>になっています。</p>
<h3 id="input-typecheckboxdraw-frames"><a class="header" href="#input-typecheckboxdraw-frames"><input type="checkbox">Draw Frames</a></h3>
<p>このオプションにチェックを入れておくと、各フレームを再生する時に<code>draw</code>によるややきれいな画像レンダリングが行われるようになります。<code>ray</code>よりはとても動作が軽い一方、<code>set ray_opaque_background, 0</code>を使った背景の透明化などはできないようです。</p>
<p>コマンドでは<code>set draw_frames, 1</code>でdraw描画がONになります（<code>0</code>で解除）。デフォルトでは<code>0</code>になっています。</p>
<h3 id="input-typecheckboxray-trace-frames"><a class="header" href="#input-typecheckboxray-trace-frames"><input type="checkbox">Ray Trace Frames</a></h3>
<p>このオプションにチェックを入れておくと、各フレームを再生する時に<code>ray</code>によるレイトレーシングが行われるようになります。1フレームごとにきれいな画像が出力されるので、後に動画ファイルとして出力する場合に利用できますが、反面1フレームごとの再生速度が極端に低下するので普段チェックを入れておくことはおすすめしません。</p>
<p>コマンドでは<code>set ray_trace_frames, 1</code>でレイトレーシングがONになります（<code>0</code>で解除）。デフォルトでは<code>0</code>になっています。</p>
<h3 id="input-typecheckboxcache-frame-images"><a class="header" href="#input-typecheckboxcache-frame-images"><input type="checkbox">Cache Frame Images</a></h3>
<p>このオプションにチェックを入れておくと、各フレームの画像がメモリに保存されるようになります。メモリに保存されると2回め以降のループ再生時の再計算が必要なくなり、表示が早くなります。ただし、画像をキャッシュすると表示サイズやフレーム数に応じて膨大な量のメモリを消費するので、少なくともこのオプションを使う前に表示画像サイズをコントロールする<code>viewport</code>コマンドでウィンドウを縮小しておくことを勧めます。</p>
<p>コマンドでは<code>set cache_frames, 1</code>でキャッシュが<code>ON</code>になります（<code>0</code>で解除）。デフォルトでは<code>0</code>になっています。</p>
<h3 id="clear-image-cache"><a class="header" href="#clear-image-cache">Clear Image Cache</a></h3>
<p>キャッシュされた画像情報をクリアしてメモリを開放します。<code>Cache Frame Images</code>にチェックを入れていなければ自動的にキャッシュが溜まることはないので使う必要はありません。コマンドでは<code>mclear</code>です。</p>
<hr>
<h3 id="input-typecheckbox-checked-static-singletons"><a class="header" href="#input-typecheckbox-checked-static-singletons"><input type="checkbox" checked> Static Singletons</a></h3>
<p>このオプションにチェックを入れておくと、PyMOLでロードされたオブジェクトが複数あり、かつ複数stateを持つオブジェクト（PDB: 1G03など）と1 stateしか存在しないオブジェクトがあったときに、再生ボタンを押してstate 2以降になった場合でも、その1 stateしか持っていないオブジェクトも画面上に表示され続けます。チェックがOFFだと、その1 stateのオブジェクトは表示されなくなります。</p>
<p>コマンドでは<code>set static_singletons, 1</code>で1 stateのオブジェクトの表示を許可します（<code>0</code>で表示しなくなります）。デフォルトでは<code>1</code>になっています。</p>
<h3 id="input-typecheckbox-show-all-states"><a class="header" href="#input-typecheckbox-show-all-states"><input type="checkbox"> Show All States</a></h3>
<p>このオプションにチェックを入れておくと、ロードしたオブジェクトに複数のStateが存在する場合に全Stateが表示されるようになります。</p>
<img src="ch03/./image/movie/allstates.png">
<p>コマンドでは<code>set all_states, 1</code>で全state表示が<code>ON</code>になります（<code>0</code>で解除）。デフォルトでは<code>0</code>になっています。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="display"><a class="header" href="#display">Display</a></h2>
<img src="ch03/./image/display/seqmenu.png" width="30%">
<h3 id="input-typecheckbox-sequence"><a class="header" href="#input-typecheckbox-sequence"><input type="checkbox"> Sequence</a></h3>
<p>Viewer上に表示されている生体分子オブジェクトの配列を表示します。デフォルトでは<code>OFF</code>になっています。</p>
<img src="ch03/./image/display/seq1.png" width="50%" height="50%">
<p>配列情報はViewer上部に表示されます。複数オブジェクトが存在する場合でも、まとめて表示することが可能です。また、この機能のON/OFFは画面右下の<code>S</code>ボタンを押すことでも可能です。コマンドは<code>set seq_view, 0/1</code>です（<code>0</code>でOFF, <code>1</code>でON）。</p>
<h3 id="sequence-mode"><a class="header" href="#sequence-mode">Sequence Mode</a></h3>
<p>次に示す5つの選択メニューは配列情報自体の表示の変更に関わる設定です。いずれか1つのみ同時に設定できます。</p>
<h4 id="input-typecheckbox-checkedchecked-residue-codes"><a class="header" href="#input-typecheckbox-checkedchecked-residue-codes"><input type="checkbox" checked="checked"> Residue Codes</a></h4>
<img src="ch03/./image/display/seqdisp_1.png">
<p>タンパク質アミノ酸を<strong>1文字表記</strong>で表示します。核酸の場合は<code>DG</code>, <code>DA</code>といった表記になります。デフォルトではこの設定がONになっています。コマンドは<code>set seq_view_format, 0</code>です。</p>
<h4 id="input-typecheckbox-residue-names"><a class="header" href="#input-typecheckbox-residue-names"><input type="checkbox"> Residue Names</a></h4>
<img src="ch03/./image/display/seqdisp_2.png">
<p>タンパク質アミノ酸を<strong>3文字表記</strong>で表示します。核酸の場合は<code>DG</code>, <code>DA</code>のままで特に変化しません。コマンドは<code>set seq_view_format, 1</code>です。</p>
<h4 id="input-typecheckbox-chain-identifiers"><a class="header" href="#input-typecheckbox-chain-identifiers"><input type="checkbox"> Chain Identifiers</a></h4>
<img src="ch03/./image/display/seqdisp_3.png">
<p>Chain識別子（A鎖、B鎖……）で表示します。コマンドは<code>set seq_view_format, 3</code>です。</p>
<h4 id="input-typecheckbox-atom-names"><a class="header" href="#input-typecheckbox-atom-names"><input type="checkbox"> Atom Names</a></h4>
<img src="ch03/./image/display/seqdisp_4.png">
<p>各アミノ酸残基または核酸塩基をさらに細分化し、原子名単位で表示することができます。特に、ある特定の場所の原子名を持つ原子だけを選択したいというときに、<strong>Selecting</strong>（マウスクリック時の選択単位）を<strong>Atoms</strong>に変更することと組み合わせることで簡単に選択するできるので重宝します。コマンドは<code>set seq_view_format, 2</code>です。</p>
<h4 id="input-typecheckbox-states"><a class="header" href="#input-typecheckbox-states"><input type="checkbox"> States</a></h4>
<img src="ch03/./image/display/seqdisp_5.png">
<p>State番号を表示します。上の例では<code>1NMR</code>オブジェクトはNMRで構造解析されたデータであり、20 states存在するオブジェクトです。<code>2iteA</code>と<code>1bnaA</code>はともに結晶構造解析のデータであり、通常1 Stateのみになっています。コマンドは<code>set seq_view_format, 4</code>です。</p>
<hr>
<p>次に示す4つの選択メニューは、配列表示欄の表示方法に関わる設定です。いずれか1つのみ同時に設定できます。例として、上記の<strong>Residue Codes</strong>表示をONにした場合の設定を掲載しています。</p>
<h4 id="input-typecheckbox-checkedchecked-all-residue-numbers"><a class="header" href="#input-typecheckbox-checkedchecked-all-residue-numbers"><input type="checkbox" checked="checked"> All Residue Numbers</a></h4>
<img src="ch03/./image/display/seqdisp_6.png">
<p>全てのオブジェクトについての配列番号を表示します。コマンドは<code>set seq_view_label_mode, 2</code>です。</p>
<h4 id="input-typecheckbox-top-sequence-only"><a class="header" href="#input-typecheckbox-top-sequence-only"><input type="checkbox"> Top Sequence Only</a></h4>
<img src="ch03/./image/display/seqdisp_7.png">
<p>配列番号の表示を一番上のオブジェクトのもののみに限定します。同じオブジェクトを複数ロードしている場合には便利ですが、そうでない場合にしようすると、残基番号の位置を誤ってしまうことになるので、利用しないことが推奨されます。コマンドは<code>set seq_view_label_mode, 1</code>です。</p>
<h4 id="input-typecheckbox-object-names-only"><a class="header" href="#input-typecheckbox-object-names-only"><input type="checkbox"> Object Names Only</a></h4>
<img src="ch03/./image/display/seqdisp_8.png">
<p>配列番号をすべて隠し、オブジェクト名だけを左端に表示します。コマンドは<code>set seq_view_label_mode, 0</code>です。</p>
<h4 id="input-typecheckbox-no-labels"><a class="header" href="#input-typecheckbox-no-labels"><input type="checkbox"> No Labels</a></h4>
<img src="ch03/./image/display/seqdisp_9.png">
<p>配列番号、オブジェクト名いずれも非表示にし、配列情報のみを表示します。
コマンドは<code>set seq_view_label_mode, 3</code>です。</p>
<hr>
<p>以下の3つのメニューは、配列情報中に存在するミッシング残基についてのギャップマーク<code>-</code>の表示・非表示を設定します。いずれか1つのみ同時に設定できます。表示しているオブジェクト中にミッシング残基が存在しない場合はどれを選んでも表示に影響はありません。この機能はver. 2.3.0で実装されました。</p>
<p>ここでは例としてミッシング残基が存在するPDB: 2xwu、pdbフォーマットを表示して紹介します。Chain Bの153-155残基がミッシングになっています。</p>
<h4 id="input-typecheckbox-no-gaps"><a class="header" href="#input-typecheckbox-no-gaps"><input type="checkbox"> No Gaps</a></h4>
<img src="ch03/./image/display/seqdisp_10.png">
<p>ギャップマークを非表示にします。
コマンドは<code>set seq_view_gap_mode, 0</code>です。</p>
<h4 id="input-typecheckbox-checkedchecked-all-gaps"><a class="header" href="#input-typecheckbox-checkedchecked-all-gaps"><input type="checkbox" checked="checked"> All Gaps</a></h4>
<img src="ch03/./image/display/seqdisp_11.png">
<p>ギャップマークをすべて表示します。コマンドは<code>set seq_view_gap_mode, 1</code>です。</p>
<h4 id="input-typecheckbox-single-gap"><a class="header" href="#input-typecheckbox-single-gap"><input type="checkbox"> Single Gap</a></h4>
<img src="ch03/./image/display/seqdisp_12.png">
<p>連続したミッシング残基がある場合、その箇所に付きギャップマークを1つだけ表示します。コマンドは<code>set seq_view_gap_mode, 2</code>です。</p>
<h3 id="input-typecheckbox-checkedchecked-internal-gui"><a class="header" href="#input-typecheckbox-checkedchecked-internal-gui"><input type="checkbox" checked="checked"> Internal GUI</a></h3>
<p>Internal GUIの表示のON/OFFを切り替えます。OFFにすると以下のようにInternal GUIが非表示になります。デフォルトではONになっています。</p>
<img src="ch03/./image/display/seqdisp_13.png">
<p>コマンドは<code>set internal_gui, 0/1</code>です（<code>0</code>でOFF, <code>1</code>でON）。</p>
<h3 id="input-typecheckbox-checkedchecked-internal-prompt"><a class="header" href="#input-typecheckbox-checkedchecked-internal-prompt"><input type="checkbox" checked="checked"> Internal Prompt</a></h3>
<p>Internal Promptの表示のON/OFFを切り替えます。Internal PromptとはPyMOL画面の下側に存在する入力欄です。</p>
<img src="ch03/./image/display/seqdisp_14.png">
<p>External GUIで入力する入力欄と実質的に機能は同じですが、ヒストリー機能（入力欄でキーボードの上キーを押すと過去に入力したコマンドを参照できる機能）は各入力欄で独立になっています。デフォルトではONになっています。コマンドは<code>set internal_prompt, 0/1</code>です（<code>0</code>でOFF, <code>1</code>でON）。</p>
<h3 id="internal-feedback"><a class="header" href="#internal-feedback">Internal Feedback</a></h3>
<p>Internal Feedbackでは、入力欄に入力したコマンドの結果を表示する行の数を設定できます。メニューからは<code>0</code>,<code>1</code>,<code>3</code>,<code>5</code>から選べるようになっています。デフォルトでは<code>1</code>となっています。例えば、<code>5</code>に設定すると以下の画像のようにViewerの下に5行までログが表示されるようになります。</p>
<img src="ch03/./image/display/seqdisp_15.png">
<p>入力欄はInternal Prompt、External GUIのどちらに入力しても同じようにコマンドの結果を表示します。</p>
<p>コマンドは<code>set internal_feedback, (val)</code>です。<code>(val)</code>には<code>0</code>,<code>1</code>,<code>3</code>,<code>5</code>を含む、任意の正の整数値を設定できます。</p>
<h3 id="overlay"><a class="header" href="#overlay">Overlay</a></h3>
<p>Overlayは、先程のInternal Feedbackの結果をViewer上に重ねて表示する行数の設定値です。メニューからは<code>0</code>,<code>1</code>,<code>3</code>,<code>5</code>から選べるようになっています。デフォルトでは<code>0</code>となっています。例えば<code>5</code>に設定すると以下の画像のようにViewerの下に5行まで結果を重ねて表示するようになります。</p>
<img src="ch03/./image/display/seqdisp_16.png">
<p>コマンドは<code>set overlay, (val)</code>です。<code>(val)</code>には<code>0</code>,<code>1</code>,<code>3</code>,<code>5</code>を含む、任意の正の整数値を設定できます。</p>
<hr>
<h3 id="input-typecheckbox-stereo"><a class="header" href="#input-typecheckbox-stereo"><input type="checkbox"> Stereo</a></h3>
<p>Stereoを選択すると、現在設定されている<strong>ステレオモード</strong>に移行します。ステレオモードは分子を立体的に見るために便利なモードです。</p>
<p>これを選択すると対応したステレオモードで分子が表示されるようになります。デフォルトではCross-Eye Stereoモードに設定されているので、左右に分かれて表示されるようになります。</p>
<ul>
<li>
<p>ステレオモード選択前<br><img src="ch03/./image/display/stereo1.png"></p>
</li>
<li>
<p>ステレオモード選択後（Cross-Eye Stereoモード）<br><img src="ch03/./image/display/stereo2.png"></p>
</li>
</ul>
<p>このモードを使うことで、論文などで時々見かける立体視の図を簡単に作ることができます。</p>
<p>コマンドは<code>stereo, 0/1</code>です（<code>0</code>でOFF, <code>1</code>でON）。</p>
<h3 id="stereo-mode"><a class="header" href="#stereo-mode">Stereo Mode</a></h3>
<h4 id="anaglyph-stereo"><a class="header" href="#anaglyph-stereo">Anaglyph Stereo</a></h4>
<img src="ch03/./image/display/stereo3.png">
<p>anaglyphモードは、一般的には左目に赤セロファン、右目に青セロファンを通したときに立体的に浮かび上がるような図への出力を行うモードです。いわゆる「赤青メガネ」を着用する状態で見ることを前提とする表示方法です。</p>
<p>コマンドは<code>stereo anaglyph</code>です。</p>
<h4 id="cross-eye-stereo"><a class="header" href="#cross-eye-stereo">Cross-Eye Stereo</a></h4>
<img src="ch03/./image/display/stereo2.png">
<p>交差法による立体視用の図を出力するモードです。コマンドは<code>stereo crosseye</code>です。</p>
<h4 id="wall-eye-stereo"><a class="header" href="#wall-eye-stereo">Wall-Eye Stereo</a></h4>
<img src="ch03/./image/display/stereo4.png">
<p>Wall-Eyeによる立体視用の図を出力するモードです。コマンドは<code>stereo walleye</code>です。</p>
<h4 id="quad-buffered-stereo"><a class="header" href="#quad-buffered-stereo">Quad-Buffered Stereo</a></h4>
<p>Quad-Buffered stereo 3Dを利用した画面表示を行うモードです。しかし、この機能はお使いのパソコン（GPU）とモニター、OSが適切に対応している場合のみ利用できるようです。また、現行のMacおよびmacOSについてはこの機能を利用することができないようです。詳細は https://pymolwiki.org/index.php/Stereo_3D_Display_Options のページを御覧ください。</p>
<p>コマンドは<code>stereo quadbuffer</code>です。</p>
<h4 id="zalman-stereo"><a class="header" href="#zalman-stereo">Zalman Stereo</a></h4>
<img src="ch03/./image/display/stereo5.png">
<p>この機能は<strong>ZALMAN社製の3Dモニター製品を利用している場合のみ</strong>効果を発揮します。この3Dモニターを使っているときであれば、立体視の訓練をしなくても上記の画像が立体的に見えるように表示されます。しかし、それ以外のモニターを使っているときには立体的に見えないので効果を実感することができません。コマンドは<code>stereo byrow</code>です。</p>
<h4 id="openvr"><a class="header" href="#openvr">OpenVR</a></h4>
<p>OpenVRは2019年6月頃から有志によって追加された機能であり、現在試験運用段階にあるようです。動作の様子は https://www.youtube.com/watch?v=kEKA1HnR9GM などで見ることができます。</p>
<p>この機能はOpenVRに依存しているため、Homebrew, LinuxbrewでインストールしたOpensource版PyMOLで利用することはできず、anacondaか公式バイナリをインストールしたときでのみ利用可能です。また、OSもWindows, Linuxに対応しているがmacOSで動作させることができるかは現時点で不明です。また、VR自体が規格の統一やプラットフォーム競争の最中にあるため、本格的な利用はまだ先でしょうか。</p>
<p>コマンドは<code>stereo openvr</code>です。</p>
<hr>
<h4 id="swap-sides"><a class="header" href="#swap-sides">Swap Sides</a></h4>
<p>Cross-Eye StereoまたはWall-Eye StereoをONにしているときにこの機能を利用すると、Internal GUI上に表示されている立体視用の画像が入れ替わります。コマンドは<code>stereo swap</code>です。</p>
<hr>
<h4 id="chromadepth"><a class="header" href="#chromadepth">Chromadepth</a></h4>
<img src="ch03/./image/display/stereo6.png">
chromadepthモードは、画面に対する奥行きに対して自動的に色付けが変わる表示形式です。このモードにした状態で分子を回転させると、常に画面手前側が赤く、画面奥側が青色になるようにカラーリングが変化します。
<p>コマンドは<code>stereo chromadepth</code>です。</p>
<hr>
<h4 id="off"><a class="header" href="#off">off</a></h4>
<p>ステレオモードをオフにします。コマンドは<code>stereo, off</code>です。</p>
<hr>
<h3 id="zoom"><a class="header" href="#zoom">Zoom</a></h3>
<p>ZoomによってInternal GUI上に表示する分子を拡大するよう視点を変更します。<code>x Angstrom sphere</code>をクリックすると、<code>x</code>の値に応じて表示される範囲が変化します。<code>All</code>では全オブジェクトが表示されるように自動的に視点を変更します。<code>complete</code>を利用すると、範囲全体がortoscopic viewに収まるようになります。</p>
<p>コマンドでは<code>zoom [ selection [,buffer [, state=0 [, complete=0 ]]]]</code>です。<code>complete</code>を利用する場合は<code>1</code>を指定します。</p>
<h3 id="clip"><a class="header" href="#clip">Clip</a></h3>
<p>Clipの値を設定します。詳細は<a href="ch03/../ch02/index.html#%E3%82%AF%E3%83%AA%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0clip.html">第2章 2.4.3 操作の詳細 クリッピング</a>を御覧ください。</p>
<hr>
<h3 id="background"><a class="header" href="#background">Background</a></h3>
<p>生体分子が表示されているViewer部分の背景について設定することができます。デフォルトでは黒背景になっています。</p>
<h4 id="input-typecheckbox-opaque"><a class="header" href="#input-typecheckbox-opaque"><input type="checkbox"> Opaque</a></h4>
<p>PyMOL Viewerの背景の不透明について設定します。この不透明設定がONの場合、設定された背景色に従って描画されます。この設定がOFFの場合、背景は透明に描画されます。デフォルトではOFFになっています。コマンドは<code>set opaque_background, 0/1</code>です。</p>
<p>……というのが本来の機能のようですが、<strong>実際には機能しておらず、常にONになっているようです</strong>。すなわち、背景は常に何かしらの色で塗られており、透明にすることはできないようです。もし背景を透過した画像を保存したい場合は、この代わりに<code>set ray_opaque_background, 0</code>とした上で<code>ray</code>コマンドを使い、その上で画像を保存することになります。</p>
<h4 id="input-typecheckbox-checkedchecked-alpha-checker"><a class="header" href="#input-typecheckbox-checkedchecked-alpha-checker"><input type="checkbox" checked="checked"> Alpha Checker</a></h4>
<p>背景色が透過状態になっている場合に、透明な市松模様を表示させるか否かを設定します。デフォルトではONになっており、この状態で<code>set ray_opaque_background, 0</code>とした上で<code>ray</code>コマンドを入力すると、その表示を確認することができます。</p>
<img src="ch03/./image/display/alphachecker.png">
<p>この表示の状態で画像を保存すると、背景が透過された状態になっています。</p>
<hr>
<h4 id="white--light-grey--grey--black"><a class="header" href="#white--light-grey--grey--black">White / Light Grey / Grey / Black</a></h4>
<p>背景色を選択できます。デフォルトではBlackに設定されているため、通常は黒背景の中に生体分子が表示されます。この4つの選択肢は同時にいずれかの1つのみ適用されます。</p>
<p>Whiteに設定すると背景が白となるので、画像出力時に利用できます。</p>
<p>コマンドでは<code>set bg_rgb, [white|grey80|grey50|black|]</code>です。</p>
<h3 id="color-space"><a class="header" href="#color-space">Color Space</a></h3>
<p>色空間を設定します。選択肢として<strong>CMYK (for publications)</strong>, <strong>PyMOL (for video + web)</strong>, <strong>RGB (default)<strong>があります。デフォルトは</strong>RGB</strong>です。</p>
<p><strong>一般に、コンピュータのモニター上ではRGB色空間で色を表現しているのに対し、印刷物上ではCMYK色空間で色が表現されています。</strong> 詳細は<a href="https://ja.wikipedia.org/wiki/%E8%89%B2%E7%A9%BA%E9%96%93">Wikipediaの色空間の記事</a>をご覧ください。このため、原理的にモニター上で見える色と論文やポスター上などに印刷された色は異なってしまいます。この2つの色空間は非等価であり、特定のRGB色をCMYK空間で表現することができず、逆にRGBで作成した画像をCMYKに変換すると、紫がかった青や黄緑がかった色になってしまいます。その結果、RGBで作成された分子グラフィックス画像をCMYKに変換すると、青みがかった紫や緑が黄色くなってしまうことがよくあります。そこで、あらかじめ<code>space cmyk</code>によって色空間をCMYKに強制させておくと、画像編集ソフト（例えばAdobe Photoshop）で確実にCMYKに変換できる色のサブセットに制限することができます。このため、画面上に表示されるものは、印刷で得られるものにかなり近いものになります。</p>
<p>一方で、アナログビデオシステムや<a href="https://ja.wikipedia.org/wiki/YUV">YUV色空間</a>に基づくデジタルビデオ圧縮コーデックにもRGBとの非互換性があります。通常、過飽和色が最も問題となります。PyMOL には &quot;space yuv&quot; がありませんが、<code>space pymol</code>を使うことで、アニメーションをビデオにエクスポートする際に、過飽和色の問題を回避することができます。</p>
<p>まとめると、<strong>紙面上への印刷を意識した図を作成する場合はCMYKを、モニター上でのみ表示する図や動画の作成では、PyMOLまたはRGBを利用すると良いでしょう</strong>。</p>
<p>コマンドは<code>space, [cmyk|pymol|rgb]</code>です。</p>
<h3 id="quality"><a class="header" href="#quality">Quality</a></h3>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<hr>
<h3 id="input-typecheckbox-orthoscopic-view"><a class="header" href="#input-typecheckbox-orthoscopic-view"><input type="checkbox"> Orthoscopic View</a></h3>
<p>Orthoscopic ViewをONにすると、遠近感(perspective)の効果をなしにすることができます。デフォルトのPyMOLの表示は遠近感を自動的に考慮した表示になっており、奥行きを自然に感じられるようになっていますが、その機能を停止させることができます。</p>
<p>次のような一方向に長いPDB: 3AEHのchain Aを使って例を示します。<br>
<img src="ch03/./image/display/3aeh.png" width="50%"></p>
<p>このタンパク質を90°横から見て、Orthoscopic ViewをOFFにしている場合（左）とONにしている場合（右）の比較です<br>
<img src="ch03/./image/display/ortho0.png" width="40%"><img src="ch03/./image/display/ortho1.png" width="40%"></p>
<p>Orthoscopic ViewをOFFにしている場合、βバレル（βシートによる樽みたいな）構造やαヘリックスについて視差がうまれているため奥行きがわかりやすいですが、ONにしていると奥行きが少しわからなくなっている感じがします。</p>
<p>球状タンパク質のほうな等方的な分子ではこの効果を実感することは少ないですが、上記のように、異方性の高いタンパク質でのみこのような違いを実感することができます。</p>
<h3 id="input-typecheckbox-checkedchecked-show-valences"><a class="header" href="#input-typecheckbox-checkedchecked-show-valences"><input type="checkbox" checked="checked"> Show Valences</a></h3>
<h3 id="input-typecheckbox-checkedchecked-smooth-lines"><a class="header" href="#input-typecheckbox-checkedchecked-smooth-lines"><input type="checkbox" checked="checked"> Smooth Lines</a></h3>
<h3 id="input-typecheckbox-checkedchecked-depth-cue-fogging"><a class="header" href="#input-typecheckbox-checkedchecked-depth-cue-fogging"><input type="checkbox" checked="checked"> Depth Cue (Fogging)</a></h3>
<h3 id="input-typecheckbox-checkedchecked-two-sided-lighting"><a class="header" href="#input-typecheckbox-checkedchecked-two-sided-lighting"><input type="checkbox" checked="checked"> Two Sided Lighting</a></h3>
<h3 id="input-typecheckbox-checkedchecked-specular-reflections"><a class="header" href="#input-typecheckbox-checkedchecked-specular-reflections"><input type="checkbox" checked="checked"> Specular Reflections</a></h3>
<h3 id="input-typecheckbox-checkedchecked-animation"><a class="header" href="#input-typecheckbox-checkedchecked-animation"><input type="checkbox" checked="checked"> Animation</a></h3>
<h3 id="input-typecheckbox-roving-detail"><a class="header" href="#input-typecheckbox-roving-detail"><input type="checkbox"> Roving Detail</a></h3>
<hr>
<h3 id="external-gui"><a class="header" href="#external-gui">External GUI</a></h3>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="setting-1"><a class="header" href="#setting-1">Setting</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="scene-1"><a class="header" href="#scene-1">Scene</a></h1>
<img src="ch03/./image/scene/scenemenu.png" width="200px">
<p><strong>Externalメニューに存在するScene機能は論文・ポスター発表や動画作成の時にとても重宝します</strong>。PyMOLに表示したタンパク質の構造を色んな角度から撮影したり、色んなカラーリングや設定値を試したり、それらをつなげて動画にまとめて出力したいという試行錯誤は、読み手に分かりやすい論文・ポスター用の図を作成する上で必要な作業だと思われます。そんなとき、1つの作業セッションファイル中に複数の表示状態を保存することができるこの<strong>Scene</strong>機能をぜひ活用しましょう。</p>
<video controls autoplay loop>
<source src="./image/scene/scene1.mp4" type="video/mp4">
</video>
<p>この動画で示しているように、左下に<code>001</code>, <code>002</code>, <code>003</code>という小さなボタンが現れています。ここをクリックすることで、<strong>前もって保存しておいたカメラ角度(view/camera)、色使い(color)、表示形式（rep/representations）に戻って表示させる</strong>ことができます。</p>
<p>このボタンはSceneの<code>append</code>または<code>Store</code>機能によって生成することができます。内容を上書きするには<code>Update</code>を、削除するには<code>Delete</code>を用います。<code>Recall</code>, <code>Store</code>, <code>Clear</code>の3つは、<code>Append</code>, <code>Delete</code>の使い方に似ていますが、キーボードのF1〜F12を使ったショートカットキーと自動的に結びつけてくれるため使い勝手が良くなります。</p>
<p><strong>Sceneボタンをマウスでクリックして白くなっているときを<code>active</code>状態と呼びます。</strong></p>
<h2 id="next-pgdn--previous-pgup-1"><a class="header" href="#next-pgdn--previous-pgup-1">Next [PgDn] / Previous [PgUp]</a></h2>
<p>すでに複数のSceneボタンが存在しているときに動作します。Nextで次の、Previousで前のSceneを表示させることができます。Next, Previousはそれぞれキーボードの[PgDn], [PgUp]ボタンにショートカットキーが割り当てられているので、マウスを使わずにSceneを切り替えることができます。</p>
<hr>
<h2 id="append-4"><a class="header" href="#append-4">Append</a></h2>
<p><strong>現在の表示状態をSceneに追加します</strong>。デフォルトではSceneオブジェクト名は自動的に<code>001</code>からの連番になります。</p>
<p>内部処理としては、コマンドで<code>scene new, store</code>が作動します。<code>new</code>は自動的に連番のIDを割り振ります。<code>new</code>以外の文字を入力すると、そのオブジェクト名でSceneが生成されます。</p>
<h3 id="append-camera-color-reps-repscolor-1"><a class="header" href="#append-camera-color-reps-repscolor-1">Append (Camera, Color, Reps, Reps+Color)</a></h3>
<p>Camera (view), Color, Repsはそれぞれ撮影角度、表示されている分子のカラーリング、表示された分子の表示形式を表しています。上述の<code>Append</code>ではこれらをすべて保存してSceneに登録するのに対して、こちらのサブメニューではその一部のみをSceneに登録します。</p>
<p>内部処理としては、コマンドで<code>scene new, store, view=0/1, color=0/1, rep=0/1</code>としており、<code>0</code>
のとき各情報を保存しない、<code>1</code>のときに情報を保存する、としています。</p>
<h2 id="insert-before--after-1"><a class="header" href="#insert-before--after-1">Insert Before / After</a></h2>
<p>現在表示している画面の状態のScene登録を、現在ActiveになっているSceneの上(before)または下(after)に登録させます。これによって、上述の Next [PgDn] / Previous [PgUp] との円滑な連携を図ることができます。</p>
<p>内部処理としては、コマンドで<code>scene &lt;scene_name&gt;, insert_before/insert_after</code>としています。</p>
<h2 id="update-1"><a class="header" href="#update-1">Update</a></h2>
<p>現在表示している画面の状態を、ActiveになっているSceneボタンの上に上書きします。内部処理としては、コマンドで<code>scene &lt;scene_name&gt;, update</code>としています。</p>
<hr>
<h2 id="delete-1"><a class="header" href="#delete-1">Delete</a></h2>
<p>現在ActiveになっているSceneボタンを削除します。内部処理としては、コマンドで<code>scene &lt;scene_name&gt;, clear</code>としています。</p>
<hr>
<h2 id="recall-1"><a class="header" href="#recall-1">Recall</a></h2>
<p>下記の<code>Store</code>で保存されたSceneを呼び出すことができます。
上で見たような連番のSceneボタンと異なり、F1〜F12ボタンと自動的に結びつけて操作することが可能です。例えば、<code>F1</code>でStoreされたSceneをF1キーを押すだけで呼び出すことができます。</p>
<h2 id="store-1"><a class="header" href="#store-1">Store</a></h2>
<p>F1〜F12ボタンと自動的に結びつけられたSceneボタンを生成することができます。使い方は<code>Append</code>と似ています。</p>
<p><strong>Windows/Linuxの場合はCtrlキーと, macOSの場合はCommandキーとF1〜F12とすることで現在表示されている画面をSceneに登録することができます</strong>。</p>
<h2 id="clear-4"><a class="header" href="#clear-4">Clear</a></h2>
<p>F1〜F12ボタンと自動的に結びつけられたSceneボタンを削除します。</p>
<hr>
<h2 id="buttons-1"><a class="header" href="#buttons-1">Buttons</a></h2>
<p>画面左下にSceneのボタンを表示するかしないかを設定できます。</p>
<p>コマンドでは<code>set scene_buttons, 0/1</code>でそれぞれ表示しない（<code>0</code>）、表示する（<code>1</code>）を設定できます。</p>
<h2 id="cache-1"><a class="header" href="#cache-1">Cache</a></h2>
<p>現在ActiveになっているSceneに対し、<code>enable</code>または<code>optimize</code>を選択することでそのSceneのキャッシュを生成します。通常、Scene間の表示形式の切り替え時には再度新たに描画のON/OFFを内部で行っているため、わずかに切り替えに時間がかかりますが、キャッシュを生成しておくとあらかじめ最適化された描画を記憶しておくためにSceneの切り替え時間が短くなります。これは特に分子表面の表示のON/OFFが関係している時に有効です。しかしその反面多量のメモリを確保する必要があるので、初回の操作は重くなります。
<code>disable</code>とするとキャッシュ機能を無効化します。（<code>read_only</code>はちょっとわかりませんでした……。）</p>
<p>cacheを<code>optimize</code>にすると、今ActiveになっているSceneに対して現在登録されている他のSceneからの切り替えをすべて計算するため、かなり重い処理になります。</p>
<p>コマンドでは<code>cache action [, scenes [, state ]]</code>となります。<code>scenes</code>はスペース区切りで複数指定できます。使用例は以下の通りです。</p>
<pre><code>cache enable
cache optimize
cache optimize, F1 F2 F5
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mouse-1"><a class="header" href="#mouse-1">Mouse</a></h1>
<img src="ch03/./image/mouse/mousemenu.png" width="30%">
<p>ここではマウス操作についてのメニューを表示しています。マウス操作については<a href="ch03/../ch02/mouse.html">2.4 マウス操作</a>を適宜参照することをおすすめします。</p>
<h2 id="selection-mode-1"><a class="header" href="#selection-mode-1">Selection Mode</a></h2>
<p><a href="ch03/../ch02/buttonaction.html#%E9%81%B8%E6%8A%9E--">+/-機能</a>（デフォルト設定では3-Button Viewingモードで左のシングルクリック）で選択範囲を増減させるときの、選択範囲の単位を変更します。デフォルトは<code>Residues</code>で、他にも<code>Atoms</code>, <code>Chains</code>, <code>Segments</code>, <code>Objects</code>, <code>Molecules</code>, <code>C-alphas</code>から選択することができます。</p>
<p>GUI上では、右下のメニューからSelectingの部分をクリックすることで、選択範囲を変更することができます。</p>
<p>コマンドからは<code>set mouse_selection_mode, (value)</code>で変更できます。設定値0, 1, 2, 3 ,4, 5, 6がそれぞれ<code>atoms</code>, <code>residues</code>, <code>chains</code>, <code>segments</code>, <code>objects</code>, <code>molecules</code>, <code>C-alphas</code>に対応します。</p>
<h2 id="mouse-mode-1"><a class="header" href="#mouse-mode-1">Mouse Mode</a></h2>
<p><a href="ch03/../ch02/buttonmode.html">2.4.1 操作モード</a>も参照して下さい。マウスのボタン配置と操作方法を、3 Button Motions, 3 Button Editing, 3 Button Viewing, 3 Button Lights, 3 Button All Modes, 2 Button Editing, 2 Button Viewing, 1 Button Viewing Mode, Emulate Maestroの中から選択することができます。</p>
<p>デスクトップ型パソコンを使っていて、左クリック、ホイールクリック（ミドルクリック）、右クリックが揃ったマウスを使える環境であれば、3 Button式を選ぶと機能を最大限活用することができます。一方、最近はホイールクリックのないタイプのタッチパッド（Macbookなど）もありますので、そういった方は2 Button式のメニューを選ぶことをおすすめします。</p>
<p>Emulate Maestroは<a href="https://www.schrodinger.com/maestro">Schrödinger Maestro</a>のマウス操作感覚とほぼ同じような設定になっています。</p>
<p>コマンドからも設定できるように思えるのですが、見かけだけ変わるようで実際の操作が変わっていないように見えます……。素直にGUIメニューから設定変更した方がよいと思われます。</p>
<h2 id="virtual-trackball-1"><a class="header" href="#virtual-trackball-1">Virtual Trackball</a></h2>
<p>この機能をONにすると（デフォルトはON）、分子が写っている画面の中央に見えないトラックボールが置かれてあるような状態になります。</p>
<img src="ch03/./image/mouse/mouse_virtual.jpg" width="80%">
<p>このトラックボールの外にマウスカーソルをあわせて視点を変更しようとしたときの挙動が、Virtual Trackballの設定値によって変動します（トラックボール内部はON/OFFともに同じです）。ONのときにトラックボールの外で視点を変更しようとすると、Z軸だけが回転するような動きになります。OFFのときは全体がトラックボールの上にあるような動きになります。</p>
<p>コマンドからは<code>set virtual_trackball, (value)</code>で変更できます。<code>0</code>がOFF, <code>1</code>がONです。</p>
<blockquote>
<p>The virtual trackball works as if there is an invisible ball in the center of the scene. When you click and drag on the screen, it is as if you put your finger on the sphere and rotated it in approximately the same manner. If you click outside the sphere, then you get rotation about the Z-axis only.</p>
</blockquote>
<h2 id="show-mouse-grid-1"><a class="header" href="#show-mouse-grid-1">Show Mouse Grid</a></h2>
<p>GUIメニュー右下のマウスの操作方法メニューの表示をON/OFFにします。</p>
<p><img src="ch03/./image/mouse/mouse2.png" width="45%"> <img src="ch03/./image/mouse/mouse3.png" width="45%"></p>
<h2 id="roving-origin-1"><a class="header" href="#roving-origin-1">Roving Origin</a></h2>
<p>Originの位置を、視点の移動とともに追従するかそうでないかを設定します。デフォルトはONです。Originとは回転操作を行いたいときの回転中心のことです。Originの位置は任意の選択範囲に対してActionパネルから<code>Origin</code>を選ぶことで設定できます。これがONのとき、視点を平行移動（<a href="ch03/../ch02/mouse.html#%E4%B8%A6%E9%80%B2-move">マウス操作のMove</a>参照）させてもOriginの位置が画面に対して同じ位置に留まるよう更新されますが、OFFにすると視点を平行移動させてもOrigin位置を自動で更新しなくなります。
この効果は、PyMOL上で分子を画面の端っこに置いた状態で設定値を変えて視点の変更しようとすると分かりやすいと思います。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/mouse/roving.mp4" type="video/mp4">
</video>
<p>コマンドからは<code>set roving_origin, (value)</code>で変更できます。<code>0</code>がOFF, <code>1</code>がONです。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="wizard-1"><a class="header" href="#wizard-1">Wizard</a></h1>
<p>Wizardは複雑な操作をユーザーとの対話形式で行えるようにしてくれるためのツール群です。Wizardには以下の種類が用意されており、選択することでInternal GUI画面にマウスで操作できるメニューが現れます。特に、<strong>Mutagenesis</strong>と<strong>Density</strong>のWizardは重宝することでしょう。</p>
<h2 id="appearance-1"><a class="header" href="#appearance-1">Appearance</a></h2>
<h2 id="measurement-1"><a class="header" href="#measurement-1">Measurement</a></h2>
<h2 id="mutagenesis-1"><a class="header" href="#mutagenesis-1">Mutagenesis</a></h2>
<p>タンパク質の任意のアミノ酸の場所にアミノ酸点変異を導入したモデルを作成してくれます。実験科学者が「もしここに変異を入れたら隣り合うアミノ酸と干渉するだろうか？」ということを簡単に試してみたり、計算科学者が点変異を加えたタンパク質の分子動力学シミュレーションの初期座標として用いたりすることができます。また各アミノ酸にはrotamerと呼ばれる、エネルギー的に安定ないくつかのコンフォメーションのライブラリが内蔵されている上、周囲のアミノ酸の座標を検知した上で最もエネルギー的に安定なrotamerを自動的に選択してくれます。</p>
<p>詳細は第5章で。</p>
<h2 id="pair-fitting-1"><a class="header" href="#pair-fitting-1">Pair Fitting</a></h2>
<h2 id="density-1"><a class="header" href="#density-1">Density</a></h2>
<p>タンパク質の構造決定法がX線結晶構造解析法, 中性子回折法, クライオ電子顕微鏡によるものだった場合、その電子密度を表示させることができます。</p>
<h2 id="filter-1"><a class="header" href="#filter-1">Filter</a></h2>
<h2 id="sculpting-3"><a class="header" href="#sculpting-3">Sculpting</a></h2>
<h2 id="label-1"><a class="header" href="#label-1">Label</a></h2>
<h2 id="charge-1"><a class="header" href="#charge-1">Charge</a></h2>
<h2 id="demo-1"><a class="header" href="#demo-1">Demo</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="plugin-1"><a class="header" href="#plugin-1">Plugin</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="help-1"><a class="header" href="#help-1">help</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="第4章-コマンドラインの使い方"><a class="header" href="#第4章-コマンドラインの使い方">第4章 コマンドラインの使い方</a></h1>
<h1 id="分子構造のロード-2"><a class="header" href="#分子構造のロード-2">分子構造のロード</a></h1>
<p><code>load</code>コマンドは様々なファイルフォーマットを読み込むことができます。読み込もうとするファイルの拡張子に対応して自動的に読み込み形式を判定してくれます。例えばPDBファイルを正しく読み込む場合は<code>.pdb</code>である必要があり、MOLファイルであれば<code>.mol</code>、Macromodelファイルは<code>.mmod</code>、XPLOR mapファイルは<code>.xplor</code>、CCP4 mapファイルは<code>.ccp4</code>、Raster3Dインプットファイル(Molscript output)は<code>.r3d</code>、PyMOLセッションファイルは<code>.pse</code>、pickleになったChemPyモデル<code>.pkl</code>などは直接読み込むことができます。</p>
<p>以下の入力拡張子は右側のファイルタイプとして認識されます。</p>
<table><thead><tr><th align="right">入力拡張子</th><th align="right">認識されるファイルタイプ</th></tr></thead><tbody>
<tr><td align="right"><code>ent</code>, <code>p5m</code></td><td align="right"><code>pdb</code></td></tr>
<tr><td align="right"><code>mmd</code>, <code>out</code>, <code>dat</code></td><td align="right"><code>mmod</code></td></tr>
<tr><td align="right"><code>map</code>, <code>mrc</code></td><td align="right"><code>ccp4</code></td></tr>
<tr><td align="right"><code>cc2</code></td><td align="right"><code>cc1</code></td></tr>
<tr><td align="right"><code>sd</code></td><td align="right"><code>sdf</code></td></tr>
<tr><td align="right"><code>rst7</code></td><td align="right"><code>rst</code></td></tr>
<tr><td align="right"><code>o</code>, <code>dsn6</code>, <code>omap</code></td><td align="right"><code>brix</code></td></tr>
<tr><td align="right"><code>ph4</code></td><td align="right"><code>moe</code></td></tr>
<tr><td align="right"><code>spi</code></td><td align="right"><code>spider</code></td></tr>
<tr><td align="right"><code>pym</code>, <code>pyc</code></td><td align="right"><code>py</code></td></tr>
<tr><td align="right"><code>p1m</code>, <code>pim</code></td><td align="right"><code>pml</code></td></tr>
<tr><td align="right"><code>xml</code></td><td align="right"><code>pdbml</code></td></tr>
</tbody></table>
<p><code>load</code>コマンドを使うときに<code>object</code>引数が指定された場合には、そのファイルは同名のオブジェクト上にファイルを読み込みます。指定しない場合、拡張子部分を除いたファイル名と同じ名前のオブジェクトが生成されます。</p>
<h2 id="使い方"><a class="header" href="#使い方">使い方</a></h2>
<pre><code>load filename [,object [,state [,format [,finish [,discrete [,multiplex ]]]]]]
</code></pre>
<h2 id="pymol-api"><a class="header" href="#pymol-api">PYMOL API</a></h2>
<pre><code>cmd.load( filename [,object [,state [,format [,finish [,discrete [,multiplex ]]]]]] )
</code></pre>
<h2 id="引数"><a class="header" href="#引数">引数</a></h2>
<ul>
<li><code>filename</code> : (string) ロードしたいファイルのファイルパス、またはURLで指定することもできます。</li>
<li><code>object</code> : (string) 構造ファイルのオブジェクト名です。デフォルト名はロードするファイルのプレフィクスです。</li>
<li><code>state</code> : (integer) 読み込む構造ファイルをオブジェクトに保存する時、指定した数字のstateの上に上書きする形で読み込みます。例えば、MDのトラジェクトリファイルをオブジェクトの上に読み込む場合は、<code>state=1</code>を指定すると初期座標を上書きして（削除して）表示できるようになります。<code>0</code>を指定した場合は最後のstateの後に追加する形で読み込みます。(default:<code>0</code>)</li>
<li><code>format</code> : (string) ファイルのフォーマット形式を指定できます(see notes)。デフォルトはファイルの拡張子です。</li>
<li><code>finish</code> : (integer)</li>
<li><code>discrete</code> : (integer) MDトラジェクトリやNMR構造ファイルをロードしようとするようなマルチモデル構造に対しての場合、<code>0</code>に設定すると同じ原子セットを持つモデルであることを宣言し、メモリを節約することができます。<code>1</code>に設定すると強制的に各モデルについて別々の原子セットモデルを生成することができます。デフォルトは<code>-1</code>でファイルタイプに依存する設定になっています。(see discrete objects)</li>
<li><code>quiet</code> : (integer) デフォルトは<code>1</code>です。</li>
<li>multiplex : integer Load a multi-model file as separate objects instead of states (see also split_states)</li>
<li>zoom : integer {default: -1 = use auto_zoom setting}</li>
<li>partial : integer For session files (.pse). partial=0: discard current session. partial=1: merge with current session (will not load global settings, selections, movie, camera). partial=2: like 1, but also load camera view {default: 0}</li>
<li>mimic : integer For .mae files, match style from file as close as possible, uses atom-level settings (like cartoon_color) {default: 1}</li>
<li>object_props : string = Space delimited list of property names (or * wildcard) to load from .sdf or .mae files {default: use load_object_props_default setting} Incentive PyMOL 1.6+</li>
<li>atom_props : string = Space delimited list of property names (or * wildcard) to load from .mae files {default: use load_atom_props_default setting} Incentive PyMOL 1.6+</li>
</ul>
<h1 id="保存"><a class="header" href="#保存">保存</a></h1>
<h1 id="分子構造の表示形式のonoff"><a class="header" href="#分子構造の表示形式のonoff">分子構造の表示形式のON/OFF</a></h1>
<h1 id="オブジェクトの重ね合わせ"><a class="header" href="#オブジェクトの重ね合わせ">オブジェクトの重ね合わせ</a></h1>
<p>生体分子、特にタンパク質には、構成されるアミノ酸配列が異なるものの概してよく似た構造を取っているものがよくあります。新種のタンパク質について構造解析を行い、既存のタンパク質と構造・機能上よく似たタンパク質が存在した場合には、その構造を比べてみて類似点・相違点を述べるというのが構造解析論文のディスカッションでよく見られる光景です。</p>
<p>重ね合わせのためのコマンドは<code>align</code>または<code>super</code>が用意されています。この2つのコマンドはともに構造の重ね合わせをすることができますが、<strong>配列相同性が高い場合は<code>align</code>コマンドを、低い場合は<code>super</code>を利用することがそれぞれ推奨されています</strong>。アルゴリズム的に見ると、<code>align</code>は構成アミノ酸配列を考慮するのに対し、<code>super</code>は配列を考慮せずに構造ベースで重ね合わせようとします。</p>
<blockquote>
<p>https://pymolwiki.org/index.php/Align</p>
</blockquote>
<blockquote>
<p>https://pymolwiki.org/index.php/Super</p>
</blockquote>
<h2 id="alignコマンド"><a class="header" href="#alignコマンド">alignコマンド</a></h2>
<h3 id="使い方-1"><a class="header" href="#使い方-1">使い方</a></h3>
<pre><code>align mobile, target [, cutoff [, cycles
    [, gap [, extend [, max_gap [, object
    [, matrix [, mobile_state [, target_state
    [, quiet [, max_skip [, transform [, reset ]]]]]]]]]]]]]
</code></pre>
<ul>
<li><code>mobile</code> = string: 移動するべきオブジェクトのatom selection</li>
<li><code>target</code> = string: 重ね合わせる先のオブジェクトのatom selection</li>
<li><code>cutoff</code> = float: RMS（root mean square :構造のズレの数値指標）を基準に、この値を超えると外れ値とみなして重ね合わせに考慮に入れなくする。 デフォルトは<code>2.0</code>。</li>
<li><code>cycles</code> = int: 重ね合わせ試行の繰り返し数。この回数分だけ、重ね合わせる→大きくずれている箇所を検出し、そこを考慮しないで再度重ね合わせ→……を行う。デフォルトは<code>5</code>回。</li>
<li><code>gap</code>, <code>extend</code>, <code>max_gap</code>: 配列アライメント上でのペナルティパラメータ。</li>
<li><code>object</code> = string: 重ね合わせ結果をアライメントオブジェクトとして出力するときのオブジェクト名を指定する。デフォルトでは重ね合わせオブジェクトを生成しない。</li>
<li><code>matrix</code> = string: 配列アライメントでの置換行列を指定する。デフォルトは<code>BLOSUM62</code>置換行列。</li>
<li><code>mobile_state</code> = int: <code>mobile</code>で指定したオブジェクトに複数のstateが存在する場合、どのstateを使ってアライメントするかを指定できる。デフォルトは<code>0</code>（全state）。</li>
<li><code>target_state</code> = int: <code>target</code>で指定したオブジェクトに複数のstateが存在する場合、どのstateを使ってアライメントするかを指定できる。デフォルトは<code>0</code></li>
<li><code>quiet</code> = <code>0</code>の場合、詳細なアウトプットを表示する。<code>1</code>の場合は表示しない。デフォルトはコマンドラインから利用した場合<code>0</code>で、APIから呼び出した場合は<code>1</code>。</li>
<li><code>max_skip</code> = ?</li>
<li><code>transform</code> = <code>1</code>ならば<code>mobile</code>オブジェクトを移動させる。<code>0</code>ならば移動させない。</li>
<li><code>reset</code> = ?</li>
</ul>
<h2 id="superコマンド"><a class="header" href="#superコマンド">superコマンド</a></h2>
<h3 id="使い方-2"><a class="header" href="#使い方-2">使い方</a></h3>
<p>ほぼ<code>align</code>コマンドと同じですが、さらにオプションが追加されています。</p>
<pre><code>super mobile, target [, cutoff [, cycles [, gap [, extend [, max_gap [, object [, matrix [, mobile_state [, target_state [, quiet [, max_skip [, transform [, reset [, seq [, radius [, scale [, base [, coord [, expect [, window [, ante ]]]]]]]]]]]]]]]]]]]]]
</code></pre>
<ul>
<li><code>reset</code> = ?</li>
<li><code>seq</code> = ?</li>
<li><code>radius</code> = ?</li>
<li><code>scale</code> = ?</li>
<li><code>base</code> = ?</li>
<li><code>coord</code> = ?</li>
<li><code>expect</code> = ?</li>
<li><code>window</code> = ?</li>
<li><code>ante</code> = ?</li>
</ul>
<h2 id="実例"><a class="header" href="#実例">実例</a></h2>
<p>ここではPDB IDの1alkと3q3qの2つのアルカリホスファターゼを例にとって構造の重ね合わせをしてみましょう。この2つはアルカリホスファターゼでありながら、全体の構造は大きく異なっています。また1alkの方は2量体であるのに対して3q3qの方は単量体で表示されていることに注意してください。</p>
<pre><code>fetch 1alk
fetch 3q3q
</code></pre>
<img src="ch04/./image/super/1.png" width="80%">
<p><code>align</code>を使って構造を重ね合わせてみるとこのような形になります。</p>
<pre><code>align 1alk, 3q3q, object=objalign
</code></pre>
<img src="ch04/./image/super/2.png" width="80%">
<p>External GUIの出力結果を見ると、</p>
<pre><code>Executive: RMSD =   25.391 (2096 to 2096 atoms)
</code></pre>
<p>となっており、構造のずれを表すRMSD値は25.3とかなり大きな値になっています。</p>
<p>一方で、<code>super</code>コマンドを使ってみると</p>
<pre><code>super 1alk, 3q3q, object=objsuper
</code></pre>
<img src="ch04/./image/super/3.png" width="80%">
```
Executive: RMSD =    3.366 (352 to 352 atoms)
```
となっており、重ね合わせに利用した原子が352 atomsであり、その範囲でのRMSD値が3.366となりました。
<p>また、<code>objalign</code>と<code>objsuper</code>という<strong>アライメントオブジェクト</strong>が生成されています。このオブジェクトは2つの構造の重ね合わせのときに使った対応部分を黄色い線で表してくれています。<code>super</code>を行った場合は、1alk, 3q3qに共通しているαβα-sandwich構造の部分だけを自動的にサーチして、その部分だけを利用した重ね合わせを実行してくれています。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="分子構造のロード-3"><a class="header" href="#分子構造のロード-3">分子構造のロード</a></h1>
<p><code>load</code>コマンドは様々なファイルフォーマットを読み込むことができます。読み込もうとするファイルの拡張子に対応して自動的に読み込み形式を判定してくれます。例えばPDBファイルを正しく読み込む場合は<code>.pdb</code>である必要があり、MOLファイルであれば<code>.mol</code>、Macromodelファイルは<code>.mmod</code>、XPLOR mapファイルは<code>.xplor</code>、CCP4 mapファイルは<code>.ccp4</code>、Raster3Dインプットファイル(Molscript output)は<code>.r3d</code>、PyMOLセッションファイルは<code>.pse</code>、pickleになったChemPyモデル<code>.pkl</code>などは直接読み込むことができます。</p>
<p>以下の入力拡張子は右側のファイルタイプとして認識されます。</p>
<table><thead><tr><th align="right">入力拡張子</th><th align="right">認識されるファイルタイプ</th></tr></thead><tbody>
<tr><td align="right"><code>ent</code>, <code>p5m</code></td><td align="right"><code>pdb</code></td></tr>
<tr><td align="right"><code>mmd</code>, <code>out</code>, <code>dat</code></td><td align="right"><code>mmod</code></td></tr>
<tr><td align="right"><code>map</code>, <code>mrc</code></td><td align="right"><code>ccp4</code></td></tr>
<tr><td align="right"><code>cc2</code></td><td align="right"><code>cc1</code></td></tr>
<tr><td align="right"><code>sd</code></td><td align="right"><code>sdf</code></td></tr>
<tr><td align="right"><code>rst7</code></td><td align="right"><code>rst</code></td></tr>
<tr><td align="right"><code>o</code>, <code>dsn6</code>, <code>omap</code></td><td align="right"><code>brix</code></td></tr>
<tr><td align="right"><code>ph4</code></td><td align="right"><code>moe</code></td></tr>
<tr><td align="right"><code>spi</code></td><td align="right"><code>spider</code></td></tr>
<tr><td align="right"><code>pym</code>, <code>pyc</code></td><td align="right"><code>py</code></td></tr>
<tr><td align="right"><code>p1m</code>, <code>pim</code></td><td align="right"><code>pml</code></td></tr>
<tr><td align="right"><code>xml</code></td><td align="right"><code>pdbml</code></td></tr>
</tbody></table>
<p><code>load</code>コマンドを使うときに<code>object</code>引数が指定された場合には、そのファイルは同名のオブジェクト上にファイルを読み込みます。指定しない場合、拡張子部分を除いたファイル名と同じ名前のオブジェクトが生成されます。</p>
<h2 id="使い方-3"><a class="header" href="#使い方-3">使い方</a></h2>
<pre><code>load filename [,object [,state [,format [,finish [,discrete [,multiplex ]]]]]]
</code></pre>
<h2 id="pymol-api-1"><a class="header" href="#pymol-api-1">PYMOL API</a></h2>
<pre><code>cmd.load( filename [,object [,state [,format [,finish [,discrete [,multiplex ]]]]]] )
</code></pre>
<h2 id="引数-1"><a class="header" href="#引数-1">引数</a></h2>
<ul>
<li><code>filename</code> : (string) ロードしたいファイルのファイルパス、またはURLで指定することもできます。</li>
<li><code>object</code> : (string) 構造ファイルのオブジェクト名です。デフォルト名はロードするファイルのプレフィクスです。</li>
<li><code>state</code> : (integer) 読み込む構造ファイルをオブジェクトに保存する時、指定した数字のstateの上に上書きする形で読み込みます。例えば、MDのトラジェクトリファイルをオブジェクトの上に読み込む場合は、<code>state=1</code>を指定すると初期座標を上書きして（削除して）表示できるようになります。<code>0</code>を指定した場合は最後のstateの後に追加する形で読み込みます。(default:<code>0</code>)</li>
<li><code>format</code> : (string) ファイルのフォーマット形式を指定できます(see notes)。デフォルトはファイルの拡張子です。</li>
<li><code>finish</code> : (integer)</li>
<li><code>discrete</code> : (integer) MDトラジェクトリやNMR構造ファイルをロードしようとするようなマルチモデル構造に対しての場合、<code>0</code>に設定すると同じ原子セットを持つモデルであることを宣言し、メモリを節約することができます。<code>1</code>に設定すると強制的に各モデルについて別々の原子セットモデルを生成することができます。デフォルトは<code>-1</code>でファイルタイプに依存する設定になっています。(see discrete objects)</li>
<li><code>quiet</code> : (integer) デフォルトは<code>1</code>です。</li>
<li>multiplex : integer Load a multi-model file as separate objects instead of states (see also split_states)</li>
<li>zoom : integer {default: -1 = use auto_zoom setting}</li>
<li>partial : integer For session files (.pse). partial=0: discard current session. partial=1: merge with current session (will not load global settings, selections, movie, camera). partial=2: like 1, but also load camera view {default: 0}</li>
<li>mimic : integer For .mae files, match style from file as close as possible, uses atom-level settings (like cartoon_color) {default: 1}</li>
<li>object_props : string = Space delimited list of property names (or * wildcard) to load from .sdf or .mae files {default: use load_object_props_default setting} Incentive PyMOL 1.6+</li>
<li>atom_props : string = Space delimited list of property names (or * wildcard) to load from .mae files {default: use load_atom_props_default setting} Incentive PyMOL 1.6+</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="保存-1"><a class="header" href="#保存-1">保存</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="分子構造の表示形式のonoff-1"><a class="header" href="#分子構造の表示形式のonoff-1">分子構造の表示形式のON/OFF</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="オブジェクトの重ね合わせ-1"><a class="header" href="#オブジェクトの重ね合わせ-1">オブジェクトの重ね合わせ</a></h1>
<p>生体分子、特にタンパク質には、構成されるアミノ酸配列が異なるものの概してよく似た構造を取っているものがよくあります。新種のタンパク質について構造解析を行い、既存のタンパク質と構造・機能上よく似たタンパク質が存在した場合には、その構造を比べてみて類似点・相違点を述べるというのが構造解析論文のディスカッションでよく見られる光景です。</p>
<p>重ね合わせのためのコマンドは<code>align</code>または<code>super</code>が用意されています。この2つのコマンドはともに構造の重ね合わせをすることができますが、<strong>配列相同性が高い場合は<code>align</code>コマンドを、低い場合は<code>super</code>を利用することがそれぞれ推奨されています</strong>。アルゴリズム的に見ると、<code>align</code>は構成アミノ酸配列を考慮するのに対し、<code>super</code>は配列を考慮せずに構造ベースで重ね合わせようとします。</p>
<blockquote>
<p>https://pymolwiki.org/index.php/Align</p>
</blockquote>
<blockquote>
<p>https://pymolwiki.org/index.php/Super</p>
</blockquote>
<h2 id="alignコマンド-1"><a class="header" href="#alignコマンド-1">alignコマンド</a></h2>
<h3 id="使い方-4"><a class="header" href="#使い方-4">使い方</a></h3>
<pre><code>align mobile, target [, cutoff [, cycles
    [, gap [, extend [, max_gap [, object
    [, matrix [, mobile_state [, target_state
    [, quiet [, max_skip [, transform [, reset ]]]]]]]]]]]]]
</code></pre>
<ul>
<li><code>mobile</code> = string: 移動するべきオブジェクトのatom selection</li>
<li><code>target</code> = string: 重ね合わせる先のオブジェクトのatom selection</li>
<li><code>cutoff</code> = float: RMS（root mean square :構造のズレの数値指標）を基準に、この値を超えると外れ値とみなして重ね合わせに考慮に入れなくする。 デフォルトは<code>2.0</code>。</li>
<li><code>cycles</code> = int: 重ね合わせ試行の繰り返し数。この回数分だけ、重ね合わせる→大きくずれている箇所を検出し、そこを考慮しないで再度重ね合わせ→……を行う。デフォルトは<code>5</code>回。</li>
<li><code>gap</code>, <code>extend</code>, <code>max_gap</code>: 配列アライメント上でのペナルティパラメータ。</li>
<li><code>object</code> = string: 重ね合わせ結果をアライメントオブジェクトとして出力するときのオブジェクト名を指定する。デフォルトでは重ね合わせオブジェクトを生成しない。</li>
<li><code>matrix</code> = string: 配列アライメントでの置換行列を指定する。デフォルトは<code>BLOSUM62</code>置換行列。</li>
<li><code>mobile_state</code> = int: <code>mobile</code>で指定したオブジェクトに複数のstateが存在する場合、どのstateを使ってアライメントするかを指定できる。デフォルトは<code>0</code>（全state）。</li>
<li><code>target_state</code> = int: <code>target</code>で指定したオブジェクトに複数のstateが存在する場合、どのstateを使ってアライメントするかを指定できる。デフォルトは<code>0</code></li>
<li><code>quiet</code> = <code>0</code>の場合、詳細なアウトプットを表示する。<code>1</code>の場合は表示しない。デフォルトはコマンドラインから利用した場合<code>0</code>で、APIから呼び出した場合は<code>1</code>。</li>
<li><code>max_skip</code> = ?</li>
<li><code>transform</code> = <code>1</code>ならば<code>mobile</code>オブジェクトを移動させる。<code>0</code>ならば移動させない。</li>
<li><code>reset</code> = ?</li>
</ul>
<h2 id="superコマンド-1"><a class="header" href="#superコマンド-1">superコマンド</a></h2>
<h3 id="使い方-5"><a class="header" href="#使い方-5">使い方</a></h3>
<p>ほぼ<code>align</code>コマンドと同じですが、さらにオプションが追加されています。</p>
<pre><code>super mobile, target [, cutoff [, cycles [, gap [, extend [, max_gap [, object [, matrix [, mobile_state [, target_state [, quiet [, max_skip [, transform [, reset [, seq [, radius [, scale [, base [, coord [, expect [, window [, ante ]]]]]]]]]]]]]]]]]]]]]
</code></pre>
<ul>
<li><code>reset</code> = ?</li>
<li><code>seq</code> = ?</li>
<li><code>radius</code> = ?</li>
<li><code>scale</code> = ?</li>
<li><code>base</code> = ?</li>
<li><code>coord</code> = ?</li>
<li><code>expect</code> = ?</li>
<li><code>window</code> = ?</li>
<li><code>ante</code> = ?</li>
</ul>
<h2 id="実例-1"><a class="header" href="#実例-1">実例</a></h2>
<p>ここではPDB IDの1alkと3q3qの2つのアルカリホスファターゼを例にとって構造の重ね合わせをしてみましょう。この2つはアルカリホスファターゼでありながら、全体の構造は大きく異なっています。また1alkの方は2量体であるのに対して3q3qの方は単量体で表示されていることに注意してください。</p>
<pre><code>fetch 1alk
fetch 3q3q
</code></pre>
<img src="ch04/./image/super/1.png" width="80%">
<p><code>align</code>を使って構造を重ね合わせてみるとこのような形になります。</p>
<pre><code>align 1alk, 3q3q, object=objalign
</code></pre>
<img src="ch04/./image/super/2.png" width="80%">
<p>External GUIの出力結果を見ると、</p>
<pre><code>Executive: RMSD =   25.391 (2096 to 2096 atoms)
</code></pre>
<p>となっており、構造のずれを表すRMSD値は25.3とかなり大きな値になっています。</p>
<p>一方で、<code>super</code>コマンドを使ってみると</p>
<pre><code>super 1alk, 3q3q, object=objsuper
</code></pre>
<img src="ch04/./image/super/3.png" width="80%">
```
Executive: RMSD =    3.366 (352 to 352 atoms)
```
となっており、重ね合わせに利用した原子が352 atomsであり、その範囲でのRMSD値が3.366となりました。
<p>また、<code>objalign</code>と<code>objsuper</code>という<strong>アライメントオブジェクト</strong>が生成されています。このオブジェクトは2つの構造の重ね合わせのときに使った対応部分を黄色い線で表してくれています。<code>super</code>を行った場合は、1alk, 3q3qに共通しているαβα-sandwich構造の部分だけを自動的にサーチして、その部分だけを利用した重ね合わせを実行してくれています。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="第5章-pymolの様々な機能"><a class="header" href="#第5章-pymolの様々な機能">第5章 PyMOLの様々な機能</a></h1>
<h2 id="結晶構造の電子密度マップを表示する"><a class="header" href="#結晶構造の電子密度マップを表示する">結晶構造の電子密度マップを表示する</a></h2>
<p>PyMOLは結晶構造の電子密度データを表示させることも可能です。</p>
<p>例としてPDB: 3TG0の大腸菌由来アルカリホスファターゼの電子密度マップを取得して表示させてみます。PDB ID:1ALKのものは電子密度マップがデータベースに登録されていないため、代わりにほぼ同一な構造情報をこちらを例として用います。</p>
<pre><code># インターネットから3tg0のPDBデータをダウンロード。
fetch 3tg0
# 3tg0の電子密度マップ（2fofc形式）を3tg0_mapというオブジェクトでダウンロードし、表示する
fetch 3tg0, 3tg0_map, type=2fofc
# A chainに結合している無機リン酸PO4に注目する
center /3tg0/H/A/PO4`504
</code></pre>
<p>ここまでのロードが終了すると、オブジェクトパネルに<code>3tg0_map</code>というオブジェクトが追加されているはずです。ここで、続いて上部メニューバーからWizard -&gt; Densityを選択します。</p>
<p><img src="ch05/./image/emap1.png" alt="3-1-1" title="Wizard-Density" /></p>
<p>この操作によって、現在の視点周辺に青色の電子密度マップが重なって表示されるようになります。</p>
<p><img src="ch05/./image/emap2.png" alt="3-1-2" title="Wizard-Density" /></p>
<p>ここで、電子密度マップは<code>w1_3tg0_map</code>というオブジェクト名になっています。各種表示を変更するには以下の部分をクリックして操作します。</p>
<ul>
<li>色はオブジェクトパネルのCボタンから変更することができます。positiveとnegativeそれぞれについて別の色を指定することができます。デフォルトの青色メッシュは濃くて見えにくいので、もう少し薄い色を指定すると見やすくなるでしょう。</li>
<li><code>Density Map Wizard</code>と書かれた部分の中の<code>Radius</code>の部分をクリックすることで、電子密度の表示範囲を変更することができます。</li>
<li><code>@ 1.0 sigma</code>と書かれているところをクリックすると、電子密度メッシュの表示範囲を変更することができます。sigmaの数字が大きいほど、表示されるメッシュの範囲は小さくなります。</li>
<li>デフォルトではMap 1のみが働いていますが、Map 2、Map 3部分をクリックしてオブジェクト名を指定すれば、さらに重ねて電子密度マップを表示することができます。異なるsigmaのメッシュを色違いで表示させることも可能です。</li>
<li>表示設定をやり直したいときは<code>w1_3tg0_map</code>のAボタンをクリックし、<code>delete object</code>をした後、下のWizardの<code>Update Maps</code>を押せば電子密度が再び表示されるようになります。</li>
</ul>
<h2 id="apbsプラグインを使った表面電荷表示"><a class="header" href="#apbsプラグインを使った表面電荷表示">APBSプラグインを使った表面電荷表示</a></h2>
<p>PyMOLのプラグインでデフォルトでインストールされている<strong>APBS</strong>を使って表面電荷を表示してくれる方法を説明します。</p>
<img src="ch05/./image/apbs1.png" title="APBSの表示例">
<p>このプラグインは、インストーラー版を使ってPyMOL 2をインストールした場合にはその中に同梱されているので別段の準備は必要ありませんが、オープンソース版をインストールした場合には様々な準備が必要となりますので、下にある<a href="ch05/index.html#apbs%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">HomebrewでAPBS, PDB2PQRをインストールしておきます</a>。まずはAPBSプラグインの使い方を説明します。</p>
<h3 id="apbsを使ってみる"><a class="header" href="#apbsを使ってみる">APBSを使ってみる</a></h3>
<p>今回は例としてPDB: 3x2oの構造のみを開いた状態にしておきます。その後、まず上部メニューの[Plugin]を選択し、次に[APBS Electrostatics]を選択します。</p>
<img src="ch05/./image/apbsmenu1.png" width="300px" title="APBSmenu1">
<p>中のメニューはこうなっています。</p>
<img src="ch05/./image/apbsmenu2.png" width="300px" title="APBSmenu2">
<p>Mainのタブでまず<code>selection</code>部分を確認します。この例では<code>polymer &amp; 3x2o</code>という表示になっていますが、これはアミノ酸20種類かつオブジェクト3x2oが選択されていることを意味し、この選択範囲についてAPBSの電荷計算をこれから行うことを意味します。</p>
<p>この選択範囲に問題がなければ、このメニューの下の方にあるRunボタンを押すだけでAPBSの計算が動き出します。途中Warnings: &quot;do you want to continue?&quot;が表示された場合はYesと答えておきましょう。</p>
<img src="ch05/./image/apbsmenu6.png" title="APBSmenu6">
<p>正常にAPBSの計算が終わると、Close the APBS dialog?と問われます。閉じてもOKです。</p>
<img src="ch05/./image/apbsmenu7.png" title="APBSmenu7">
<p>計算が終わると、このように3x2oの表面が赤・白・青に分けて表示されるようになりました。</p>
<img src="ch05/./image/apbs4.png" title="APBS4">
<p><strong>赤は負電荷の多い箇所、青は正電荷の多い箇所</strong>を表しています。白は中性です。</p>
<p>右側のInternal GUIのメニューには<code>run01</code>というオブジェクトグループが新しく増えています。ここの＋マークを押すと子オブジェクトが現れます。このうち<code>apbs_ramp01</code>というオブジェクトの<code>A</code>メニューを開いてみましょう。</p>
<img src="ch05/./image/apbs5.png" width="300px" title="APBS5">
<p>上の方の<code>levels</code>を選ぶと<code>Range</code>を変えることができそうです。このRangeは先述の負電荷・正電荷の色付けの表示領域を表しており、値が小さいほど、描画上で最大となる赤・青のしきい値が小さくなります。つまり、デフォルトの5.0から2.0にしてみると</p>
<img src="ch05/./image/apbs6.png" title="APBS6">
<p>こんな感じで赤と青の箇所が濃く表示されるようになります。</p>
<p>この表面電荷表示はSurface表示として扱われているので、<code>set transparency, 0.5</code>として透明度を変更してあげることができます(<code>0.5</code>は透明度)。</p>
<img src="ch05/./image/apbs7.png" title="APBS7">
<p>透明度を下げてCartoon表示とともに観察すれば、分子のどの部分構造の付近が負電荷、正電荷になっているかがわかりやすいと思います。</p>
<p>さて、ここで先程のAPBS Electrostaticsメニューのプラグイン画面に戻ってみましょう。そこのMainタブの下の方には<code>Other Visualizations</code>というOptionsボタンがあります。ここを開いてみると、「mapオブジェクトが計算されたあと、オブジェクトメニューパネルの&quot;Action&quot;アイテムを使うことで追加の描画を生成することができる」（日本語訳）と書かれてあります。</p>
<img src="ch05/./image/apbsmenu3.png" title="APBSmenu3">
<p>これに従って追加操作をしてみましょう（書きかけ）。</p>
<h3 id="advanced-configuration"><a class="header" href="#advanced-configuration">Advanced Configuration</a></h3>
<p>APBS Electrostaticsの計算のパラメータはデフォルトでも十分問題なく動作すると思いますが、上級者のために、パラメータを変更することもできるようになっています。[APBS Templrate]のタブを開くと、表面電荷を計算するための設定ファイルが表示されます。</p>
<p><img src="ch05/./image/apbsmenu4.png" title="APBSmenu4"><br></p>
<p>ここのBrowse...のところからは完成された設定ファイルを読み込ませることができます。公式ドキュメントは<a href="https://apbs-pdb2pqr.readthedocs.io/en/latest/apbs/input/">https://apbs-pdb2pqr.readthedocs.io/en/latest/apbs/input/</a> にあるので、そちらを参考にするのも良いでしょう。</p>
<p>最後の[Advanced Configuration]タブからは、APBSとPDB2PQRのプログラムのインストール場所を指定したり、コマンドオプションを追加して計算させることもできます。追加コマンドオプションの一覧は<a href="https://apbs-pdb2pqr.readthedocs.io/en/latest/pdb2pqr/invoking.html">https://apbs-pdb2pqr.readthedocs.io/en/latest/pdb2pqr/invoking.html</a>などが参考になります。</p>
<img src="ch05/./image/apbsmenu5.png" title="APBSmenu5">
<p>以下の項で説明するように、オープンソース版PyMOLではAPBS, PDB2PQRがプリインストールされていないため、自前で用意してからこのAdvanced Configurationで正しくプログラムの位置を指定してあげる必要があります。</p>
<h3 id="apbsのインストール"><a class="header" href="#apbsのインストール">APBSのインストール</a></h3>
<p>(2022年5月3日更新)</p>
<p>オープンソース版PyMOLを使っている人向けの説明です。やり方は3通りあって、Homebrewを使う方法と、バイナリインストールとソースコードからのインストールがあります。macOSの方やLinuxbrewが使える方はHomebrewの方法が簡単です。ソースコードからのインストールの方法は上級者向けです。</p>
<p>macOS（Linux OSの場合はLinuxbrewが必要）を使っている方は、私が作成したHomebrewのFormulaを使うことで簡単にインストールすることができます。執筆時点ではバージョン3.4.0です。</p>
<pre><code class="language-bash">brew install brewsci/bio/apbs
</code></pre>
<p>これにより、<code>apbs</code>コマンドが利用できるようになります。</p>
<pre><code class="language-bash">$ apbs --version

----------------------------------------------------------------------
    APBS -- Adaptive Poisson-Boltzmann Solver
    Version APBS 3.4.0
...
（以下省略）
</code></pre>
<p>インストール先は<code>which apbs</code>で調べることができます。</p>
<pre><code class="language-bash">$ which apbs
/opt/homebrew/bin/apbs # M1 Macの場合
/usr/local/bin/apbs    # Intel Macの場合
</code></pre>
<p>ここで表示されたインストール先のパス名をAdvanced ConfigurationのProgram Locationsのapbsの欄に入力すれば動作準備完了です。</p>
<img src="ch05/./image/apbs8.png" title="Homebrew APBS">
<h3 id="pdb2pqrのインストール"><a class="header" href="#pdb2pqrのインストール">PDB2PQRのインストール</a></h3>
<p>(2022年5月3日更新)</p>
<p>オープンソース版PyMOLを使っている人向けの説明です。pythonのpipを使ったインストールの方法が最も簡単でおすすめです。執筆時点ではバージョン3.5.2です。先に、</p>
<pre><code class="language-bash">$ python3 -m pip install pdb2pqr
...
(中略)
...
Successfully installed pdb2pqr-3.5.2
</code></pre>
<p>インストール先は<code>which pdb2pqr30</code>で調べることができます。バージョン3以前と異なり、バイナリ名が<code>pdb2pqr</code>から<code>pdb2pqr30</code>に変わっていることに気をつけてください。</p>
<pre><code class="language-bash">$ which pdb2pqr30
/opt/homebrew/bin/pdb2pqr30 # M1 Macの場合
/usr/local/bin/pdb2pqr30    # Intel Macの場合
</code></pre>
<p>ここで表示されたインストール先のパス名をAdvanced ConfigurationのProgram Locationsのpdb2pqrの欄に入力すれば動作準備完了です。</p>
<h3 id="apbs-guiプラグインのインストール"><a class="header" href="#apbs-guiプラグインのインストール">APBS GUIプラグインのインストール</a></h3>
<p>オープンソース版PyMOLはバイナリ版と違い、GUIプラグインがあらかじめインストールされていません。しかしバイナリ版のプラグインのディレクトリをそのままオープンソース版の方のディレクトリにコピーしてくれば使用することができます。</p>
<p>このGUIプラグイン部分は<a href="https://github.com/YoshitakaMo/pymolplugin">私のGithub</a>にコピーして置いてありますので、それをオープンソース版PyMOLのプラグインディレクトリに追加してやります。ターミナルを開いて</p>
<pre><code class="language-bash"># pymolpluginディレクトリをダウンロード
cd ~
git clone https://github.com/YoshitakaMo/pymolplugin.git
# ファイルをオープンソース版PyMOLのプラグインディレクトリに追加
cp -rp ~/pymolplugin/* ${HOMEBREW_PREFIX}/opt/pymol/libexec/lib/python3.10/site-packages/pmg_tk/startup
# ここでPyMOLを立ち上げてみて、プラグインがインストールされていればOK
# インストールできたら~/pymolpluginディレクトリは削除してOK
rm -rf ~/pymolplugin
</code></pre>
<p>と入力します。このコピーを行った後にopen-source版PyMOLを立ち上げると、上部メニューのPluginのところにAPBS Electrostaticsの文字が現れているはずです。</p>
<img src="ch05/./image/apbsmenu1.png" title="APBSmenu1">
<p>この文字をクリックし、Advanced Configurationのタブをクリックします。このProgram Locationsを自身の環境にあわせて設定する必要があります。</p>
<img src="ch05/./image/apbs3.png" title="APBSの表示例">
<p>HomebrewでAPBSとPDB2PQRをインストールした場合は、上図のようにapbsの欄を<code>/usr/local/bin/apbs</code>にし、pdb2pqrの欄を<code>/usr/local/bin/pdb2pqr30</code>に設定します（※M1以降のMacの方はそれぞれ<code>/opt/homebrew/bin/apbs</code>と<code>/opt/homebrew/bin/pdb2pqr30</code>）。もしソースコードからインストールした場合にはこの限りではありませんので、適切なapbs, pdb2pqrバイナリ本体へのpathを指定しましょう。</p>
<p>他の部分は特に変更する必要はありません。これで右下のrunを押せばめでたくAPBSが動くはずです。</p>
<h2 id="動画の作成方法"><a class="header" href="#動画の作成方法">動画の作成方法</a></h2>
<p>自身の研究しているタンパク質の構造を他の人にもしっかりと見てもらうための方法は、1つにはPyMOLセッションファイルに保存して、それをPyMOLで開いてもらうということが考えられます。しかし、PyMOLセッションファイルは相手のパソコンやmacにPyMOLがインストールされてなければ閲覧することはできません。そこで、より広い範囲で色んな人に見てもらうための方法として、<strong>分子が動いている様子を一般的な動画形式に変換する</strong>という方法があります。これならPowerpointなどのスライドに埋め込むこともできますし、ウェブ上でも公開できます。</p>
<p>ここではその方法をいくつか紹介します。</p>
<h3 id="目指す動画の例"><a class="header" href="#目指す動画の例">目指す動画の例</a></h3>
<p>先に完成例としての動画を表示します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/alpmovie.mp4" type="video/mp4">
</video>
<p>ポイントは</p>
<ul>
<li>全体像を見せつつ、基質結合部位を見せる</li>
<li>背景画像を使う</li>
<li>無料のコマンドラインツールのみを使用し、有料アプリを使わない</li>
</ul>
<p>です。</p>
<p>背景画像を使っているのは、使用しないと黒背景になることが多くなってしまうためです。</p>
<h3 id="使うツール"><a class="header" href="#使うツール">使うツール</a></h3>
<p>動画への出力は<strong>ffmpeg</strong>を使います。macOSならば</p>
<pre><code class="language-bash">$ brew install ffmpeg
</code></pre>
<p>でインストールできますので、これをインストールしておきます。もしOpen-source版のPyMOLを<code>brew install pymol</code>でインストールしていた場合はffmpegも自動的にインストールされているはずです。</p>
<h3 id="手順1画面サイズを決める"><a class="header" href="#手順1画面サイズを決める">手順1：画面サイズを決める</a></h3>
<p>動画として出力する予定の画面サイズを先に決めておくと後が楽です。ここでは横1280ピクセル縦720ピクセルの動画を出力することにします。これはコマンドでかんたんに設定することができます。コマンド入力欄に</p>
<pre><code>viewport 1280, 720
</code></pre>
<p>と入力すると、画面が指定したサイズに変化します。</p>
<img src="ch05/./image/movie/viewport.png" width="100%" title="">
<h3 id="手順2sceneを保存する"><a class="header" href="#手順2sceneを保存する">手順2：Sceneを保存する</a></h3>
<p><a href="ch05/../ch03/scene.html">3.7 Scene</a>で述べているように、<strong>Scene機能</strong>を使うとPyMOLでのカメラアングルと表示状態を保存することができ、左下に現れたメニューからいつでもその状態を呼び出すことができます。動画を作成する上でもこの<strong>Scene機能</strong>を活用することが可能です。</p>
<p>例としてまずアルカリホスファターゼの二量体構造全体が見える位置でSceneを1つ保存しておきます。いい感じの表示設定とカメラアングルが得られたら、上部メニューの<strong>Scene</strong>から<strong>Store</strong>を選びF1〜F12のいずれかに保存します（ここでは<strong>F1</strong>にしておきます）。</p>
<img src="ch05/./image/movie/movie1.png" width="100%" title="">
<p>左下に<strong>F1ボタン</strong>が現れました。以降はこのボタンを押すと表示設定とカメラアングルが呼び出されます。</p>
<img src="ch05/./image/movie/movie2.png" width="100%" title="">
<p>続いて基質結合部位に注目したカメラアングルをSceneの<strong>F2</strong>として保存しておきます。同様の操作でこんな感じで保存しておきます。</p>
<img src="ch05/./image/movie/movie3.png" width="100%" title="">
<img src="ch05/./image/movie/movie4.png" width="100%" title="">
<p>Sceneをすべて設定し終えたら、上部<strong>Movie</strong>メニューから<strong>Program</strong>, <strong>Scene Loop</strong>, <strong>Nutate, 30 de. over 2sec.</strong> を選びます。これはSceneを順番に表示しつつ、各Sceneで2秒間30°ずつ揺らしながら次の状態に移行する設定です。設定には色々あるので、<a href="ch05/../ch03/movie.html">3.4 Movie</a>から好きなものを選んでください。</p>
<p>右下のスタートボタンを押すとこんな感じで再生されます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/movie_1.mp4" type="video/mp4">
</video>
<p>ここに表示されている画面が動画として出力されるので、よくチェックしておきます。</p>
<p>もし手順1を飛ばしていた場合はここで<code>viewport</code>コマンドを入れて画像サイズを調節し、再度手順2のScene保存をやり直します。</p>
<p>よければセッションファイル（pseファイル）として保存しておきます。</p>
<h3 id="手順3png形式で各フレームを保存する"><a class="header" href="#手順3png形式で各フレームを保存する">手順3：PNG形式で各フレームを保存する</a></h3>
<p>動画に表示されている動きの全フレームをPNG画像形式で出力させます。これは<strong>File</strong>, <strong>Export Movie As</strong>, <strong>PNG Images</strong>から選択することができます。</p>
<img src="ch05/./image/movie/movie5.png" width="100%" title="">
<p>Moview Exportのダイアログボックスでは出力画像サイズを設定することができます。もしここで当初予定していた画像サイズから変わっていれば（少し変わっていることがよくあります）、その数字を修正しておきます。また、RenderingオプションはRay(Slow)の方がきれいに出力されますが、その分時間がかかります。今回はRayでやります。</p>
<p>最後に一番下のSave Movie as...から出力先のディレクトリを選択します。このとき、出力先ディレクトリは新規ディレクトリを作成してからその中に保存することを強く勧めます。こうしないと画像が散らばって面倒です。</p>
<p>今回の例では保存先をmovietestというディレクトリ上に保存することにします。そしてSave Asの名前欄に<code>ALP</code>と入力します（この文字は画像のprefixなので任意の文字列でOKです）。</p>
<img src="ch05/./image/movie/movie6.png" width="100%" title="">
<p>すると、出力先のmovietestディレクトリにALP0001.png, ALP0002.png, ... といった具合にすべてのフレームの画像が出力されます。しばらくかかるのでこのまますべて終わるまでじっくり待ちます。</p>
<h3 id="手順4背景画像を使ってffmpegで動画を生成する"><a class="header" href="#手順4背景画像を使ってffmpegで動画を生成する">手順4：背景画像を使ってffmpegで動画を生成する</a></h3>
<p>好きな背景画像を適当に用意します。今回は以下のものを使いました。</p>
<img src="ch05/./image/movie/bg.jpg" width="100%" title="">
<p>画像サイズはあらかじめ出力したタンパク質の画像サイズ（1280 x 720）と合わせておくと良いでしょう。画像の切り抜きにはコマンドラインツールのImagemagickを使うこともできます。詳しくは<a href="https://qiita.com/yoya/items/62879e6e03d5a70eed09">ImageMagick の画像 Crop</a>の記事などを参考にしてください。</p>
<p>この背景画像を<code>bg.jpg</code>として、先程のmovietestディレクトリに置きます。その後、以下のコマンドでffmpegを実行するだけで、動画ファイル<code>out.mp4</code>が生成されます。</p>
<pre><code class="language-bash">$ ffmpeg -r 30 -i bg.jpg -vf 'movie=ALP%4d.png [over], [in][over] overlay' -vcodec libx264 -pix_fmt yuv420p out.mp4
</code></pre>
<ul>
<li><code>-r</code>：フレームレート</li>
<li><code>-i</code>：インプット画像</li>
<li><code>-vcodec libx264</code>：スマートフォン向けの動画(H.264+aac)に変換</li>
<li><code>-pix_fmt yuv420p</code>：エンコーダに渡すピクセルフォーマットを指定。yuv420pはH.264動画変換のときのデフォルトらしい</li>
<li><code>-vf 'movie=ALP%4d.png [over], [in][over] overlay'</code>：ALPではじまる連番画像をインプット画像の上に重ねる</li>
</ul>
<p>これで動画が出力されました。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/alpmovie.mp4" type="video/mp4">
</video>
<h3 id="その他"><a class="header" href="#その他">その他</a></h3>
<p>MDシミュレーションでトラジェクトリを表示させたときのタンパク質が動いている様子もこれと同様の手順で出力することができます。</p>
<h2 id="表示形式のプリセット"><a class="header" href="#表示形式のプリセット">表示形式のプリセット</a></h2>
<p>PyMOLのオブジェクトパネルのAボタンの中には<code>preset</code>と言うメニューがあります。これを使うと、様々な表示形式に一発で変換できます。</p>
<img src="ch05/./image/preset/menu.png" width="60%" title="">
<ul>
<li>classified</li>
<li>simple</li>
<li>simple (no solvent)</li>
<li>ball and stick</li>
<li>b factor putty</li>
<li>technical</li>
<li>ligands</li>
<li>ligand sites
<ul>
<li>cartoon</li>
<li>solid surface</li>
<li>solid (better)</li>
<li>transparent surface</li>
<li>transparent (better)</li>
<li>dot surface</li>
<li>mesh surface</li>
</ul>
</li>
<li>pretty</li>
<li>pretty (with solvent)</li>
<li>publication</li>
<li>publication (with solvent)</li>
<li>protein interface</li>
<li>default</li>
<li>hydropathy</li>
</ul>
<p>以上のプリセットが用意されています（ver. 2.5.0 時点）。</p>
<p>このプリセットが選択された時、内部処理的には一度デフォルト形式である<code>classified</code>を設定してから選択されたプリセットの描画設定を上書きしていく形で適用しています。ただし<code>pymolrc</code>に書かれたいくつかの設定値（<code>transparency</code>, <code>surface_quality</code>, <code>surface_type</code>, <code>sphere_scale</code>, <code>stick_radius</code>, <code>stick_color</code>, <code>cartoon_highlight_color</code>, <code>cartoon_fancy_helices</code>, <code>cartoon_smooth_loops</code>, <code>cartoon_flat_sheets</code>, <code>cartoon_side_chain_helper</code>など）は<code>auto_show_classified</code>としてPyMOL起動時に記憶され、<code>classified</code>は描画形式以外この値を利用します。</p>
<p>プリセットの定義は、<code>modules/pymol/preset.py</code> の中に書かれてあります。 https://github.com/schrodinger/pymol-open-source/blob/master/modules/pymol/preset.py も参考にすると良いでしょう。</p>
<p>ここではギャラリー風に紹介していきます。</p>
<h3 id="classified"><a class="header" href="#classified">classified</a></h3>
<p>現在PyMOLのデフォルト設定に最も近い描画形式です。タンパク質構造はCartoon表示、リガンドはSphere表示です。デフォルト設定との細かな違いとして、水分子がwire-nonbonded表示されないなどが挙げられますが、<strong>デフォルトの描画設定に戻したいときはこの設定を呼び出すと良いでしょう</strong>。</p>
<p>ただし、色設定は変化しないため、手動で戻す必要があります。</p>
<p><img src="ch05/./image/preset/classified.png" width="50%" alt="classified" title="classified"><img src="ch05/./image/preset/classified2.png" width="50%" alt="classified" title="classified"></p>
<p>コマンドで行いたい場合は、以下の<code>objectname</code>部分をオブジェクト名に変えて実行します（例: 1ALK）。以下同様。</p>
<blockquote>
<p>preset.classified(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="simple"><a class="header" href="#simple">simple</a></h3>
<p>タンパク質構造は主鎖だけをシンプルに表示するribbon表示、リガンドはStick表示になります。また、チェインごとに自動で色分けがなされます。</p>
<p><img src="ch05/./image/preset/simple.png" width="50%" alt="simple" title="simple"><img src="ch05/./image/preset/simple2.png" width="50%" alt="simple" title="simple"></p>
<blockquote>
<p>preset.simple(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="simple-no-solvent"><a class="header" href="#simple-no-solvent">simple (no solvent)</a></h3>
<p>上記simple表示について、溶媒の表示がなくなったものです。</p>
<p><img src="ch05/./image/preset/simplenos.png" width="50%" alt="simple" title="simple"><img src="ch05/./image/preset/simplenos2.png" width="50%" alt="simple" title="simple"></p>
<blockquote>
<p>preset.simple_no_solv(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="ball-and-stick"><a class="header" href="#ball-and-stick">ball and stick</a></h3>
<p>各原子を小さめのボールで表し、結合を白色のスティックで表示します。色分けは変化しません。</p>
<p><img src="ch05/./image/preset/bs.png" width="50%" alt="ball and stick" title="ball and stick"><img src="ch05/./image/preset/bs2.png" width="50%" alt="ball and stick" title="ball and stick"></p>
<blockquote>
<p>preset.ball_and_stick(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="b-factor-putty"><a class="header" href="#b-factor-putty">b factor putty</a></h3>
<p>温度因子であるB factorをもとに色付けし、さらに温度因子が大きいほど太くチューブ状に表示します。温度因子は青色ほど低く、赤色ほど高くなっています。この表示では主鎖構造のみが表示されます。</p>
<p><img src="ch05/./image/preset/bfactor.png" width="50%" alt="B factor putty" title="B factor putty"><img src="ch05/./image/preset/bfactor2.png" width="50%" alt="B factor putty" title="B factor putty"></p>
<blockquote>
<p>preset.b_factor_putty(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="technical"><a class="header" href="#technical">technical</a></h3>
<p>各チェインのN末端からC末端にかけて青色→赤色となるようなRainbowカラーリングが適用されます。また、水素結合が自動的に検出され、<code>&lt;objectname&gt;_pol_conts</code>というオブジェクトが生成されます。水素結合を表示させたくない場合はオブジェクトパネル上でこの<code>&lt;objectname&gt;_pol_conts</code>の表示をOFFにすればOKです。</p>
<p><img src="ch05/./image/preset/technical.png" width="50%" alt="technical" title="technical"><img src="ch05/./image/preset/technical2.png" width="50%" alt="technical" title="technical"></p>
<blockquote>
<p>preset.technical(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="ligands"><a class="header" href="#ligands">ligands</a></h3>
<p>上述のRainbowカラーリングが施され、基本的には主鎖構造のみのribbon表示になりますが、リガンドから一定範囲のみ側鎖を含んだline表示が行われ、リガンドへの水素結合自動検出処理が行われます。</p>
<p>カメラもそのリガンド周辺にズームしてくれますが、リガンドが複数ある場合はそれらの中間にカメラを合わせてしまうようです。</p>
<p><img src="ch05/./image/preset/ligands.png" width="50%" alt="ligands" title="ligands"><img src="ch05/./image/preset/ligands2.png" width="50%" alt="ligands" title="ligands"></p>
<blockquote>
<p>preset.ligands(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="ligand-sites"><a class="header" href="#ligand-sites">ligand sites</a></h3>
<p>上記ligands設定の拡張版と言えます。様々な表示形式が用意されています。いずれのプリセットでも水素結合を検出し、<code>&lt;objectname&gt;_pol_conts</code>というオブジェクトを生成します。</p>
<h4 id="cartoon"><a class="header" href="#cartoon">Cartoon</a></h4>
<p>タンパク質をCartoon表示のままRainbowカラーリング、リガンドをStick表示で、周辺の一定範囲のみline表示にします。</p>
<p><img src="ch05/./image/preset/ligcartoon.png" width="50%" alt="ligcartoon" title="ligcartoon"><img src="ch05/./image/preset/ligcartoon2.png" width="50%" alt="ligcartoon" title="ligcartoon"></p>
<blockquote>
<p>preset.ligand_cartoon(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="solid-surface"><a class="header" href="#solid-surface">solid surface</a></h4>
<p>タンパク質をribbon表示, Rainbowカラーリング, リガンドをStick表示, 周辺の一定範囲のみsurface表示にします。</p>
<p><img src="ch05/./image/preset/solsurf.png" width="50%" alt="solid surface" title="solid surface"><img src="ch05/./image/preset/solsurf2.png" width="50%" alt="solid surface2" title="solid surface2"></p>
<blockquote>
<p>preset.ligand_sites(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="solid-better"><a class="header" href="#solid-better">solid (better)</a></h4>
<p>上記solid surfaceプリセット表示のsurfaceクオリティが上がったものです。設定としては<code>set surface_quality, 1</code>を追加しています。</p>
<p><img src="ch05/./image/preset/solbetter.png" width="50%" alt="solid (better)" title="solid (better)"><img src="ch05/./image/preset/solbetter2.png" width="50%" alt="solid (better)" title="solid (better)"></p>
<blockquote>
<p>preset.ligand_sites_hq(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="transparent-surface"><a class="header" href="#transparent-surface">transparent surface</a></h4>
<p>上記solid surfaceの透明度を上げ(<code>set transparency, 0.33</code>)、周辺の残基をstick表示にしたものです。</p>
<p><img src="ch05/./image/preset/transsurf.png" width="50%" alt="transparent surface" title="transparent surface"><img src="ch05/./image/preset/transsurf2.png" width="50%" alt="transparent surface" title="transparent surface"></p>
<blockquote>
<p>preset.ligand_sites_trans(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="transparent-better"><a class="header" href="#transparent-better">transparent (better)</a></h4>
<p>上記transparent surfaceプリセット表示のsurfaceクオリティが上がったものです。設定としては<code>set surface_quality, 1</code>を追加しています。</p>
<p><img src="ch05/./image/preset/transbetter.png" width="50%" alt="transparent (better)" title="transparent (better)"><img src="ch05/./image/preset/transbetter2.png" width="50%" alt="transparent (better)" title="transparent (better)"></p>
<blockquote>
<p>preset.ligand_sites_trans_hq(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="dot-surface"><a class="header" href="#dot-surface">dot surface</a></h4>
<p>上記solid surfaceの表面表示をdotにしたものです。</p>
<p><img src="ch05/./image/preset/dotsurface.png" width="50%" alt="dot surface" title="dot surface"><img src="ch05/./image/preset/dotsurface2.png" width="50%" alt="dot surface" title="dot surface"></p>
<blockquote>
<p>preset.ligand_sites_dots(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="mesh-surface"><a class="header" href="#mesh-surface">mesh surface</a></h4>
<p>上記solid surfaceの表面表示をdotにしたものです。</p>
<p><img src="ch05/./image/preset/meshsurface.png" width="50%" alt="mesh surface" title="mesh surface"><img src="ch05/./image/preset/meshsurface2.png" width="50%" alt="mesh surface" title="mesh surface"></p>
<blockquote>
<p>preset.ligand_sites_mesh(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="pretty"><a class="header" href="#pretty">pretty</a></h3>
<p>生体分子のレインボー表示、リガンドをstick形式で表示します。</p>
<p><img src="ch05/./image/preset/pretty.png" width="50%" alt="pretty" title="pretty"><img src="ch05/./image/preset/pretty2.png" width="50%" alt="pretty" title="pretty"></p>
<blockquote>
<p>preset.pretty(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="pretty-with-solvent"><a class="header" href="#pretty-with-solvent">pretty (with solvent)</a></h3>
<p>上記prettyに加えて溶媒やリガンドをnb_spheres表示にします。</p>
<p><img src="ch05/./image/preset/prettywiths.png" width="50%" alt="pretty (with solvent)" title="pretty (with solvent)"><img src="ch05/./image/preset/prettywiths2.png" width="50%" alt="pretty (with solvent)" title="pretty (with solvent)"></p>
<blockquote>
<p>preset.pretty_solv(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="publication"><a class="header" href="#publication">publication</a></h3>
<p>cartoon表示において、</p>
<ul>
<li>ループ構造のスムージング<code>set cartoon_smooth_loops, 1</code></li>
<li>ヘリックスやシートの内部を灰色に設定<code>set cartoon_highlight_color, grey50</code></li>
<li>ヘリックスのファンシー化<code>set cartoon_fancy_helices, 1</code></li>
<li>シート構造の平坦化（初期設定でON）<code>set cartoon_flat_sheets, 1</code></li>
<li>側鎖構造のみの表示（初期設定でON）<code>set cartoon_side_chain_helper, 0</code></li>
</ul>
<p>を行います。</p>
<p><img src="ch05/./image/preset/pub.png" width="50%" alt="publication" title="publication"><img src="ch05/./image/preset/pub2.png" width="50%" alt="publication" title="publication"></p>
<blockquote>
<p>preset.publication(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="publication-with-solvent"><a class="header" href="#publication-with-solvent">publication (with solvent)</a></h3>
<p>上記の溶媒表示版です。</p>
<p><img src="ch05/./image/preset/pubwiths.png" width="50%" alt="publication (with solvent)" title="publication (with solvent)"><img src="ch05/./image/preset/pubwiths2.png" width="50%" alt="publication (with solvent)" title="publication (with solvent)"></p>
<blockquote>
<p>preset.pub_solv(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="protein-interface"><a class="header" href="#protein-interface">protein interface</a></h3>
<p>異なるチェインの境目から4.5 Å以内に一部でも含まれる残基をStick表示にします。</p>
<p><img src="ch05/./image/preset/proint.png" width="50%" alt="protein interface" title="protein interface"><img src="ch05/./image/preset/proint2.png" width="50%" alt="protein interface" title="protein interface"></p>
<blockquote>
<p>preset.interface(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="default"><a class="header" href="#default">default</a></h3>
<p>PyMOL 1時代はこのシンプルなライン表示だけの形式がデフォルト表示でした。Defaultとついていますが、現在はデフォルト設定ではなくなり、classified presetに取って替わられています。</p>
<p><img src="ch05/./image/preset/default.png" width="50%" alt="default" title="default"><img src="ch05/./image/preset/default2.png" width="50%" alt="default" title="default"></p>
<blockquote>
<p>preset.default(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h2 id="gaussian-16のcubeファイルを開いて分子軌道を表示する"><a class="header" href="#gaussian-16のcubeファイルを開いて分子軌道を表示する">Gaussian 16のcubeファイルを開いて分子軌道を表示する</a></h2>
<img src="ch05/./image/gaus1.png" width="700" title="Gaussian 16での分子軌道の表示例">
<p>PyMOLは、<a href="https://www.ks.uiuc.edu/Research/vmd/">VMD</a>とまでは行きませんが、様々なファイルの可視化にも対応しています。今回紹介するのは、Gaussian 16などで計算された分子の分子軌道（molecular orbital）をPyMOL上で表示させるテクニックです。</p>
<p>GaussView 6やVMD 1.9.4などの他のソフトを用いて可視化してもよいのですが、タンパク質の構造生物学をやっている人ならだいたい使ったことがあり、扱いに慣れているPyMOLで見られれば、共同研究のときとかに喜ばれると考えられます。</p>
<p>ここでは、簡単な計算の例を示しながら、それをGaussViewまたはPyMOLで分子軌道を表示する時の方法を紹介します。</p>
<h3 id="分子軌道を表示するのに必要な環境"><a class="header" href="#分子軌道を表示するのに必要な環境">分子軌道を表示するのに必要な環境</a></h3>
<ul>
<li>GaussView 6, VMD, PyMOL 2.3.0以降のうち、いずれか1つをインストールしてあるパソコン</li>
</ul>
<p>この記事ではGaussView 6またはPyMOL 2.3.0での方法を示します</p>
<h3 id="example-1-1-シクロペンタジエンの場合"><a class="header" href="#example-1-1-シクロペンタジエンの場合">Example 1-1. シクロペンタジエンの場合</a></h3>
<p>例として、シクロペンタジエン分子の構造をGaussian 16（<code>g16</code>）で構造最適化させ、分子軌道を計算させてみます。インプットファイル<code>cyclopenta.gjf</code> を以下のように書いて<code>g16</code>で計算させます。</p>
<pre><code>%chk=cyclopenta.chk
%mem=20GB
%nprocshared=12
#p opt b3lyp/6-311g(d,p) pop=full

Title

0 1
 C                 -1.78668958   -0.09572728    0.64728372
 C                 -1.36269158    1.27506872    0.64728372
 H                 -1.14231658   -0.96843328    0.64730872
 H                 -0.33812858    1.63156072    0.64725872
 C                 -3.62816658    1.22478072    0.64727472
 H                 -4.64865477    1.54029066    0.71018208
 C                 -3.18843958   -0.09572728    0.64728372
 H                 -3.80595672   -0.96740593    0.58605536
 C                 -2.51974858    2.06652172    0.64717972
 H                 -2.52502738    2.68450968    1.52065726
 H                 -2.55124904    2.68351582   -0.22644835

</code></pre>
<p><code>%mem=20GB</code>部分は計算にメモリを20GB使用するということ、<code>%nprocshared=12</code>は計算で使うCPU数を指定します。この値は各計算環境に応じて適宜変更する必要があります。ここで、重要なのは計算条件を指定する<code>#p opt pop=full</code>の部分です。<code>opt pop=full</code>で構造最適化計算と、電子密度解析計算を行うよう指示します。計算レベルや基底関数については<code>b3lyp/6-311g(d,p)</code>でなくても好みのものを使ってください。
（ちなみにGaussian 16だと<code>%nprocshared</code>の指定は非推奨になっています。最近実装された、環境変数での指定方法のほうが使い勝手が良いと思います。さらに、GPUを使った計算をしたい場合にはもっと別の指定方法になります。 参考： http://www.hpc.co.jp/gaussian_Link-0-Equivs.html ）</p>
<p>実行コマンド例は</p>
<pre><code class="language-bash">#!/bin/bash
job=&quot;cyclopenta&quot;
export GAUSS_CDEF=&quot;0-11&quot; # cyclopenta.gjfファイルの%nprocshared=12に対応

g16 &lt; ${job}.gjf &gt; ${job}.log
</code></pre>
<p>計算が終わりますと、計算結果の<code>cyclopenta.log</code>ファイルだけでなく、.chk（チェックポイント）ファイル<code>cyclopenta.chk</code>も生成されているはずです。分子軌道の可視化や以降の処理にはこのファイルを用います。</p>
<h3 id="example-1-2-chkファイルの処理"><a class="header" href="#example-1-2-chkファイルの処理">Example 1-2. chkファイルの処理</a></h3>
<p>このchkファイルを用いて、まずターミナル上での以下のコマンドで、formatted checkpoint file形式に変換します。</p>
<pre><code>formchk cyclopenta.chk cyclopenta.fchk
</code></pre>
<p>として、formatted checkpoint fileに変換します。この<code>formchk</code>コマンドはGaussian 16と同時にインストールされているはずのコマンドです。Gaussian 16がインストールされてあるマシンやスパコンでは、Gaussian 16の本体である<code>g16</code>コマンドが使えるならば、ほぼ間違いなく使えるはずです。
（ちなみにGaussian 16で計算したchkファイルをGaussian 09時代の<code>formchk</code>コマンドで変換することはできない……かもしれません）</p>
<p>続いて、上のコマンドで作成された<code>cyclopenta.fchk</code>ファイルから、必要な分子軌道のデータを<code>.cube</code>形式のファイルに抽出します。</p>
<pre><code>cubegen 0 MO=homo cyclopenta.fchk cyclopenta_homo.cube
</code></pre>
<p>この<code>cubegen</code>についての操作方法はGaussian公式の<a href="http://gaussian.com/cubegen/">cubegenの解説ページ</a>のページを参照してください。MO=のあとにhomoやlumo、または数字を指定すると、それに対応した分子軌道が出力されます。
今回はシクロペンタジエンのHOMO（最高被占軌道）のデータを取り出したいので、MO=homoとし、.fchkファイルと出力ファイル名<code>cyclopenta_homo.cube</code>を指定します。</p>
<h3 id="example-1-3-cubeファイルの表示"><a class="header" href="#example-1-3-cubeファイルの表示">Example 1-3. cubeファイルの表示</a></h3>
<h4 id="case-1-gaussview-6で表示する"><a class="header" href="#case-1-gaussview-6で表示する">Case 1. GaussView 6で表示する</a></h4>
<p>GaussView 6で表示する時、必要になるファイルは<code>cyclopenta.log</code>と<code>cyclopenta_homo.cube</code>です。まずはふつうに<code>cyclopenta.log</code>を開きます。</p>
<img src="ch05/./image/gaus2.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>続いて、Results &gt; Surfaces/Contoursを選択し、Cube ActionsからLoad Cubeを選び、<code>cyclopenta_homo.cube</code>を選択します。</p>
<img src="ch05/./image/gaus3.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>続いて、Surface Actions &gt; New Surfaceをクリックすると、分子軌道の図が表示されるようになります。</p>
<img src="ch05/./image/gaus4.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>このSurfaceの描画モードを変えたい場合は、この紫の画面内で右クリックし、View -&gt; Display Formatを選択します（macOSはCommand+DでもOK）。</p>
<img src="ch05/./image/gaus5.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>このDisplay Formatウィンドウの中で、右端のSurfaceタブを選び、Format: transparentとすれば、半透明な表面を描画することができます。透明度はそこのスライダで調節できます。またmesh表示も可能です。</p>
<img src="ch05/./image/gaus6.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>以下では、この部分をPyMOLでやってみる方法を紹介します。</p>
<h4 id="case-2-pymol-230で表示する"><a class="header" href="#case-2-pymol-230で表示する">Case 2. PyMOL 2.3.0で表示する</a></h4>
<p>PyMOLで開く場合には、</p>
<ol>
<li><code>cyclopenta.log</code>の最終構造に対応する構造ファイルをPDB形式などで用意し、PyMOLに表示させる</li>
<li>この上に<code>cyclopenta_homo.cube</code>をロードし、適切な処理を施す。</li>
</ol>
<p>という流れになります。このうち、1.で述べた構造ファイルを用意する部分はやや面倒かもしれません。お使いのマシンに<a href="https://qiita.com/Ag_smith/items/d2e86dda17f190a3dd0f">AmberTools 18がインストールされている</a>状態であれば、</p>
<pre><code>antechamber -i cyclopenta.log -fi gout -o cyclopenta.pdb -fo pdb
</code></pre>
<p>とすることで最終構造のPDBファイルを一発変換できます。AmberToolsがない場合は、オープンソースのファイルコンバータである<a href="https://future-chem.com/open-babel-usage/">Open Babelを使った変換法</a>で代用できます。Homebrewのインストール方法は適当にググってください。</p>
<pre><code># Open BabelをHomebrewでインストール
brew install open-babel
# Usage:
# obabel [-i&lt;input-type&gt;] &lt;infilename&gt; [-o&lt;output-type&gt;] -O&lt;outfilename&gt; [Options]
# input-typeにはまだg16フォーマットがサポートされていないのですが、g09で代用可能だと思います。
# see also 'http://openbabel.org/docs/current/FileFormats/Overview.html#file-formats'
obabel -i g09 cyclopenta.log -o pdb -O cyclopenta.pdb
</code></pre>
<p>こうしてファイル形式を変換して作成した<code>cyclopenta.pdb</code>をPyMOLで開いてみます。</p>
<img src="ch05/./image/gaus7.png" width="600" title="Gaussian 16での分子軌道の表示例">
<p>んー、本来は二重結合になっている炭素の結合情報が、全部同じような線で繋がれてしまっていますね。これが嫌だな〜って方は、以下のようにして二重結合っぽい表示に変えてみます。</p>
<p>二重結合にしたい原子の上でそれぞれ右のダブルクリック（マウスにホイールがある場合はホイールクリックでも可能）をすると、Pk1, Pk2という選択印が付きます。この状態で、PyMOLのコマンド <code>unbond ; bond order=2</code> を実行します（コマンド入力できるフォームは2箇所ありますが、どちらに入れても同じです）。この<code>order=2</code>で結合次数を指定しています。</p>
<img src="ch05/./image/gaus8.png" width="600" title="Gaussian 16での分子軌道の表示例">
<p>これで二重結合っぽい表示に変わりました。ついでに、好みで以下の設定を入れてGaussViewっぽい描画設定にしてみます。</p>
<pre><code>show sticks
show spheres
set stick_radius, 0.1
set sphere_scale, .22
set sphere_scale, .18, elem H
</code></pre>
<img src="ch05/./image/gaus9.png" width="600" title="Gaussian 16での分子軌道の表示例">
<p>では、PyMOLに<code>cyclopenta_homo.cube</code>ファイルをロードします。コマンドは以下の通り</p>
<pre><code>load /path/to/cyclopenta_homo.cube
isosurface Asurf1, cyclopenta_homo, 0.02
isosurface Bsurf1, cyclopenta_homo, -0.02
color red, Asurf1
color blue, Bsurf1
set transparency, 0.5
</code></pre>
<p><code>load</code>部分は、<code>cyclopenta_homo.cube</code>のファイルのあるファイルパスを指定します。デスクトップ上に置いてあるならば<code>load ~/Desktop/cyclopenta_homo.cube</code>みたいに。以下の<code>isosurface</code>コマンドで分子軌道をしきい値0.02, -0.02で作成します。正と負の波動関数に対応する各電子雲をAsurf1, Bsurf1というオブジェクト名で作成し、色付けを red, blueにしています。</p>
<img src="ch05/./image/gaus10.png" width="600" title="Gaussian 16での分子軌道の表示例">
<p>Asurf1, Bsurf1の色変更は、PyMOLのオブジェクト色変更と同じ感覚でマウスを使って簡単に変更できます。</p>
<h2 id="pymol上でのpythonスクリプトの実行基本編"><a class="header" href="#pymol上でのpythonスクリプトの実行基本編">PyMOL上でのpythonスクリプトの実行：基本編</a></h2>
<p>PyMOLの大きな強みの1つとして、PyMOLのコマンドラインからpythonスクリプトを実行させることができることが挙げられます。ここではいくつかの例を挙げながら、PyMOL上でのpythonスクリプト実行機能を紹介してみます。ただし、python3についての基本的な知識があることを前提とします。</p>
<h3 id="pythonの設定を確認する"><a class="header" href="#pythonの設定を確認する">Pythonの設定を確認する</a></h3>
<p>まずは現在PyMOLが動作しているPython環境を確認するために、バージョン情報とPATHをPyMOLのコマンド入力欄から確認してみましょう。コマンドは通常のpythonと同じように</p>
<pre><code class="language-python"># pythonのバージョンを表示
import sys
print(sys.version)
# pythonのモジュール検索PATHを確認
print(sys.path)
</code></pre>
<p>となります。返り値は、私の環境（macOSのHomebrewでインストールした場合）では</p>
<pre><code class="language-shell"># PyMOL&gt;print(sys.version)
3.10.8 (main, Oct 13 2022, 09:48:40) [Clang 14.0.0 (clang-1400.0.29.102)]
# PyMOL&gt;print(sys.path)
['', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python310.zip', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload', '/Users/YoshitakaM/Library/Python/3.10/lib/python/site-packages', '/usr/local/lib/python3.10/site-packages', '/usr/local/lib/python3.10/site-packages/coot', '/usr/local/lib/python3.10/site-packages/coot/rcrane', '/usr/local/Cellar/pybind11/2.10.0/libexec/lib/python3.10/site-packages', '/usr/local/Cellar/pymol/2.5.0/libexec/lib/python3.10/site-packages', '/usr/local/Cellar/sip/6.6.2_1/libexec/lib/python3.10/site-packages', '/usr/local/Cellar/modeller/10.3_1/modlib', '/usr/local/opt/python-tk@3.10/libexec', '/Users/YoshitakaM/apps/pymol-psico']
</code></pre>
<p>のようになりました。<code>print(sys.path)</code>で表示されたPATHからはモジュールをimportすることができます。</p>
<h3 id="pythonスクリプトをpymol上で実行する"><a class="header" href="#pythonスクリプトをpymol上で実行する">PythonスクリプトをPyMOL上で実行する</a></h3>
<p>PyMOLコマンドラインからは<code>python</code>と<code>python end</code>という入力の間に任意のpythonスクリプトを挟むことで、PyMOL上で擬似インタラクティブにコマンドを実行することができます。ただし、一度<code>python</code>を入力した後は<code>python end</code>を入力するまではフィードバックが得られないことに注意しましょう。</p>
<p>例えば、以下のように変数<code>x</code>に<code>10</code>という値を入れてそれをprintさせるだけの簡単なスクリプトをコマンドラインに入力してみます。</p>
<pre><code class="language-python">python
x = 10
print(x)
python end
</code></pre>
<p>PyMOLのアウトプットとしては</p>
<pre><code class="language-shell">PyMOL&gt;python
PyMOL&gt;x = 10
    1:x = 10
PyMOL&gt;print(x)
    2:print(x)
PyMOL&gt;python end
PyMOL&gt;python end
10
</code></pre>
<p>というように表示され、最後に<code>10</code>という結果がprintされたことがわかります。</p>
<p>この機能を使えば、Pythonを使い慣れた方であれば様々な応用可能性があることに気づくと思います。例えば、あるディレクトリの中で目的の構造ファイル群だけPyMOL上にロードしたいという例では、以下のようにPythonスクリプトを書くことができます。</p>
<pre><code class="language-python"># globモジュールをインポートし、ワイルドカード*によって
# 拡張子がcifであるファイルを一括でPyMOL上にロードする
python
from glob import glob

for file in glob(&quot;*.cif&quot;):
    cmd.load(file)
python end
</code></pre>
<h3 id="コマンドを外部ファイルに保存しpymolからスクリプトを呼び出す"><a class="header" href="#コマンドを外部ファイルに保存しpymolからスクリプトを呼び出す">コマンドを外部ファイルに保存し、PyMOLからスクリプトを呼び出す</a></h3>
<p>上で挙げた一括ロードのPythonスクリプトを繰り返し使いたいときは、別ファイルにスクリプトを保存しておいてそれを呼び出すような形にすれば、毎回入力しなくて済むようになります。この場合は、<code>python</code>と<code>python end</code>の間の部分だけを別のファイル（名前は<code>cifload.py</code>とします）に書いておきます。</p>
<pre><code class="language-python:cifload.py">from glob import glob

for file in glob(&quot;*.cif&quot;):
    cmd.load(file)
</code></pre>
<p>これをPyMOL上から呼び出すときには、コマンドラインから<code>run /path/to/cifload.py</code>として呼び出します（<code>/path/to/</code>の部分は<code>cifload.py</code>が存在するディレクトリパスに適宜置き換えてください）。</p>
<h3 id="拡張コマンドを使えるように読み込む"><a class="header" href="#拡張コマンドを使えるように読み込む">拡張コマンドを使えるように読み込む</a></h3>
<p>発展的な内容ですが、上記の方法を使えばPyMOLWikiのScript Libraryなどで公開されている拡張コマンドを即座に使えるようにすることもできます。例として, タンパク質の色分けをアミノ酸の疎水性〜親水性に応じて行う<code>color_h</code>, <code>color_h2</code>コマンド（<a href="https://pymolwiki.org/index.php/Color_h">https://pymolwiki.org/index.php/Color_h</a>）を使えるようにします。</p>
<p>上記ページのコードの<code>from pymol import cmd</code>から<code>cmd.extend('color_h2',color_h2)</code>の前に<code>python</code>を、最後に<code>python end</code>を入力することで、<code>color_h</code>, <code>color_h2</code>コマンドが使えるようになります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/scripting1.mp4" type="video/mp4">
</video>
<p>これによって<code>color_h</code>, <code>color_h2</code>の拡張コマンドが使えるようになりました。もちろん、外部ファイルに保存しておいて<code>run ~~</code>で呼び出すことも可能です。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="結晶構造の電子密度マップを表示する-1"><a class="header" href="#結晶構造の電子密度マップを表示する-1">結晶構造の電子密度マップを表示する</a></h2>
<p>PyMOLは結晶構造の電子密度データを表示させることも可能です。</p>
<p>例としてPDB: 3TG0の大腸菌由来アルカリホスファターゼの電子密度マップを取得して表示させてみます。PDB ID:1ALKのものは電子密度マップがデータベースに登録されていないため、代わりにほぼ同一な構造情報をこちらを例として用います。</p>
<pre><code># インターネットから3tg0のPDBデータをダウンロード。
fetch 3tg0
# 3tg0の電子密度マップ（2fofc形式）を3tg0_mapというオブジェクトでダウンロードし、表示する
fetch 3tg0, 3tg0_map, type=2fofc
# A chainに結合している無機リン酸PO4に注目する
center /3tg0/H/A/PO4`504
</code></pre>
<p>ここまでのロードが終了すると、オブジェクトパネルに<code>3tg0_map</code>というオブジェクトが追加されているはずです。ここで、続いて上部メニューバーからWizard -&gt; Densityを選択します。</p>
<p><img src="ch05/./image/emap1.png" alt="3-1-1" title="Wizard-Density" /></p>
<p>この操作によって、現在の視点周辺に青色の電子密度マップが重なって表示されるようになります。</p>
<p><img src="ch05/./image/emap2.png" alt="3-1-2" title="Wizard-Density" /></p>
<p>ここで、電子密度マップは<code>w1_3tg0_map</code>というオブジェクト名になっています。各種表示を変更するには以下の部分をクリックして操作します。</p>
<ul>
<li>色はオブジェクトパネルのCボタンから変更することができます。positiveとnegativeそれぞれについて別の色を指定することができます。デフォルトの青色メッシュは濃くて見えにくいので、もう少し薄い色を指定すると見やすくなるでしょう。</li>
<li><code>Density Map Wizard</code>と書かれた部分の中の<code>Radius</code>の部分をクリックすることで、電子密度の表示範囲を変更することができます。</li>
<li><code>@ 1.0 sigma</code>と書かれているところをクリックすると、電子密度メッシュの表示範囲を変更することができます。sigmaの数字が大きいほど、表示されるメッシュの範囲は小さくなります。</li>
<li>デフォルトではMap 1のみが働いていますが、Map 2、Map 3部分をクリックしてオブジェクト名を指定すれば、さらに重ねて電子密度マップを表示することができます。異なるsigmaのメッシュを色違いで表示させることも可能です。</li>
<li>表示設定をやり直したいときは<code>w1_3tg0_map</code>のAボタンをクリックし、<code>delete object</code>をした後、下のWizardの<code>Update Maps</code>を押せば電子密度が再び表示されるようになります。</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="apbsプラグインを使った表面電荷表示-1"><a class="header" href="#apbsプラグインを使った表面電荷表示-1">APBSプラグインを使った表面電荷表示</a></h2>
<p>PyMOLのプラグインでデフォルトでインストールされている<strong>APBS</strong>を使って表面電荷を表示してくれる方法を説明します。</p>
<img src="ch05/./image/apbs1.png" title="APBSの表示例">
<p>このプラグインは、インストーラー版を使ってPyMOL 2をインストールした場合にはその中に同梱されているので別段の準備は必要ありませんが、オープンソース版をインストールした場合には様々な準備が必要となりますので、下にある<a href="ch05/apbs.html#apbs%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">HomebrewでAPBS, PDB2PQRをインストールしておきます</a>。まずはAPBSプラグインの使い方を説明します。</p>
<h3 id="apbsを使ってみる-1"><a class="header" href="#apbsを使ってみる-1">APBSを使ってみる</a></h3>
<p>今回は例としてPDB: 3x2oの構造のみを開いた状態にしておきます。その後、まず上部メニューの[Plugin]を選択し、次に[APBS Electrostatics]を選択します。</p>
<img src="ch05/./image/apbsmenu1.png" width="300px" title="APBSmenu1">
<p>中のメニューはこうなっています。</p>
<img src="ch05/./image/apbsmenu2.png" width="300px" title="APBSmenu2">
<p>Mainのタブでまず<code>selection</code>部分を確認します。この例では<code>polymer &amp; 3x2o</code>という表示になっていますが、これはアミノ酸20種類かつオブジェクト3x2oが選択されていることを意味し、この選択範囲についてAPBSの電荷計算をこれから行うことを意味します。</p>
<p>この選択範囲に問題がなければ、このメニューの下の方にあるRunボタンを押すだけでAPBSの計算が動き出します。途中Warnings: &quot;do you want to continue?&quot;が表示された場合はYesと答えておきましょう。</p>
<img src="ch05/./image/apbsmenu6.png" title="APBSmenu6">
<p>正常にAPBSの計算が終わると、Close the APBS dialog?と問われます。閉じてもOKです。</p>
<img src="ch05/./image/apbsmenu7.png" title="APBSmenu7">
<p>計算が終わると、このように3x2oの表面が赤・白・青に分けて表示されるようになりました。</p>
<img src="ch05/./image/apbs4.png" title="APBS4">
<p><strong>赤は負電荷の多い箇所、青は正電荷の多い箇所</strong>を表しています。白は中性です。</p>
<p>右側のInternal GUIのメニューには<code>run01</code>というオブジェクトグループが新しく増えています。ここの＋マークを押すと子オブジェクトが現れます。このうち<code>apbs_ramp01</code>というオブジェクトの<code>A</code>メニューを開いてみましょう。</p>
<img src="ch05/./image/apbs5.png" width="300px" title="APBS5">
<p>上の方の<code>levels</code>を選ぶと<code>Range</code>を変えることができそうです。このRangeは先述の負電荷・正電荷の色付けの表示領域を表しており、値が小さいほど、描画上で最大となる赤・青のしきい値が小さくなります。つまり、デフォルトの5.0から2.0にしてみると</p>
<img src="ch05/./image/apbs6.png" title="APBS6">
<p>こんな感じで赤と青の箇所が濃く表示されるようになります。</p>
<p>この表面電荷表示はSurface表示として扱われているので、<code>set transparency, 0.5</code>として透明度を変更してあげることができます(<code>0.5</code>は透明度)。</p>
<img src="ch05/./image/apbs7.png" title="APBS7">
<p>透明度を下げてCartoon表示とともに観察すれば、分子のどの部分構造の付近が負電荷、正電荷になっているかがわかりやすいと思います。</p>
<p>さて、ここで先程のAPBS Electrostaticsメニューのプラグイン画面に戻ってみましょう。そこのMainタブの下の方には<code>Other Visualizations</code>というOptionsボタンがあります。ここを開いてみると、「mapオブジェクトが計算されたあと、オブジェクトメニューパネルの&quot;Action&quot;アイテムを使うことで追加の描画を生成することができる」（日本語訳）と書かれてあります。</p>
<img src="ch05/./image/apbsmenu3.png" title="APBSmenu3">
<p>これに従って追加操作をしてみましょう（書きかけ）。</p>
<h3 id="advanced-configuration-1"><a class="header" href="#advanced-configuration-1">Advanced Configuration</a></h3>
<p>APBS Electrostaticsの計算のパラメータはデフォルトでも十分問題なく動作すると思いますが、上級者のために、パラメータを変更することもできるようになっています。[APBS Templrate]のタブを開くと、表面電荷を計算するための設定ファイルが表示されます。</p>
<p><img src="ch05/./image/apbsmenu4.png" title="APBSmenu4"><br></p>
<p>ここのBrowse...のところからは完成された設定ファイルを読み込ませることができます。公式ドキュメントは<a href="https://apbs-pdb2pqr.readthedocs.io/en/latest/apbs/input/">https://apbs-pdb2pqr.readthedocs.io/en/latest/apbs/input/</a> にあるので、そちらを参考にするのも良いでしょう。</p>
<p>最後の[Advanced Configuration]タブからは、APBSとPDB2PQRのプログラムのインストール場所を指定したり、コマンドオプションを追加して計算させることもできます。追加コマンドオプションの一覧は<a href="https://apbs-pdb2pqr.readthedocs.io/en/latest/pdb2pqr/invoking.html">https://apbs-pdb2pqr.readthedocs.io/en/latest/pdb2pqr/invoking.html</a>などが参考になります。</p>
<img src="ch05/./image/apbsmenu5.png" title="APBSmenu5">
<p>以下の項で説明するように、オープンソース版PyMOLではAPBS, PDB2PQRがプリインストールされていないため、自前で用意してからこのAdvanced Configurationで正しくプログラムの位置を指定してあげる必要があります。</p>
<h3 id="apbsのインストール-1"><a class="header" href="#apbsのインストール-1">APBSのインストール</a></h3>
<p>(2022年5月3日更新)</p>
<p>オープンソース版PyMOLを使っている人向けの説明です。やり方は3通りあって、Homebrewを使う方法と、バイナリインストールとソースコードからのインストールがあります。macOSの方やLinuxbrewが使える方はHomebrewの方法が簡単です。ソースコードからのインストールの方法は上級者向けです。</p>
<p>macOS（Linux OSの場合はLinuxbrewが必要）を使っている方は、私が作成したHomebrewのFormulaを使うことで簡単にインストールすることができます。執筆時点ではバージョン3.4.0です。</p>
<pre><code class="language-bash">brew install brewsci/bio/apbs
</code></pre>
<p>これにより、<code>apbs</code>コマンドが利用できるようになります。</p>
<pre><code class="language-bash">$ apbs --version

----------------------------------------------------------------------
    APBS -- Adaptive Poisson-Boltzmann Solver
    Version APBS 3.4.0
...
（以下省略）
</code></pre>
<p>インストール先は<code>which apbs</code>で調べることができます。</p>
<pre><code class="language-bash">$ which apbs
/opt/homebrew/bin/apbs # M1 Macの場合
/usr/local/bin/apbs    # Intel Macの場合
</code></pre>
<p>ここで表示されたインストール先のパス名をAdvanced ConfigurationのProgram Locationsのapbsの欄に入力すれば動作準備完了です。</p>
<img src="ch05/./image/apbs8.png" title="Homebrew APBS">
<h3 id="pdb2pqrのインストール-1"><a class="header" href="#pdb2pqrのインストール-1">PDB2PQRのインストール</a></h3>
<p>(2022年5月3日更新)</p>
<p>オープンソース版PyMOLを使っている人向けの説明です。pythonのpipを使ったインストールの方法が最も簡単でおすすめです。執筆時点ではバージョン3.5.2です。先に、</p>
<pre><code class="language-bash">$ python3 -m pip install pdb2pqr
...
(中略)
...
Successfully installed pdb2pqr-3.5.2
</code></pre>
<p>インストール先は<code>which pdb2pqr30</code>で調べることができます。バージョン3以前と異なり、バイナリ名が<code>pdb2pqr</code>から<code>pdb2pqr30</code>に変わっていることに気をつけてください。</p>
<pre><code class="language-bash">$ which pdb2pqr30
/opt/homebrew/bin/pdb2pqr30 # M1 Macの場合
/usr/local/bin/pdb2pqr30    # Intel Macの場合
</code></pre>
<p>ここで表示されたインストール先のパス名をAdvanced ConfigurationのProgram Locationsのpdb2pqrの欄に入力すれば動作準備完了です。</p>
<h3 id="apbs-guiプラグインのインストール-1"><a class="header" href="#apbs-guiプラグインのインストール-1">APBS GUIプラグインのインストール</a></h3>
<p>オープンソース版PyMOLはバイナリ版と違い、GUIプラグインがあらかじめインストールされていません。しかしバイナリ版のプラグインのディレクトリをそのままオープンソース版の方のディレクトリにコピーしてくれば使用することができます。</p>
<p>このGUIプラグイン部分は<a href="https://github.com/YoshitakaMo/pymolplugin">私のGithub</a>にコピーして置いてありますので、それをオープンソース版PyMOLのプラグインディレクトリに追加してやります。ターミナルを開いて</p>
<pre><code class="language-bash"># pymolpluginディレクトリをダウンロード
cd ~
git clone https://github.com/YoshitakaMo/pymolplugin.git
# ファイルをオープンソース版PyMOLのプラグインディレクトリに追加
cp -rp ~/pymolplugin/* ${HOMEBREW_PREFIX}/opt/pymol/libexec/lib/python3.10/site-packages/pmg_tk/startup
# ここでPyMOLを立ち上げてみて、プラグインがインストールされていればOK
# インストールできたら~/pymolpluginディレクトリは削除してOK
rm -rf ~/pymolplugin
</code></pre>
<p>と入力します。このコピーを行った後にopen-source版PyMOLを立ち上げると、上部メニューのPluginのところにAPBS Electrostaticsの文字が現れているはずです。</p>
<img src="ch05/./image/apbsmenu1.png" title="APBSmenu1">
<p>この文字をクリックし、Advanced Configurationのタブをクリックします。このProgram Locationsを自身の環境にあわせて設定する必要があります。</p>
<img src="ch05/./image/apbs3.png" title="APBSの表示例">
<p>HomebrewでAPBSとPDB2PQRをインストールした場合は、上図のようにapbsの欄を<code>/usr/local/bin/apbs</code>にし、pdb2pqrの欄を<code>/usr/local/bin/pdb2pqr30</code>に設定します（※M1以降のMacの方はそれぞれ<code>/opt/homebrew/bin/apbs</code>と<code>/opt/homebrew/bin/pdb2pqr30</code>）。もしソースコードからインストールした場合にはこの限りではありませんので、適切なapbs, pdb2pqrバイナリ本体へのpathを指定しましょう。</p>
<p>他の部分は特に変更する必要はありません。これで右下のrunを押せばめでたくAPBSが動くはずです。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="動画の作成方法-1"><a class="header" href="#動画の作成方法-1">動画の作成方法</a></h2>
<p>自身の研究しているタンパク質の構造を他の人にもしっかりと見てもらうための方法は、1つにはPyMOLセッションファイルに保存して、それをPyMOLで開いてもらうということが考えられます。しかし、PyMOLセッションファイルは相手のパソコンやmacにPyMOLがインストールされてなければ閲覧することはできません。そこで、より広い範囲で色んな人に見てもらうための方法として、<strong>分子が動いている様子を一般的な動画形式に変換する</strong>という方法があります。これならPowerpointなどのスライドに埋め込むこともできますし、ウェブ上でも公開できます。</p>
<p>ここではその方法をいくつか紹介します。</p>
<h3 id="目指す動画の例-1"><a class="header" href="#目指す動画の例-1">目指す動画の例</a></h3>
<p>先に完成例としての動画を表示します。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/alpmovie.mp4" type="video/mp4">
</video>
<p>ポイントは</p>
<ul>
<li>全体像を見せつつ、基質結合部位を見せる</li>
<li>背景画像を使う</li>
<li>無料のコマンドラインツールのみを使用し、有料アプリを使わない</li>
</ul>
<p>です。</p>
<p>背景画像を使っているのは、使用しないと黒背景になることが多くなってしまうためです。</p>
<h3 id="使うツール-1"><a class="header" href="#使うツール-1">使うツール</a></h3>
<p>動画への出力は<strong>ffmpeg</strong>を使います。macOSならば</p>
<pre><code class="language-bash">$ brew install ffmpeg
</code></pre>
<p>でインストールできますので、これをインストールしておきます。もしOpen-source版のPyMOLを<code>brew install pymol</code>でインストールしていた場合はffmpegも自動的にインストールされているはずです。</p>
<h3 id="手順1画面サイズを決める-1"><a class="header" href="#手順1画面サイズを決める-1">手順1：画面サイズを決める</a></h3>
<p>動画として出力する予定の画面サイズを先に決めておくと後が楽です。ここでは横1280ピクセル縦720ピクセルの動画を出力することにします。これはコマンドでかんたんに設定することができます。コマンド入力欄に</p>
<pre><code>viewport 1280, 720
</code></pre>
<p>と入力すると、画面が指定したサイズに変化します。</p>
<img src="ch05/./image/movie/viewport.png" width="100%" title="">
<h3 id="手順2sceneを保存する-1"><a class="header" href="#手順2sceneを保存する-1">手順2：Sceneを保存する</a></h3>
<p><a href="ch05/../ch03/scene.html">3.7 Scene</a>で述べているように、<strong>Scene機能</strong>を使うとPyMOLでのカメラアングルと表示状態を保存することができ、左下に現れたメニューからいつでもその状態を呼び出すことができます。動画を作成する上でもこの<strong>Scene機能</strong>を活用することが可能です。</p>
<p>例としてまずアルカリホスファターゼの二量体構造全体が見える位置でSceneを1つ保存しておきます。いい感じの表示設定とカメラアングルが得られたら、上部メニューの<strong>Scene</strong>から<strong>Store</strong>を選びF1〜F12のいずれかに保存します（ここでは<strong>F1</strong>にしておきます）。</p>
<img src="ch05/./image/movie/movie1.png" width="100%" title="">
<p>左下に<strong>F1ボタン</strong>が現れました。以降はこのボタンを押すと表示設定とカメラアングルが呼び出されます。</p>
<img src="ch05/./image/movie/movie2.png" width="100%" title="">
<p>続いて基質結合部位に注目したカメラアングルをSceneの<strong>F2</strong>として保存しておきます。同様の操作でこんな感じで保存しておきます。</p>
<img src="ch05/./image/movie/movie3.png" width="100%" title="">
<img src="ch05/./image/movie/movie4.png" width="100%" title="">
<p>Sceneをすべて設定し終えたら、上部<strong>Movie</strong>メニューから<strong>Program</strong>, <strong>Scene Loop</strong>, <strong>Nutate, 30 de. over 2sec.</strong> を選びます。これはSceneを順番に表示しつつ、各Sceneで2秒間30°ずつ揺らしながら次の状態に移行する設定です。設定には色々あるので、<a href="ch05/../ch03/movie.html">3.4 Movie</a>から好きなものを選んでください。</p>
<p>右下のスタートボタンを押すとこんな感じで再生されます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/movie_1.mp4" type="video/mp4">
</video>
<p>ここに表示されている画面が動画として出力されるので、よくチェックしておきます。</p>
<p>もし手順1を飛ばしていた場合はここで<code>viewport</code>コマンドを入れて画像サイズを調節し、再度手順2のScene保存をやり直します。</p>
<p>よければセッションファイル（pseファイル）として保存しておきます。</p>
<h3 id="手順3png形式で各フレームを保存する-1"><a class="header" href="#手順3png形式で各フレームを保存する-1">手順3：PNG形式で各フレームを保存する</a></h3>
<p>動画に表示されている動きの全フレームをPNG画像形式で出力させます。これは<strong>File</strong>, <strong>Export Movie As</strong>, <strong>PNG Images</strong>から選択することができます。</p>
<img src="ch05/./image/movie/movie5.png" width="100%" title="">
<p>Moview Exportのダイアログボックスでは出力画像サイズを設定することができます。もしここで当初予定していた画像サイズから変わっていれば（少し変わっていることがよくあります）、その数字を修正しておきます。また、RenderingオプションはRay(Slow)の方がきれいに出力されますが、その分時間がかかります。今回はRayでやります。</p>
<p>最後に一番下のSave Movie as...から出力先のディレクトリを選択します。このとき、出力先ディレクトリは新規ディレクトリを作成してからその中に保存することを強く勧めます。こうしないと画像が散らばって面倒です。</p>
<p>今回の例では保存先をmovietestというディレクトリ上に保存することにします。そしてSave Asの名前欄に<code>ALP</code>と入力します（この文字は画像のprefixなので任意の文字列でOKです）。</p>
<img src="ch05/./image/movie/movie6.png" width="100%" title="">
<p>すると、出力先のmovietestディレクトリにALP0001.png, ALP0002.png, ... といった具合にすべてのフレームの画像が出力されます。しばらくかかるのでこのまますべて終わるまでじっくり待ちます。</p>
<h3 id="手順4背景画像を使ってffmpegで動画を生成する-1"><a class="header" href="#手順4背景画像を使ってffmpegで動画を生成する-1">手順4：背景画像を使ってffmpegで動画を生成する</a></h3>
<p>好きな背景画像を適当に用意します。今回は以下のものを使いました。</p>
<img src="ch05/./image/movie/bg.jpg" width="100%" title="">
<p>画像サイズはあらかじめ出力したタンパク質の画像サイズ（1280 x 720）と合わせておくと良いでしょう。画像の切り抜きにはコマンドラインツールのImagemagickを使うこともできます。詳しくは<a href="https://qiita.com/yoya/items/62879e6e03d5a70eed09">ImageMagick の画像 Crop</a>の記事などを参考にしてください。</p>
<p>この背景画像を<code>bg.jpg</code>として、先程のmovietestディレクトリに置きます。その後、以下のコマンドでffmpegを実行するだけで、動画ファイル<code>out.mp4</code>が生成されます。</p>
<pre><code class="language-bash">$ ffmpeg -r 30 -i bg.jpg -vf 'movie=ALP%4d.png [over], [in][over] overlay' -vcodec libx264 -pix_fmt yuv420p out.mp4
</code></pre>
<ul>
<li><code>-r</code>：フレームレート</li>
<li><code>-i</code>：インプット画像</li>
<li><code>-vcodec libx264</code>：スマートフォン向けの動画(H.264+aac)に変換</li>
<li><code>-pix_fmt yuv420p</code>：エンコーダに渡すピクセルフォーマットを指定。yuv420pはH.264動画変換のときのデフォルトらしい</li>
<li><code>-vf 'movie=ALP%4d.png [over], [in][over] overlay'</code>：ALPではじまる連番画像をインプット画像の上に重ねる</li>
</ul>
<p>これで動画が出力されました。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/movie/alpmovie.mp4" type="video/mp4">
</video>
<h3 id="その他-1"><a class="header" href="#その他-1">その他</a></h3>
<p>MDシミュレーションでトラジェクトリを表示させたときのタンパク質が動いている様子もこれと同様の手順で出力することができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="表示形式のプリセット-1"><a class="header" href="#表示形式のプリセット-1">表示形式のプリセット</a></h2>
<p>PyMOLのオブジェクトパネルのAボタンの中には<code>preset</code>と言うメニューがあります。これを使うと、様々な表示形式に一発で変換できます。</p>
<img src="ch05/./image/preset/menu.png" width="60%" title="">
<ul>
<li>classified</li>
<li>simple</li>
<li>simple (no solvent)</li>
<li>ball and stick</li>
<li>b factor putty</li>
<li>technical</li>
<li>ligands</li>
<li>ligand sites
<ul>
<li>cartoon</li>
<li>solid surface</li>
<li>solid (better)</li>
<li>transparent surface</li>
<li>transparent (better)</li>
<li>dot surface</li>
<li>mesh surface</li>
</ul>
</li>
<li>pretty</li>
<li>pretty (with solvent)</li>
<li>publication</li>
<li>publication (with solvent)</li>
<li>protein interface</li>
<li>default</li>
<li>hydropathy</li>
</ul>
<p>以上のプリセットが用意されています（ver. 2.5.0 時点）。</p>
<p>このプリセットが選択された時、内部処理的には一度デフォルト形式である<code>classified</code>を設定してから選択されたプリセットの描画設定を上書きしていく形で適用しています。ただし<code>pymolrc</code>に書かれたいくつかの設定値（<code>transparency</code>, <code>surface_quality</code>, <code>surface_type</code>, <code>sphere_scale</code>, <code>stick_radius</code>, <code>stick_color</code>, <code>cartoon_highlight_color</code>, <code>cartoon_fancy_helices</code>, <code>cartoon_smooth_loops</code>, <code>cartoon_flat_sheets</code>, <code>cartoon_side_chain_helper</code>など）は<code>auto_show_classified</code>としてPyMOL起動時に記憶され、<code>classified</code>は描画形式以外この値を利用します。</p>
<p>プリセットの定義は、<code>modules/pymol/preset.py</code> の中に書かれてあります。 https://github.com/schrodinger/pymol-open-source/blob/master/modules/pymol/preset.py も参考にすると良いでしょう。</p>
<p>ここではギャラリー風に紹介していきます。</p>
<h3 id="classified-1"><a class="header" href="#classified-1">classified</a></h3>
<p>現在PyMOLのデフォルト設定に最も近い描画形式です。タンパク質構造はCartoon表示、リガンドはSphere表示です。デフォルト設定との細かな違いとして、水分子がwire-nonbonded表示されないなどが挙げられますが、<strong>デフォルトの描画設定に戻したいときはこの設定を呼び出すと良いでしょう</strong>。</p>
<p>ただし、色設定は変化しないため、手動で戻す必要があります。</p>
<p><img src="ch05/./image/preset/classified.png" width="50%" alt="classified" title="classified"><img src="ch05/./image/preset/classified2.png" width="50%" alt="classified" title="classified"></p>
<p>コマンドで行いたい場合は、以下の<code>objectname</code>部分をオブジェクト名に変えて実行します（例: 1ALK）。以下同様。</p>
<blockquote>
<p>preset.classified(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="simple-1"><a class="header" href="#simple-1">simple</a></h3>
<p>タンパク質構造は主鎖だけをシンプルに表示するribbon表示、リガンドはStick表示になります。また、チェインごとに自動で色分けがなされます。</p>
<p><img src="ch05/./image/preset/simple.png" width="50%" alt="simple" title="simple"><img src="ch05/./image/preset/simple2.png" width="50%" alt="simple" title="simple"></p>
<blockquote>
<p>preset.simple(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="simple-no-solvent-1"><a class="header" href="#simple-no-solvent-1">simple (no solvent)</a></h3>
<p>上記simple表示について、溶媒の表示がなくなったものです。</p>
<p><img src="ch05/./image/preset/simplenos.png" width="50%" alt="simple" title="simple"><img src="ch05/./image/preset/simplenos2.png" width="50%" alt="simple" title="simple"></p>
<blockquote>
<p>preset.simple_no_solv(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="ball-and-stick-1"><a class="header" href="#ball-and-stick-1">ball and stick</a></h3>
<p>各原子を小さめのボールで表し、結合を白色のスティックで表示します。色分けは変化しません。</p>
<p><img src="ch05/./image/preset/bs.png" width="50%" alt="ball and stick" title="ball and stick"><img src="ch05/./image/preset/bs2.png" width="50%" alt="ball and stick" title="ball and stick"></p>
<blockquote>
<p>preset.ball_and_stick(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="b-factor-putty-1"><a class="header" href="#b-factor-putty-1">b factor putty</a></h3>
<p>温度因子であるB factorをもとに色付けし、さらに温度因子が大きいほど太くチューブ状に表示します。温度因子は青色ほど低く、赤色ほど高くなっています。この表示では主鎖構造のみが表示されます。</p>
<p><img src="ch05/./image/preset/bfactor.png" width="50%" alt="B factor putty" title="B factor putty"><img src="ch05/./image/preset/bfactor2.png" width="50%" alt="B factor putty" title="B factor putty"></p>
<blockquote>
<p>preset.b_factor_putty(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="technical-1"><a class="header" href="#technical-1">technical</a></h3>
<p>各チェインのN末端からC末端にかけて青色→赤色となるようなRainbowカラーリングが適用されます。また、水素結合が自動的に検出され、<code>&lt;objectname&gt;_pol_conts</code>というオブジェクトが生成されます。水素結合を表示させたくない場合はオブジェクトパネル上でこの<code>&lt;objectname&gt;_pol_conts</code>の表示をOFFにすればOKです。</p>
<p><img src="ch05/./image/preset/technical.png" width="50%" alt="technical" title="technical"><img src="ch05/./image/preset/technical2.png" width="50%" alt="technical" title="technical"></p>
<blockquote>
<p>preset.technical(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="ligands-1"><a class="header" href="#ligands-1">ligands</a></h3>
<p>上述のRainbowカラーリングが施され、基本的には主鎖構造のみのribbon表示になりますが、リガンドから一定範囲のみ側鎖を含んだline表示が行われ、リガンドへの水素結合自動検出処理が行われます。</p>
<p>カメラもそのリガンド周辺にズームしてくれますが、リガンドが複数ある場合はそれらの中間にカメラを合わせてしまうようです。</p>
<p><img src="ch05/./image/preset/ligands.png" width="50%" alt="ligands" title="ligands"><img src="ch05/./image/preset/ligands2.png" width="50%" alt="ligands" title="ligands"></p>
<blockquote>
<p>preset.ligands(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="ligand-sites-1"><a class="header" href="#ligand-sites-1">ligand sites</a></h3>
<p>上記ligands設定の拡張版と言えます。様々な表示形式が用意されています。いずれのプリセットでも水素結合を検出し、<code>&lt;objectname&gt;_pol_conts</code>というオブジェクトを生成します。</p>
<h4 id="cartoon-1"><a class="header" href="#cartoon-1">Cartoon</a></h4>
<p>タンパク質をCartoon表示のままRainbowカラーリング、リガンドをStick表示で、周辺の一定範囲のみline表示にします。</p>
<p><img src="ch05/./image/preset/ligcartoon.png" width="50%" alt="ligcartoon" title="ligcartoon"><img src="ch05/./image/preset/ligcartoon2.png" width="50%" alt="ligcartoon" title="ligcartoon"></p>
<blockquote>
<p>preset.ligand_cartoon(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="solid-surface-1"><a class="header" href="#solid-surface-1">solid surface</a></h4>
<p>タンパク質をribbon表示, Rainbowカラーリング, リガンドをStick表示, 周辺の一定範囲のみsurface表示にします。</p>
<p><img src="ch05/./image/preset/solsurf.png" width="50%" alt="solid surface" title="solid surface"><img src="ch05/./image/preset/solsurf2.png" width="50%" alt="solid surface2" title="solid surface2"></p>
<blockquote>
<p>preset.ligand_sites(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="solid-better-1"><a class="header" href="#solid-better-1">solid (better)</a></h4>
<p>上記solid surfaceプリセット表示のsurfaceクオリティが上がったものです。設定としては<code>set surface_quality, 1</code>を追加しています。</p>
<p><img src="ch05/./image/preset/solbetter.png" width="50%" alt="solid (better)" title="solid (better)"><img src="ch05/./image/preset/solbetter2.png" width="50%" alt="solid (better)" title="solid (better)"></p>
<blockquote>
<p>preset.ligand_sites_hq(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="transparent-surface-1"><a class="header" href="#transparent-surface-1">transparent surface</a></h4>
<p>上記solid surfaceの透明度を上げ(<code>set transparency, 0.33</code>)、周辺の残基をstick表示にしたものです。</p>
<p><img src="ch05/./image/preset/transsurf.png" width="50%" alt="transparent surface" title="transparent surface"><img src="ch05/./image/preset/transsurf2.png" width="50%" alt="transparent surface" title="transparent surface"></p>
<blockquote>
<p>preset.ligand_sites_trans(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="transparent-better-1"><a class="header" href="#transparent-better-1">transparent (better)</a></h4>
<p>上記transparent surfaceプリセット表示のsurfaceクオリティが上がったものです。設定としては<code>set surface_quality, 1</code>を追加しています。</p>
<p><img src="ch05/./image/preset/transbetter.png" width="50%" alt="transparent (better)" title="transparent (better)"><img src="ch05/./image/preset/transbetter2.png" width="50%" alt="transparent (better)" title="transparent (better)"></p>
<blockquote>
<p>preset.ligand_sites_trans_hq(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="dot-surface-1"><a class="header" href="#dot-surface-1">dot surface</a></h4>
<p>上記solid surfaceの表面表示をdotにしたものです。</p>
<p><img src="ch05/./image/preset/dotsurface.png" width="50%" alt="dot surface" title="dot surface"><img src="ch05/./image/preset/dotsurface2.png" width="50%" alt="dot surface" title="dot surface"></p>
<blockquote>
<p>preset.ligand_sites_dots(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h4 id="mesh-surface-1"><a class="header" href="#mesh-surface-1">mesh surface</a></h4>
<p>上記solid surfaceの表面表示をdotにしたものです。</p>
<p><img src="ch05/./image/preset/meshsurface.png" width="50%" alt="mesh surface" title="mesh surface"><img src="ch05/./image/preset/meshsurface2.png" width="50%" alt="mesh surface" title="mesh surface"></p>
<blockquote>
<p>preset.ligand_sites_mesh(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="pretty-1"><a class="header" href="#pretty-1">pretty</a></h3>
<p>生体分子のレインボー表示、リガンドをstick形式で表示します。</p>
<p><img src="ch05/./image/preset/pretty.png" width="50%" alt="pretty" title="pretty"><img src="ch05/./image/preset/pretty2.png" width="50%" alt="pretty" title="pretty"></p>
<blockquote>
<p>preset.pretty(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="pretty-with-solvent-1"><a class="header" href="#pretty-with-solvent-1">pretty (with solvent)</a></h3>
<p>上記prettyに加えて溶媒やリガンドをnb_spheres表示にします。</p>
<p><img src="ch05/./image/preset/prettywiths.png" width="50%" alt="pretty (with solvent)" title="pretty (with solvent)"><img src="ch05/./image/preset/prettywiths2.png" width="50%" alt="pretty (with solvent)" title="pretty (with solvent)"></p>
<blockquote>
<p>preset.pretty_solv(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="publication-1"><a class="header" href="#publication-1">publication</a></h3>
<p>cartoon表示において、</p>
<ul>
<li>ループ構造のスムージング<code>set cartoon_smooth_loops, 1</code></li>
<li>ヘリックスやシートの内部を灰色に設定<code>set cartoon_highlight_color, grey50</code></li>
<li>ヘリックスのファンシー化<code>set cartoon_fancy_helices, 1</code></li>
<li>シート構造の平坦化（初期設定でON）<code>set cartoon_flat_sheets, 1</code></li>
<li>側鎖構造のみの表示（初期設定でON）<code>set cartoon_side_chain_helper, 0</code></li>
</ul>
<p>を行います。</p>
<p><img src="ch05/./image/preset/pub.png" width="50%" alt="publication" title="publication"><img src="ch05/./image/preset/pub2.png" width="50%" alt="publication" title="publication"></p>
<blockquote>
<p>preset.publication(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="publication-with-solvent-1"><a class="header" href="#publication-with-solvent-1">publication (with solvent)</a></h3>
<p>上記の溶媒表示版です。</p>
<p><img src="ch05/./image/preset/pubwiths.png" width="50%" alt="publication (with solvent)" title="publication (with solvent)"><img src="ch05/./image/preset/pubwiths2.png" width="50%" alt="publication (with solvent)" title="publication (with solvent)"></p>
<blockquote>
<p>preset.pub_solv(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="protein-interface-1"><a class="header" href="#protein-interface-1">protein interface</a></h3>
<p>異なるチェインの境目から4.5 Å以内に一部でも含まれる残基をStick表示にします。</p>
<p><img src="ch05/./image/preset/proint.png" width="50%" alt="protein interface" title="protein interface"><img src="ch05/./image/preset/proint2.png" width="50%" alt="protein interface" title="protein interface"></p>
<blockquote>
<p>preset.interface(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<h3 id="default-1"><a class="header" href="#default-1">default</a></h3>
<p>PyMOL 1時代はこのシンプルなライン表示だけの形式がデフォルト表示でした。Defaultとついていますが、現在はデフォルト設定ではなくなり、classified presetに取って替わられています。</p>
<p><img src="ch05/./image/preset/default.png" width="50%" alt="default" title="default"><img src="ch05/./image/preset/default2.png" width="50%" alt="default" title="default"></p>
<blockquote>
<p>preset.default(&quot;objectname&quot;,_self=cmd)</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="gaussian-16のcubeファイルを開いて分子軌道を表示する-1"><a class="header" href="#gaussian-16のcubeファイルを開いて分子軌道を表示する-1">Gaussian 16のcubeファイルを開いて分子軌道を表示する</a></h2>
<img src="ch05/./image/gaus1.png" width="700" title="Gaussian 16での分子軌道の表示例">
<p>PyMOLは、<a href="https://www.ks.uiuc.edu/Research/vmd/">VMD</a>とまでは行きませんが、様々なファイルの可視化にも対応しています。今回紹介するのは、Gaussian 16などで計算された分子の分子軌道（molecular orbital）をPyMOL上で表示させるテクニックです。</p>
<p>GaussView 6やVMD 1.9.4などの他のソフトを用いて可視化してもよいのですが、タンパク質の構造生物学をやっている人ならだいたい使ったことがあり、扱いに慣れているPyMOLで見られれば、共同研究のときとかに喜ばれると考えられます。</p>
<p>ここでは、簡単な計算の例を示しながら、それをGaussViewまたはPyMOLで分子軌道を表示する時の方法を紹介します。</p>
<h3 id="分子軌道を表示するのに必要な環境-1"><a class="header" href="#分子軌道を表示するのに必要な環境-1">分子軌道を表示するのに必要な環境</a></h3>
<ul>
<li>GaussView 6, VMD, PyMOL 2.3.0以降のうち、いずれか1つをインストールしてあるパソコン</li>
</ul>
<p>この記事ではGaussView 6またはPyMOL 2.3.0での方法を示します</p>
<h3 id="example-1-1-シクロペンタジエンの場合-1"><a class="header" href="#example-1-1-シクロペンタジエンの場合-1">Example 1-1. シクロペンタジエンの場合</a></h3>
<p>例として、シクロペンタジエン分子の構造をGaussian 16（<code>g16</code>）で構造最適化させ、分子軌道を計算させてみます。インプットファイル<code>cyclopenta.gjf</code> を以下のように書いて<code>g16</code>で計算させます。</p>
<pre><code>%chk=cyclopenta.chk
%mem=20GB
%nprocshared=12
#p opt b3lyp/6-311g(d,p) pop=full

Title

0 1
 C                 -1.78668958   -0.09572728    0.64728372
 C                 -1.36269158    1.27506872    0.64728372
 H                 -1.14231658   -0.96843328    0.64730872
 H                 -0.33812858    1.63156072    0.64725872
 C                 -3.62816658    1.22478072    0.64727472
 H                 -4.64865477    1.54029066    0.71018208
 C                 -3.18843958   -0.09572728    0.64728372
 H                 -3.80595672   -0.96740593    0.58605536
 C                 -2.51974858    2.06652172    0.64717972
 H                 -2.52502738    2.68450968    1.52065726
 H                 -2.55124904    2.68351582   -0.22644835

</code></pre>
<p><code>%mem=20GB</code>部分は計算にメモリを20GB使用するということ、<code>%nprocshared=12</code>は計算で使うCPU数を指定します。この値は各計算環境に応じて適宜変更する必要があります。ここで、重要なのは計算条件を指定する<code>#p opt pop=full</code>の部分です。<code>opt pop=full</code>で構造最適化計算と、電子密度解析計算を行うよう指示します。計算レベルや基底関数については<code>b3lyp/6-311g(d,p)</code>でなくても好みのものを使ってください。
（ちなみにGaussian 16だと<code>%nprocshared</code>の指定は非推奨になっています。最近実装された、環境変数での指定方法のほうが使い勝手が良いと思います。さらに、GPUを使った計算をしたい場合にはもっと別の指定方法になります。 参考： http://www.hpc.co.jp/gaussian_Link-0-Equivs.html ）</p>
<p>実行コマンド例は</p>
<pre><code class="language-bash">#!/bin/bash
job=&quot;cyclopenta&quot;
export GAUSS_CDEF=&quot;0-11&quot; # cyclopenta.gjfファイルの%nprocshared=12に対応

g16 &lt; ${job}.gjf &gt; ${job}.log
</code></pre>
<p>計算が終わりますと、計算結果の<code>cyclopenta.log</code>ファイルだけでなく、.chk（チェックポイント）ファイル<code>cyclopenta.chk</code>も生成されているはずです。分子軌道の可視化や以降の処理にはこのファイルを用います。</p>
<h3 id="example-1-2-chkファイルの処理-1"><a class="header" href="#example-1-2-chkファイルの処理-1">Example 1-2. chkファイルの処理</a></h3>
<p>このchkファイルを用いて、まずターミナル上での以下のコマンドで、formatted checkpoint file形式に変換します。</p>
<pre><code>formchk cyclopenta.chk cyclopenta.fchk
</code></pre>
<p>として、formatted checkpoint fileに変換します。この<code>formchk</code>コマンドはGaussian 16と同時にインストールされているはずのコマンドです。Gaussian 16がインストールされてあるマシンやスパコンでは、Gaussian 16の本体である<code>g16</code>コマンドが使えるならば、ほぼ間違いなく使えるはずです。
（ちなみにGaussian 16で計算したchkファイルをGaussian 09時代の<code>formchk</code>コマンドで変換することはできない……かもしれません）</p>
<p>続いて、上のコマンドで作成された<code>cyclopenta.fchk</code>ファイルから、必要な分子軌道のデータを<code>.cube</code>形式のファイルに抽出します。</p>
<pre><code>cubegen 0 MO=homo cyclopenta.fchk cyclopenta_homo.cube
</code></pre>
<p>この<code>cubegen</code>についての操作方法はGaussian公式の<a href="http://gaussian.com/cubegen/">cubegenの解説ページ</a>のページを参照してください。MO=のあとにhomoやlumo、または数字を指定すると、それに対応した分子軌道が出力されます。
今回はシクロペンタジエンのHOMO（最高被占軌道）のデータを取り出したいので、MO=homoとし、.fchkファイルと出力ファイル名<code>cyclopenta_homo.cube</code>を指定します。</p>
<h3 id="example-1-3-cubeファイルの表示-1"><a class="header" href="#example-1-3-cubeファイルの表示-1">Example 1-3. cubeファイルの表示</a></h3>
<h4 id="case-1-gaussview-6で表示する-1"><a class="header" href="#case-1-gaussview-6で表示する-1">Case 1. GaussView 6で表示する</a></h4>
<p>GaussView 6で表示する時、必要になるファイルは<code>cyclopenta.log</code>と<code>cyclopenta_homo.cube</code>です。まずはふつうに<code>cyclopenta.log</code>を開きます。</p>
<img src="ch05/./image/gaus2.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>続いて、Results &gt; Surfaces/Contoursを選択し、Cube ActionsからLoad Cubeを選び、<code>cyclopenta_homo.cube</code>を選択します。</p>
<img src="ch05/./image/gaus3.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>続いて、Surface Actions &gt; New Surfaceをクリックすると、分子軌道の図が表示されるようになります。</p>
<img src="ch05/./image/gaus4.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>このSurfaceの描画モードを変えたい場合は、この紫の画面内で右クリックし、View -&gt; Display Formatを選択します（macOSはCommand+DでもOK）。</p>
<img src="ch05/./image/gaus5.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>このDisplay Formatウィンドウの中で、右端のSurfaceタブを選び、Format: transparentとすれば、半透明な表面を描画することができます。透明度はそこのスライダで調節できます。またmesh表示も可能です。</p>
<img src="ch05/./image/gaus6.png" width="500" title="Gaussian 16での分子軌道の表示例">
<p>以下では、この部分をPyMOLでやってみる方法を紹介します。</p>
<h4 id="case-2-pymol-230で表示する-1"><a class="header" href="#case-2-pymol-230で表示する-1">Case 2. PyMOL 2.3.0で表示する</a></h4>
<p>PyMOLで開く場合には、</p>
<ol>
<li><code>cyclopenta.log</code>の最終構造に対応する構造ファイルをPDB形式などで用意し、PyMOLに表示させる</li>
<li>この上に<code>cyclopenta_homo.cube</code>をロードし、適切な処理を施す。</li>
</ol>
<p>という流れになります。このうち、1.で述べた構造ファイルを用意する部分はやや面倒かもしれません。お使いのマシンに<a href="https://qiita.com/Ag_smith/items/d2e86dda17f190a3dd0f">AmberTools 18がインストールされている</a>状態であれば、</p>
<pre><code>antechamber -i cyclopenta.log -fi gout -o cyclopenta.pdb -fo pdb
</code></pre>
<p>とすることで最終構造のPDBファイルを一発変換できます。AmberToolsがない場合は、オープンソースのファイルコンバータである<a href="https://future-chem.com/open-babel-usage/">Open Babelを使った変換法</a>で代用できます。Homebrewのインストール方法は適当にググってください。</p>
<pre><code># Open BabelをHomebrewでインストール
brew install open-babel
# Usage:
# obabel [-i&lt;input-type&gt;] &lt;infilename&gt; [-o&lt;output-type&gt;] -O&lt;outfilename&gt; [Options]
# input-typeにはまだg16フォーマットがサポートされていないのですが、g09で代用可能だと思います。
# see also 'http://openbabel.org/docs/current/FileFormats/Overview.html#file-formats'
obabel -i g09 cyclopenta.log -o pdb -O cyclopenta.pdb
</code></pre>
<p>こうしてファイル形式を変換して作成した<code>cyclopenta.pdb</code>をPyMOLで開いてみます。</p>
<img src="ch05/./image/gaus7.png" width="600" title="Gaussian 16での分子軌道の表示例">
<p>んー、本来は二重結合になっている炭素の結合情報が、全部同じような線で繋がれてしまっていますね。これが嫌だな〜って方は、以下のようにして二重結合っぽい表示に変えてみます。</p>
<p>二重結合にしたい原子の上でそれぞれ右のダブルクリック（マウスにホイールがある場合はホイールクリックでも可能）をすると、Pk1, Pk2という選択印が付きます。この状態で、PyMOLのコマンド <code>unbond ; bond order=2</code> を実行します（コマンド入力できるフォームは2箇所ありますが、どちらに入れても同じです）。この<code>order=2</code>で結合次数を指定しています。</p>
<img src="ch05/./image/gaus8.png" width="600" title="Gaussian 16での分子軌道の表示例">
<p>これで二重結合っぽい表示に変わりました。ついでに、好みで以下の設定を入れてGaussViewっぽい描画設定にしてみます。</p>
<pre><code>show sticks
show spheres
set stick_radius, 0.1
set sphere_scale, .22
set sphere_scale, .18, elem H
</code></pre>
<img src="ch05/./image/gaus9.png" width="600" title="Gaussian 16での分子軌道の表示例">
<p>では、PyMOLに<code>cyclopenta_homo.cube</code>ファイルをロードします。コマンドは以下の通り</p>
<pre><code>load /path/to/cyclopenta_homo.cube
isosurface Asurf1, cyclopenta_homo, 0.02
isosurface Bsurf1, cyclopenta_homo, -0.02
color red, Asurf1
color blue, Bsurf1
set transparency, 0.5
</code></pre>
<p><code>load</code>部分は、<code>cyclopenta_homo.cube</code>のファイルのあるファイルパスを指定します。デスクトップ上に置いてあるならば<code>load ~/Desktop/cyclopenta_homo.cube</code>みたいに。以下の<code>isosurface</code>コマンドで分子軌道をしきい値0.02, -0.02で作成します。正と負の波動関数に対応する各電子雲をAsurf1, Bsurf1というオブジェクト名で作成し、色付けを red, blueにしています。</p>
<img src="ch05/./image/gaus10.png" width="600" title="Gaussian 16での分子軌道の表示例">
<p>Asurf1, Bsurf1の色変更は、PyMOLのオブジェクト色変更と同じ感覚でマウスを使って簡単に変更できます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="pymol上でのpythonスクリプトの実行基本編-1"><a class="header" href="#pymol上でのpythonスクリプトの実行基本編-1">PyMOL上でのpythonスクリプトの実行：基本編</a></h2>
<p>PyMOLの大きな強みの1つとして、PyMOLのコマンドラインからpythonスクリプトを実行させることができることが挙げられます。ここではいくつかの例を挙げながら、PyMOL上でのpythonスクリプト実行機能を紹介してみます。ただし、python3についての基本的な知識があることを前提とします。</p>
<h3 id="pythonの設定を確認する-1"><a class="header" href="#pythonの設定を確認する-1">Pythonの設定を確認する</a></h3>
<p>まずは現在PyMOLが動作しているPython環境を確認するために、バージョン情報とPATHをPyMOLのコマンド入力欄から確認してみましょう。コマンドは通常のpythonと同じように</p>
<pre><code class="language-python"># pythonのバージョンを表示
import sys
print(sys.version)
# pythonのモジュール検索PATHを確認
print(sys.path)
</code></pre>
<p>となります。返り値は、私の環境（macOSのHomebrewでインストールした場合）では</p>
<pre><code class="language-shell"># PyMOL&gt;print(sys.version)
3.10.8 (main, Oct 13 2022, 09:48:40) [Clang 14.0.0 (clang-1400.0.29.102)]
# PyMOL&gt;print(sys.path)
['', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python310.zip', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload', '/Users/YoshitakaM/Library/Python/3.10/lib/python/site-packages', '/usr/local/lib/python3.10/site-packages', '/usr/local/lib/python3.10/site-packages/coot', '/usr/local/lib/python3.10/site-packages/coot/rcrane', '/usr/local/Cellar/pybind11/2.10.0/libexec/lib/python3.10/site-packages', '/usr/local/Cellar/pymol/2.5.0/libexec/lib/python3.10/site-packages', '/usr/local/Cellar/sip/6.6.2_1/libexec/lib/python3.10/site-packages', '/usr/local/Cellar/modeller/10.3_1/modlib', '/usr/local/opt/python-tk@3.10/libexec', '/Users/YoshitakaM/apps/pymol-psico']
</code></pre>
<p>のようになりました。<code>print(sys.path)</code>で表示されたPATHからはモジュールをimportすることができます。</p>
<h3 id="pythonスクリプトをpymol上で実行する-1"><a class="header" href="#pythonスクリプトをpymol上で実行する-1">PythonスクリプトをPyMOL上で実行する</a></h3>
<p>PyMOLコマンドラインからは<code>python</code>と<code>python end</code>という入力の間に任意のpythonスクリプトを挟むことで、PyMOL上で擬似インタラクティブにコマンドを実行することができます。ただし、一度<code>python</code>を入力した後は<code>python end</code>を入力するまではフィードバックが得られないことに注意しましょう。</p>
<p>例えば、以下のように変数<code>x</code>に<code>10</code>という値を入れてそれをprintさせるだけの簡単なスクリプトをコマンドラインに入力してみます。</p>
<pre><code class="language-python">python
x = 10
print(x)
python end
</code></pre>
<p>PyMOLのアウトプットとしては</p>
<pre><code class="language-shell">PyMOL&gt;python
PyMOL&gt;x = 10
    1:x = 10
PyMOL&gt;print(x)
    2:print(x)
PyMOL&gt;python end
PyMOL&gt;python end
10
</code></pre>
<p>というように表示され、最後に<code>10</code>という結果がprintされたことがわかります。</p>
<p>この機能を使えば、Pythonを使い慣れた方であれば様々な応用可能性があることに気づくと思います。例えば、あるディレクトリの中で目的の構造ファイル群だけPyMOL上にロードしたいという例では、以下のようにPythonスクリプトを書くことができます。</p>
<pre><code class="language-python"># globモジュールをインポートし、ワイルドカード*によって
# 拡張子がcifであるファイルを一括でPyMOL上にロードする
python
from glob import glob

for file in glob(&quot;*.cif&quot;):
    cmd.load(file)
python end
</code></pre>
<h3 id="コマンドを外部ファイルに保存しpymolからスクリプトを呼び出す-1"><a class="header" href="#コマンドを外部ファイルに保存しpymolからスクリプトを呼び出す-1">コマンドを外部ファイルに保存し、PyMOLからスクリプトを呼び出す</a></h3>
<p>上で挙げた一括ロードのPythonスクリプトを繰り返し使いたいときは、別ファイルにスクリプトを保存しておいてそれを呼び出すような形にすれば、毎回入力しなくて済むようになります。この場合は、<code>python</code>と<code>python end</code>の間の部分だけを別のファイル（名前は<code>cifload.py</code>とします）に書いておきます。</p>
<pre><code class="language-python:cifload.py">from glob import glob

for file in glob(&quot;*.cif&quot;):
    cmd.load(file)
</code></pre>
<p>これをPyMOL上から呼び出すときには、コマンドラインから<code>run /path/to/cifload.py</code>として呼び出します（<code>/path/to/</code>の部分は<code>cifload.py</code>が存在するディレクトリパスに適宜置き換えてください）。</p>
<h3 id="拡張コマンドを使えるように読み込む-1"><a class="header" href="#拡張コマンドを使えるように読み込む-1">拡張コマンドを使えるように読み込む</a></h3>
<p>発展的な内容ですが、上記の方法を使えばPyMOLWikiのScript Libraryなどで公開されている拡張コマンドを即座に使えるようにすることもできます。例として, タンパク質の色分けをアミノ酸の疎水性〜親水性に応じて行う<code>color_h</code>, <code>color_h2</code>コマンド（<a href="https://pymolwiki.org/index.php/Color_h">https://pymolwiki.org/index.php/Color_h</a>）を使えるようにします。</p>
<p>上記ページのコードの<code>from pymol import cmd</code>から<code>cmd.extend('color_h2',color_h2)</code>の前に<code>python</code>を、最後に<code>python end</code>を入力することで、<code>color_h</code>, <code>color_h2</code>コマンドが使えるようになります。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/scripting1.mp4" type="video/mp4">
</video>
<p>これによって<code>color_h</code>, <code>color_h2</code>の拡張コマンドが使えるようになりました。もちろん、外部ファイルに保存しておいて<code>run ~~</code>で呼び出すことも可能です。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="pythonからpymolモジュールをimportして使う"><a class="header" href="#pythonからpymolモジュールをimportして使う">Pythonからpymolモジュールをimportして使う</a></h2>
<p>よくプログラミングしているユーザーからすると、PyMOLに使われている様々なコマンドをPython側から呼び出して利用したいということもあるかもしれません。しかし、その設定が環境によってはちょっと難しいので、ここではまずpymolをimportできるようにする設定の方法を確認します。</p>
<p>まずターミナルを開いてPython3を対話型で開き、<code>import pymol</code>を入力してみましょう。<code>python3</code>の部分は<code>python3.10</code>, <code>python3.10</code>の場合もあります。</p>
<pre><code class="language-shell">$ python3
Python 3.10.8 (main, Oct 13 2022, 09:48:40) [Clang 14.0.0 (clang-1400.0.29.102)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import pymol
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ModuleNotFoundError: No module named 'pymol'
&gt;&gt;&gt;
</code></pre>
<p>もしここで<code>ModuleNotFoundError</code>というエラーが表示されずそのまま次の入力<code>&gt;&gt;&gt;</code>が表示された場合はめでたくpymolのモジュールのimportに成功しているのですが、そうでない場合は環境設定を行う必要がありますので、次項以降を確認してみてください。</p>
<p>Homebrewをお使いの場合、2021年5月1日以降のpymol 2.4.0_5からは<code>import pymol</code>が使えるようになっているはずです。</p>
<h3 id="事前準備-pythonのpathとpython内のsyspathの値を確認するmacoslinuxの人向け"><a class="header" href="#事前準備-pythonのpathとpython内のsyspathの値を確認するmacoslinuxの人向け">事前準備: PythonのPATHとpython内のsys.pathの値を確認する（macOS/Linuxの人向け）</a></h3>
<p>ターミナルから以下のコマンドを入力することで<code>python3</code>のバージョン情報およびインストールされているディレクトリの場所を確認することができます。</p>
<pre><code class="language-shell">$ python3 --version
Python 3.10.8
$ ls -l `which python3`
lrwxr-xr-x  1 YoshitakaM  admin  40 10 26 10:06 /usr/local/bin/python3 -&gt; ../Cellar/python@3.10/3.10.8/bin/python3
</code></pre>
<p>今の環境ではPython 3.10.8のバージョンを使用しており、python3は<code>/usr/local/Cellar/python@3.10/3.10.8/bin/python3</code>にあることがわかりました（これもシンボリックリンクで、真の実体はまた別の位置に存在しています）。macOSの場合Cellar以下にpython3がある場合は、それはHomebrewでインストールされたpython3、もっと言うと<code>brew install python@3.10</code>コマンドでインストールされたものとなっています。</p>
<p>次にターミナルからpython3を起動して、以下のコマンド<code>import sys</code>, <code>sys.path</code>を入れてみます。</p>
<pre><code class="language-shell">$ python3
Python 3.10.8 (main, Oct 13 2022, 09:48:40) [Clang 14.0.0 (clang-1400.0.29.102)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python39.zip', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10', '/usr/local/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload', '/Users/YoshitakaM/Library/Python/3.10/lib/python/site-packages', '/usr/local/lib/python3.10/site-packages']
</code></pre>
<p><code>sys.path</code>は起動したpython3に対して、Pythonの追加モジュールを読み込むPATHを表示してくれています。ここにpymolのモジュールへのパス、例えば<code>/usr/local/Cellar/pymol/2.5.0/libexec/lib/python3.10/site-packages/pymol</code>が含まれていない場合はimportに失敗し、<code>ModuleNotFoundError</code>というエラーが発生します。</p>
<p>これを解決する方法は3つあります。</p>
<ol>
<li>環境変数<code>PYTHONPATH</code>を設定し、pymolモジュールがインストールされている場所を追加する</li>
<li><code>import sys</code>, <code>sys.path.append()</code>を使ってpython3の中からモジュール検索パスを追加する</li>
<li>パス設定ファイル(<code>.pth</code>)をpython3のデフォルト<code>site-packages</code>の中に追加する</li>
</ol>
<p>詳しくは https://note.nkmk.me/python-import-module-search-path/ を参照してください。簡単なのは1.の環境変数<code>PYTHONPATH</code>を設定する方法です。Homebrewでは実は3.の方法で実現しています。</p>
<h3 id="pymolモジュールの使い方"><a class="header" href="#pymolモジュールの使い方">pymolモジュールの使い方</a></h3>
<p>普段使いの<code>python3</code>から無事<code>import pymol</code>が成功したら、次にpymolモジュールの使い方を見ていきましょう。</p>
<h4 id="例1-pymolの画像を出力する"><a class="header" href="#例1-pymolの画像を出力する">例1. PyMOLの画像を出力する</a></h4>
<p>PyMOLのGUIを開き、以下のコマンドを入力していきます。</p>
<pre><code>fetch 1alk, type=mmtf
hide everything
select sel1, byres resn * within 5 of (resn PO4 and chain A)
zoom sel1
as sticks, sel1
ray 640,480
png ~/Desktop/foosel1.png
</code></pre>
<p>すると、以下のような画像が出力されます。</p>
<img src="ch05/./image/foosel1.png" title="foosel1">
<p>これと同様のことを、Pythonの<code>import pymol</code>から実行することができます。そのためのコマンドがこちら</p>
<pre><code class="language-python">import pymol
pymol.cmd.fetch(&quot;1alk&quot;, type=&quot;mmtf&quot;)
pymol.cmd.hide(&quot;everything&quot;)
pymol.cmd.select(&quot;sel1&quot;,  &quot;byres resn * within 5 of (resn PO4 and chain A)&quot;)
pymol.cmd.zoom(&quot;sel1&quot;)
pymol.cmd.show_as(&quot;sticks&quot;, &quot;sel1&quot;)
pymol.cmd.ray(&quot;640&quot;, &quot;480&quot;)
pymol.cmd.png(&quot;~/Desktop/foosel2.png&quot;)
</code></pre>
<img src="ch05/./image/foosel2.png" title="foosel2">
<p>このように、同様の結果が得られました。</p>
<p>上記のコマンドでは<code>pymol.cmd</code>と書いていましたが<code>from pymol import cmd</code>とすれば<code>pymol.cmd</code>を<code>cmd</code>と短くすることもできます（Pythonの仕様です）。</p>
<pre><code class="language-python">from pymol import cmd
cmd.fetch(&quot;1alk&quot;, type=&quot;mmtf&quot;)
cmd.hide(&quot;everything&quot;)
cmd.select(&quot;sel1&quot;,  &quot;byres resn * within 5 of (resn PO4 and chain A)&quot;)
cmd.zoom(&quot;sel1&quot;)
cmd.show_as(&quot;sticks&quot;, &quot;sel1&quot;)
cmd.ray(&quot;640&quot;, &quot;480&quot;)
cmd.png(&quot;~/Desktop/foosel2.png&quot;)
</code></pre>
<p>module<code>cmd</code>以下に存在する様々な関数（<code>fetch</code>, <code>hide</code>, <code>select</code>など）はPyMOLのコマンドとほぼ同様ですが、一部は<code>as</code>→<code>show_as</code>のように名前が変更されているものもありますので注意してください。各コマンドの使い方は<a href="https://pymolwiki.org/">PyMOLWiki</a>、またはpymol.orgのサイト上で検索することでも情報が取得できますが、VSCodeなどのエディタ上でのプログラミングに慣れている方であれば、メソッドのヘルプ表示機能などで仕様を直接確認する方が確実かもしれません。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="第6章-プラグインを使う"><a class="header" href="#第6章-プラグインを使う">第6章 プラグインを使う</a></h1>
<p>PyMOLは追加のプラグインを使って機能を拡張させることができます。プラグインといっても、Excelなどで言うところの、マクロみたいなものです。<strong>理論的には、PyMOLに実装されている機能を組み合わせれば実現可能なことは、このプラグイン機能を使うことでワンコマンドで達成できるようになります</strong>。</p>
<p>ここではできあいのプラグインのインストール方法を示しつつ、その中でも便利なものをいくつか紹介したいと思います。</p>
<h2 id="環境"><a class="header" href="#環境">環境</a></h2>
<ul>
<li>macOSまたはLinux OS。Windowsの場合はやり方が異なる可能性があります。</li>
<li>PyMOL 2.0以降をインストールしてある（バイナリ版・conda版・オープンソース版どれでも可）</li>
</ul>
<h2 id="pymolプラグインのインストール方法"><a class="header" href="#pymolプラグインのインストール方法">PyMOLプラグインのインストール方法</a></h2>
<h3 id="プラグインのダウンロード"><a class="header" href="#プラグインのダウンロード">プラグインのダウンロード</a></h3>
<p>例えば私が管理しているもので、 <a href="https://github.com/YoshitakaMo/pymol-psico">https://github.com/YoshitakaMo/pymol-psico</a> があります。これは大元のpsicoからクローンしてきたものです。これを、例としてホームディレクトリ以下の<code>Documents</code>ディレクトリにインストールします。</p>
<pre><code class="language-bash">cd ~/Documents
git clone https://github.com/YoshitakaMo/pymol-psico.git
</code></pre>
<p>以上でこのpymol-psicoディレクトリをコピーしてくることができます。中身のプラグインはすべてpython言語で書かれています。オープンソース版でPyMOLをインストールした場合には、この文法はインストールに使用したpythonのバージョンに依存します。</p>
<h3 id="使用のための初期設定"><a class="header" href="#使用のための初期設定">使用のための初期設定</a></h3>
<p>このプラグインを使える状態にするには、先程のpymol-psicoディレクトリにPyMOL側からPATHを通し、さらに初期化コマンドを入れて上げる必要があります。これは、pymolを開いて以下のコマンドを入力してあげると可能です。</p>
<pre><code class="language-python">sys.path.append(os.path.expanduser('~/Documents/pymol-psico'))
import psico.fullinit
</code></pre>
<p>入力する場所はここ（下の <code>PyMOL&gt;</code>でも良い）</p>
<img src="ch06/./image/inst1.png" width="100%" alt="プラグイン使用のための初期設定" title="プラグイン使用のための初期設定">
<p>1行目はPATHの追加コマンドです。先程、psicoディレクトリを<code>~/Documents</code>にインストールしたので、上の例では<code>(os.path.expanduser('~/Documents/pymol-psico'))</code>となっていますが、<code>~/Documents</code>以外のディレクトリに置いた場合は適宜このPATHを変更してください。2行目は、psicoモジュールの初期化コマンドです。Pythonの<code>import</code>コマンドでpsicoを使えるようにします。</p>
<p>しかし、これを毎回PyMOLを立ち上げるたびに入れるのは面倒です。そこで、<strong>PyMOLを開いた時に最初に読み込まれる設定ファイル、<code>~/.pymolrc</code>に上の設定を書いておきましょう</strong>。（参考：<a href="ch06/../ch03/file.html#edit-pymolrc">3.1 FileのEdit pymolrcの項</a>）そうすると、PyMOL起動時に自動で上のプラグインが使えるようになります。</p>
<h2 id="dsspプラグイン"><a class="header" href="#dsspプラグイン">DSSPプラグイン</a></h2>
<p><a href="ch06/installation.html">プラグインのインストール方法</a>の手順に従ってpsicoのインストールがうまく行っていれば、改めて起動した後にPyMOLのコマンドラインで<code>dssp</code>というコマンドが使えるようになっているはずです。このコマンドは開いているタンパク質に対して二次構造アサインメントプログラムの<strong>DSSP</strong>をかけてくれて、その計算結果をもとに表示を切り替えてくれます。ただし利用するためにはあらかじめ<code>mkdssp</code>コマンドがインストールされ、かつ動作することが条件です。現在、最新版のDSSPは以下のHomebrewコマンドからインストールすることができます。</p>
<pre><code>brew install brewsci/bio/dssp
</code></pre>
<p>このdsspパッケージの中に<code>mkdssp</code>コマンドが入っています。ちなみにCentOS 7の方は、<code>yum -y install dssp</code>とすれば簡単に<code>mkdssp</code>コマンドがインストールできます。バージョンがちょっと古いですけど問題なく動作するはずです。</p>
<p>そしてPyMOLの画面に戻り、dsspコマンドを打てば、以下のような表示になります。
<img src="ch06/./image/dssp1.png" width="100%" alt="DSSPの使用例" title="DSSPの使用例"></p>
<p>DSSPプログラムによって判定された二次構造アサインの結果に対応して、PyMOL上の二次構造表示が変化し、色分けされたものになります。DSSPによる二次構造アサイン法とPyMOLネイティヴで入っているアサイン法は微妙に異なるため、細かいところをよーくみてみると、ものによっては二次構造アサインが変化している場合があります。DSSPによる二次構造判定法は現在もなおProtein Data Bankで公式に採用されていますので、こちらを使って表示させたほうが良いと個人的に思います。</p>
<p>また、MDシミュレーションの結果をPyMOLで表示している方の場合、初期構造からシミュレーションの途中でタンパク質の二次構造が変化した場合でも、そのフレームで<code>dssp</code>と打てば、そのフレームに合わせた二次構造表示に変化してくれるところが便利です。</p>
<p>これらのコマンドの説明は<code>PyMOL &gt;</code>の欄に<code>help dssp</code>と打てば表示されます。オプションが色々ついているPyMOLコマンドは多いので、確認しておきましょう。例えばこのdsspコマンドの場合は</p>
<pre><code>DESCRIPTION

    Secondary structure assignment with DSSP.
    http://swift.cmbi.ru.nl/gv/dssp/

ARGUMENTS

    selection = string: atom selection {default: all}

    exe = string: name of dssp executable {default: mkdssp}

    raw = string: atom property to load raw dssp class into {default: 'custom'}

    color = string: color in response to secondary structure {default: 1/ON}

EXAMPLE

    dssp all, /usr/local/bin/mkdssp, raw=text_type
    color gray
    color red, text_type H
    color orange, text_type G
    color yellow, text_type E
    color wheat, text_type B
    color forest, text_type T
    color green, text_type S
    set cartoon_discrete_colors, 1

SEE ALSO

    dss, stride
</code></pre>
<p>と表示されます。colorがデフォルトでONになっています。二次構造についての色分けを自動でしてほしくない場合には、<code>dssp color=0</code>と打てば、さっきのような色分けをしないで二次構造表示だけ変更してくれます（←地味によく使う）。</p>
<h3 id="dsspプラグインの設定を変更してみる"><a class="header" href="#dsspプラグインの設定を変更してみる">DSSPプラグインの設定を変更してみる</a></h3>
<p><strong>DSSPのカラーリングが気に入らない、他の色で塗り分けたい！</strong> という場合は、せっかくなのでプラグインを書き換えてみましょう（ちなみに上の設定のカラーリングは有名な<a href="https://ethanschoonover.com/solarized/">Solarized Dark</a>のテーマを模しています）。</p>
<p>psidoディレクトリの中にある<code>editing.py</code>の258行目あたりからがdsspの関数定義になっています。</p>
<pre><code class="language-python">def dssp(selection='(all)', exe='', raw='custom', state=-1, quiet=1, color=1):
    '''
DESCRIPTION

    Secondary structure assignment with DSSP.
    http://swift.cmbi.ru.nl/gv/dssp/
</code></pre>
<p>ここで<code>color=1</code>となっていますが、<code>dssp</code>コマンドを打ってみた時に、デフォルトでカラーリングを変えてほしくない場合はここを<code>color=0</code>としておくとよいでしょう。
この下をさらに見てみると、色分け設定をしている部分が見られます。</p>
<pre><code class="language-python">    # if color=1
    if color == 1:
        cmd.color('gray', selection)
        cmd.set_color('H_color', [220, 50, 47])
        cmd.color('H_color', raw+' H')
        cmd.set_color('G_color', [211, 54, 130])
        cmd.color('G_color', raw+' G')
        cmd.set_color('I_color', [255, 170, 170])
        cmd.color('I_color', raw+' I')
        cmd.set_color('E_color', [196, 177, 3])
        cmd.color('E_color', raw+' E')
        cmd.set_color('B_color', [42, 161, 152])
        cmd.color('B_color', raw+' B')
        cmd.set_color('T_color', [38, 139, 210])
        cmd.color('T_color', raw+' T')
        cmd.set_color('G_color', [211, 54, 130])
        cmd.color('G_color', raw+' G')
        cmd.set_color('S_color', [133, 153, 0])
        cmd.color('S_color', raw+' S')
        cmd.set('cartoon_discrete_colors', '1')
        cmd.util.cnc(selection)
</code></pre>
<p><code>cmd.set_color</code>はPyMOLに最初から実装されているコマンド<code>set_color</code>そのものであり、ここでは<code>H_color</code>という名前でRGB色使いの<code>(220, 50, 47)</code>を定義しています。詳しい説明は<a href="https://pymolwiki.org/index.php/Set_Color">PyMOLWiki</a>を読んでね。DSSPの定義で、αヘリックスはH、βシートはEという一文字表記になっているので、ここでの<code>cmd.color('H_color', raw+' H')</code>部分は、「DSSPでHと判定された残基をH_colorで色付けする」という意味になっています。つまり、ここの色の値を変えれば、DSSPの二次構造判定に対して思い通りの色分けを行うことができます。</p>
<h2 id="pyvol-guiプラグイン"><a class="header" href="#pyvol-guiプラグイン">PyVOL GUIプラグイン</a></h2>
<p>2019年10月24日、<a href="https://www.biorxiv.org/content/10.1101/816702v1">BioRxivにPyMOLプラグインの<strong>PyVOL</strong>というのを開発したよという論文</a>が投稿されました。</p>
<img src="ch06/./image/pyvol1.jpg" width="100%" alt="PyVOL" title="PyVOL">
<p>これはタンパク質の中の空隙、つまり基質や薬剤などが入りそうな空間を検出し、体積の値の表示もしてくれるプラグインのようです。ちょっと興味があったのでインストールすることにしてみました。</p>
<h3 id="使用可能な環境"><a class="header" href="#使用可能な環境">使用可能な環境</a></h3>
<ul>
<li>Linux OSまたはmacOS 10.14.6 (Mojave)以前。<strong>10.15 (Catalina)では今のところ動作しません。</strong>（現在対応中だそうです）</li>
</ul>
<h3 id="pyvolのインストール"><a class="header" href="#pyvolのインストール">PyVOLのインストール</a></h3>
<p>以下のGitHubにてこのプラグインをメンテナンスしてくれているようです。
<a href="https://github.com/schlessingerlab/pyvol/">https://github.com/schlessingerlab/pyvol/</a></p>
<p>ここの <a href="https://github.com/schlessingerlab/pyvol/blob/master/pyvolgui.zip">https://github.com/schlessingerlab/pyvol/blob/master/pyvolgui.zip</a> にプラグインのZIPファイルが置いてあるのでDownloadボタンを押すと、<code>pyvolgui.zip</code>というファイルがダウンロードされます。これを展開すると、中には<code>pyvolgui</code>と<code>pyvol_plugin</code>というディレクトリの2つがあるのですが、たぶん<code>pyvolgui</code>だけで動作してくれるように思えます。よって、このディレクトリをPyMOLのプラグインディレクトリにコピーしてあげます。
お使いのmacOSにて、インストーラー版でPyMOLをインストールした場合（Licenseを求められる方）は<code>/Applications/PyMOL.app/Contents/share/pymol/data/startup/</code>に、Homebrewを使ってOpen-source版をインストールした場合（Licenseがいらない方）には<code>/usr/local/Cellar/pymol/2.3.0/libexec/lib/python3.7/site-packages/pmg_tk/startup</code>に、それぞれコピーしてあげます。Linuxの場合はpymolがインストールされているディレクトリを見つけて<code>python3.x/site-packages/pmg_tk/startup</code>あたりを探ればたどり着けるんじゃないですかね（適当）。</p>
<p>コピーしたら、PyMOLを起動している場合はいったん閉じて改めて起動します。すると、PluginメニューのところにPyVOLが増えているはずです。</p>
<img width="176" alt="pyvol_pluginメニュー" src="ch06/./image/pyvol2.png">
<p>このPyVOLを選択してみて、メニューが開けたら成功です。</p>
<img width="100%" alt="pyvol_menu" src="ch06/./image/pyvol3.png">
<h3 id="追加のプログラムのインストール"><a class="header" href="#追加のプログラムのインストール">追加のプログラムのインストール</a></h3>
<h4 id="インストーラー版"><a class="header" href="#インストーラー版">インストーラー版</a></h4>
<p>PyVOLを動かすためにはいくつかのライブラリやプログラムを追加でインストールさせてあげる必要があります。上のPyVOLメニューで<strong>Install/Update</strong>のタブを開き、ここの左に表示されている<code>Install PyVOL</code>ボタンを押します。</p>
<img width="100%" alt="pyvolインストール直後" src="ch06/./image/pyvol4.png">
<p>1分くらい待っていると追加プログラムがすべてインストールされ、使用可能な状態になります。</p>
<img width="100%" alt="pyvolの追加プログラムインストール後" src="ch06/./image/pyvol5.png">
<p>ちなみに<strong>macOS catalinaでは動作しませんでした</strong>（Mojaveまでは動作します）。</p>
<pre><code>subprocess.py&quot;, line 1522, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
OSError: [Errno 86] Bad CPU type in executable: 'msms'
</code></pre>
<p>これはcatalinaになってから32bitのプログラムを切り捨てたことに起因しています。現在公式で対応中だそうです。</p>
<h4 id="open-source版"><a class="header" href="#open-source版">Open-Source版</a></h4>
<p>Open-source版の場合は、もしかしたら追加のプログラムを手動でインストールする必要があるかもしれません。もしかしたら上と同じやり方で動作させることができるかもしれないので、先にそっちを試してください（雑）。Homebrewでインストールしていた場合、<code>msms exe</code>を除く他のPythonライブラリは以下の1コマンドでインストールできます。</p>
<pre><code>pip3.7 install bio-pyvol
</code></pre>
<img width="100%" alt="pyvolの追加プログラムインストール後" src="ch06/./image/pyvol6.png">
<p><code>msms exe</code>についてですが、これは http://mgltools.scripps.edu/downloads のところからMSMS 2.6.1をダウンロードして解凍すると、中に<code>msms.MacOSX.2.6.1</code>が存在しますので、それを利用します(macOS Mojave以前の場合)。これを、<code>/usr/local/bin/msms</code>として利用できるようにコピーしてあげます。</p>
<pre><code>cp ~/Downloads/msms_MacOSX_2.6.1/msms_MacOSX_2.6.1 /usr/local/bin/msms
</code></pre>
<p>この後、Open-source PyMOLを一度再起動してこのInstall/Updateタブを見てみたときに、msms exeのところが<code>/usr/local/bin/msms</code>と表示されていればOKです（本当は<code>/usr/local/bin</code>以下はHomebrewでインストールしたもののみにしておきたいところですが……）。</p>
<p>Linux OSの場合は64 bit版<code>msms</code>が公開されているので、それをダウンロードして同様に<code>/usr/local/bin</code>以下にコピーすれば動作します。</p>
<p>以上でPyVOLが利用可能になります。</p>
<h3 id="簡単な使い方"><a class="header" href="#簡単な使い方">簡単な使い方</a></h3>
<p>タンパク質を選択しておいてからPyVOLプラグインのParametersタブのRunボタンを押すだけです。Load Pocketのタブでは描画方法を色々変えることもできます。（詳細はいつか書きます）</p>
<img width="100%" alt="pyvol load pocketメニュー" src="ch06/./image/pyvol7.png">
## pLDDTカラーリングプラグイン
<p><a href="ch06/installation.html">プラグインのインストール方法</a>の手順に従って森脇の<strong>pymol-psico</strong>のインストールがうまく行っていれば、改めて起動した後にPyMOLのコマンドラインで<code>plddt</code>というコマンドが使えるようになっています。このコマンドはAlphaFold2またはColabFoldで予測された構造に対し、予測のpLDDT値に応じて色分けを行ってくれます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/plddt.mp4" type="video/mp4">
</video>
<p>デフォルトでの色分けは<a href="https://alphafold.ebi.ac.uk/">AlphaFold Protein Structure Database</a>で使われている配色に準じています。</p>
<img src="ch06/./image/plddt1.png" width="100%" alt="" title="">
<p>別のカラーリングスキームとして<code>spectrum</code>があります。例えば<code>plddt (selection), spectrum, 50, 90</code>とすると、(selection)に入れたオブジェクトについてpLDDT値の下限（赤色）を50に上限（青色）を90としてグラデーション配色してくれます。</p>
<img src="ch06/./image/plddt2.png" width="100%" alt="" title="">
<p>詳細は<code>help plddt</code>を御覧ください。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="pymolプラグインのインストール方法-1"><a class="header" href="#pymolプラグインのインストール方法-1">PyMOLプラグインのインストール方法</a></h2>
<h3 id="プラグインのダウンロード-1"><a class="header" href="#プラグインのダウンロード-1">プラグインのダウンロード</a></h3>
<p>例えば私が管理しているもので、 <a href="https://github.com/YoshitakaMo/pymol-psico">https://github.com/YoshitakaMo/pymol-psico</a> があります。これは大元のpsicoからクローンしてきたものです。これを、例としてホームディレクトリ以下の<code>Documents</code>ディレクトリにインストールします。</p>
<pre><code class="language-bash">cd ~/Documents
git clone https://github.com/YoshitakaMo/pymol-psico.git
</code></pre>
<p>以上でこのpymol-psicoディレクトリをコピーしてくることができます。中身のプラグインはすべてpython言語で書かれています。オープンソース版でPyMOLをインストールした場合には、この文法はインストールに使用したpythonのバージョンに依存します。</p>
<h3 id="使用のための初期設定-1"><a class="header" href="#使用のための初期設定-1">使用のための初期設定</a></h3>
<p>このプラグインを使える状態にするには、先程のpymol-psicoディレクトリにPyMOL側からPATHを通し、さらに初期化コマンドを入れて上げる必要があります。これは、pymolを開いて以下のコマンドを入力してあげると可能です。</p>
<pre><code class="language-python">sys.path.append(os.path.expanduser('~/Documents/pymol-psico'))
import psico.fullinit
</code></pre>
<p>入力する場所はここ（下の <code>PyMOL&gt;</code>でも良い）</p>
<img src="ch06/./image/inst1.png" width="100%" alt="プラグイン使用のための初期設定" title="プラグイン使用のための初期設定">
<p>1行目はPATHの追加コマンドです。先程、psicoディレクトリを<code>~/Documents</code>にインストールしたので、上の例では<code>(os.path.expanduser('~/Documents/pymol-psico'))</code>となっていますが、<code>~/Documents</code>以外のディレクトリに置いた場合は適宜このPATHを変更してください。2行目は、psicoモジュールの初期化コマンドです。Pythonの<code>import</code>コマンドでpsicoを使えるようにします。</p>
<p>しかし、これを毎回PyMOLを立ち上げるたびに入れるのは面倒です。そこで、<strong>PyMOLを開いた時に最初に読み込まれる設定ファイル、<code>~/.pymolrc</code>に上の設定を書いておきましょう</strong>。（参考：<a href="ch06/../ch03/file.html#edit-pymolrc">3.1 FileのEdit pymolrcの項</a>）そうすると、PyMOL起動時に自動で上のプラグインが使えるようになります。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="dsspプラグイン-1"><a class="header" href="#dsspプラグイン-1">DSSPプラグイン</a></h2>
<p><a href="ch06/installation.html">プラグインのインストール方法</a>の手順に従ってpsicoのインストールがうまく行っていれば、改めて起動した後にPyMOLのコマンドラインで<code>dssp</code>というコマンドが使えるようになっているはずです。このコマンドは開いているタンパク質に対して二次構造アサインメントプログラムの<strong>DSSP</strong>をかけてくれて、その計算結果をもとに表示を切り替えてくれます。ただし利用するためにはあらかじめ<code>mkdssp</code>コマンドがインストールされ、かつ動作することが条件です。現在、最新版のDSSPは以下のHomebrewコマンドからインストールすることができます。</p>
<pre><code>brew install brewsci/bio/dssp
</code></pre>
<p>このdsspパッケージの中に<code>mkdssp</code>コマンドが入っています。ちなみにCentOS 7の方は、<code>yum -y install dssp</code>とすれば簡単に<code>mkdssp</code>コマンドがインストールできます。バージョンがちょっと古いですけど問題なく動作するはずです。</p>
<p>そしてPyMOLの画面に戻り、dsspコマンドを打てば、以下のような表示になります。
<img src="ch06/./image/dssp1.png" width="100%" alt="DSSPの使用例" title="DSSPの使用例"></p>
<p>DSSPプログラムによって判定された二次構造アサインの結果に対応して、PyMOL上の二次構造表示が変化し、色分けされたものになります。DSSPによる二次構造アサイン法とPyMOLネイティヴで入っているアサイン法は微妙に異なるため、細かいところをよーくみてみると、ものによっては二次構造アサインが変化している場合があります。DSSPによる二次構造判定法は現在もなおProtein Data Bankで公式に採用されていますので、こちらを使って表示させたほうが良いと個人的に思います。</p>
<p>また、MDシミュレーションの結果をPyMOLで表示している方の場合、初期構造からシミュレーションの途中でタンパク質の二次構造が変化した場合でも、そのフレームで<code>dssp</code>と打てば、そのフレームに合わせた二次構造表示に変化してくれるところが便利です。</p>
<p>これらのコマンドの説明は<code>PyMOL &gt;</code>の欄に<code>help dssp</code>と打てば表示されます。オプションが色々ついているPyMOLコマンドは多いので、確認しておきましょう。例えばこのdsspコマンドの場合は</p>
<pre><code>DESCRIPTION

    Secondary structure assignment with DSSP.
    http://swift.cmbi.ru.nl/gv/dssp/

ARGUMENTS

    selection = string: atom selection {default: all}

    exe = string: name of dssp executable {default: mkdssp}

    raw = string: atom property to load raw dssp class into {default: 'custom'}

    color = string: color in response to secondary structure {default: 1/ON}

EXAMPLE

    dssp all, /usr/local/bin/mkdssp, raw=text_type
    color gray
    color red, text_type H
    color orange, text_type G
    color yellow, text_type E
    color wheat, text_type B
    color forest, text_type T
    color green, text_type S
    set cartoon_discrete_colors, 1

SEE ALSO

    dss, stride
</code></pre>
<p>と表示されます。colorがデフォルトでONになっています。二次構造についての色分けを自動でしてほしくない場合には、<code>dssp color=0</code>と打てば、さっきのような色分けをしないで二次構造表示だけ変更してくれます（←地味によく使う）。</p>
<h3 id="dsspプラグインの設定を変更してみる-1"><a class="header" href="#dsspプラグインの設定を変更してみる-1">DSSPプラグインの設定を変更してみる</a></h3>
<p><strong>DSSPのカラーリングが気に入らない、他の色で塗り分けたい！</strong> という場合は、せっかくなのでプラグインを書き換えてみましょう（ちなみに上の設定のカラーリングは有名な<a href="https://ethanschoonover.com/solarized/">Solarized Dark</a>のテーマを模しています）。</p>
<p>psidoディレクトリの中にある<code>editing.py</code>の258行目あたりからがdsspの関数定義になっています。</p>
<pre><code class="language-python">def dssp(selection='(all)', exe='', raw='custom', state=-1, quiet=1, color=1):
    '''
DESCRIPTION

    Secondary structure assignment with DSSP.
    http://swift.cmbi.ru.nl/gv/dssp/
</code></pre>
<p>ここで<code>color=1</code>となっていますが、<code>dssp</code>コマンドを打ってみた時に、デフォルトでカラーリングを変えてほしくない場合はここを<code>color=0</code>としておくとよいでしょう。
この下をさらに見てみると、色分け設定をしている部分が見られます。</p>
<pre><code class="language-python">    # if color=1
    if color == 1:
        cmd.color('gray', selection)
        cmd.set_color('H_color', [220, 50, 47])
        cmd.color('H_color', raw+' H')
        cmd.set_color('G_color', [211, 54, 130])
        cmd.color('G_color', raw+' G')
        cmd.set_color('I_color', [255, 170, 170])
        cmd.color('I_color', raw+' I')
        cmd.set_color('E_color', [196, 177, 3])
        cmd.color('E_color', raw+' E')
        cmd.set_color('B_color', [42, 161, 152])
        cmd.color('B_color', raw+' B')
        cmd.set_color('T_color', [38, 139, 210])
        cmd.color('T_color', raw+' T')
        cmd.set_color('G_color', [211, 54, 130])
        cmd.color('G_color', raw+' G')
        cmd.set_color('S_color', [133, 153, 0])
        cmd.color('S_color', raw+' S')
        cmd.set('cartoon_discrete_colors', '1')
        cmd.util.cnc(selection)
</code></pre>
<p><code>cmd.set_color</code>はPyMOLに最初から実装されているコマンド<code>set_color</code>そのものであり、ここでは<code>H_color</code>という名前でRGB色使いの<code>(220, 50, 47)</code>を定義しています。詳しい説明は<a href="https://pymolwiki.org/index.php/Set_Color">PyMOLWiki</a>を読んでね。DSSPの定義で、αヘリックスはH、βシートはEという一文字表記になっているので、ここでの<code>cmd.color('H_color', raw+' H')</code>部分は、「DSSPでHと判定された残基をH_colorで色付けする」という意味になっています。つまり、ここの色の値を変えれば、DSSPの二次構造判定に対して思い通りの色分けを行うことができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="pyvol-guiプラグイン-1"><a class="header" href="#pyvol-guiプラグイン-1">PyVOL GUIプラグイン</a></h2>
<p>2019年10月24日、<a href="https://www.biorxiv.org/content/10.1101/816702v1">BioRxivにPyMOLプラグインの<strong>PyVOL</strong>というのを開発したよという論文</a>が投稿されました。</p>
<img src="ch06/./image/pyvol1.jpg" width="100%" alt="PyVOL" title="PyVOL">
<p>これはタンパク質の中の空隙、つまり基質や薬剤などが入りそうな空間を検出し、体積の値の表示もしてくれるプラグインのようです。ちょっと興味があったのでインストールすることにしてみました。</p>
<h3 id="使用可能な環境-1"><a class="header" href="#使用可能な環境-1">使用可能な環境</a></h3>
<ul>
<li>Linux OSまたはmacOS 10.14.6 (Mojave)以前。<strong>10.15 (Catalina)では今のところ動作しません。</strong>（現在対応中だそうです）</li>
</ul>
<h3 id="pyvolのインストール-1"><a class="header" href="#pyvolのインストール-1">PyVOLのインストール</a></h3>
<p>以下のGitHubにてこのプラグインをメンテナンスしてくれているようです。
<a href="https://github.com/schlessingerlab/pyvol/">https://github.com/schlessingerlab/pyvol/</a></p>
<p>ここの <a href="https://github.com/schlessingerlab/pyvol/blob/master/pyvolgui.zip">https://github.com/schlessingerlab/pyvol/blob/master/pyvolgui.zip</a> にプラグインのZIPファイルが置いてあるのでDownloadボタンを押すと、<code>pyvolgui.zip</code>というファイルがダウンロードされます。これを展開すると、中には<code>pyvolgui</code>と<code>pyvol_plugin</code>というディレクトリの2つがあるのですが、たぶん<code>pyvolgui</code>だけで動作してくれるように思えます。よって、このディレクトリをPyMOLのプラグインディレクトリにコピーしてあげます。
お使いのmacOSにて、インストーラー版でPyMOLをインストールした場合（Licenseを求められる方）は<code>/Applications/PyMOL.app/Contents/share/pymol/data/startup/</code>に、Homebrewを使ってOpen-source版をインストールした場合（Licenseがいらない方）には<code>/usr/local/Cellar/pymol/2.3.0/libexec/lib/python3.7/site-packages/pmg_tk/startup</code>に、それぞれコピーしてあげます。Linuxの場合はpymolがインストールされているディレクトリを見つけて<code>python3.x/site-packages/pmg_tk/startup</code>あたりを探ればたどり着けるんじゃないですかね（適当）。</p>
<p>コピーしたら、PyMOLを起動している場合はいったん閉じて改めて起動します。すると、PluginメニューのところにPyVOLが増えているはずです。</p>
<img width="176" alt="pyvol_pluginメニュー" src="ch06/./image/pyvol2.png">
<p>このPyVOLを選択してみて、メニューが開けたら成功です。</p>
<img width="100%" alt="pyvol_menu" src="ch06/./image/pyvol3.png">
<h3 id="追加のプログラムのインストール-1"><a class="header" href="#追加のプログラムのインストール-1">追加のプログラムのインストール</a></h3>
<h4 id="インストーラー版-1"><a class="header" href="#インストーラー版-1">インストーラー版</a></h4>
<p>PyVOLを動かすためにはいくつかのライブラリやプログラムを追加でインストールさせてあげる必要があります。上のPyVOLメニューで<strong>Install/Update</strong>のタブを開き、ここの左に表示されている<code>Install PyVOL</code>ボタンを押します。</p>
<img width="100%" alt="pyvolインストール直後" src="ch06/./image/pyvol4.png">
<p>1分くらい待っていると追加プログラムがすべてインストールされ、使用可能な状態になります。</p>
<img width="100%" alt="pyvolの追加プログラムインストール後" src="ch06/./image/pyvol5.png">
<p>ちなみに<strong>macOS catalinaでは動作しませんでした</strong>（Mojaveまでは動作します）。</p>
<pre><code>subprocess.py&quot;, line 1522, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
OSError: [Errno 86] Bad CPU type in executable: 'msms'
</code></pre>
<p>これはcatalinaになってから32bitのプログラムを切り捨てたことに起因しています。現在公式で対応中だそうです。</p>
<h4 id="open-source版-1"><a class="header" href="#open-source版-1">Open-Source版</a></h4>
<p>Open-source版の場合は、もしかしたら追加のプログラムを手動でインストールする必要があるかもしれません。もしかしたら上と同じやり方で動作させることができるかもしれないので、先にそっちを試してください（雑）。Homebrewでインストールしていた場合、<code>msms exe</code>を除く他のPythonライブラリは以下の1コマンドでインストールできます。</p>
<pre><code>pip3.7 install bio-pyvol
</code></pre>
<img width="100%" alt="pyvolの追加プログラムインストール後" src="ch06/./image/pyvol6.png">
<p><code>msms exe</code>についてですが、これは http://mgltools.scripps.edu/downloads のところからMSMS 2.6.1をダウンロードして解凍すると、中に<code>msms.MacOSX.2.6.1</code>が存在しますので、それを利用します(macOS Mojave以前の場合)。これを、<code>/usr/local/bin/msms</code>として利用できるようにコピーしてあげます。</p>
<pre><code>cp ~/Downloads/msms_MacOSX_2.6.1/msms_MacOSX_2.6.1 /usr/local/bin/msms
</code></pre>
<p>この後、Open-source PyMOLを一度再起動してこのInstall/Updateタブを見てみたときに、msms exeのところが<code>/usr/local/bin/msms</code>と表示されていればOKです（本当は<code>/usr/local/bin</code>以下はHomebrewでインストールしたもののみにしておきたいところですが……）。</p>
<p>Linux OSの場合は64 bit版<code>msms</code>が公開されているので、それをダウンロードして同様に<code>/usr/local/bin</code>以下にコピーすれば動作します。</p>
<p>以上でPyVOLが利用可能になります。</p>
<h3 id="簡単な使い方-1"><a class="header" href="#簡単な使い方-1">簡単な使い方</a></h3>
<p>タンパク質を選択しておいてからPyVOLプラグインのParametersタブのRunボタンを押すだけです。Load Pocketのタブでは描画方法を色々変えることもできます。（詳細はいつか書きます）</p>
<img width="100%" alt="pyvol load pocketメニュー" src="ch06/./image/pyvol7.png">
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="plddtカラーリングプラグイン"><a class="header" href="#plddtカラーリングプラグイン">pLDDTカラーリングプラグイン</a></h2>
<p><a href="ch06/installation.html">プラグインのインストール方法</a>の手順に従って森脇の<strong>pymol-psico</strong>のインストールがうまく行っていれば、改めて起動した後にPyMOLのコマンドラインで<code>plddt</code>というコマンドが使えるようになっています。このコマンドはAlphaFold2またはColabFoldで予測された構造に対し、予測のpLDDT値に応じて色分けを行ってくれます。</p>
<video width="100%" height="100%" controls autoplay loop>
<source src="./image/plddt.mp4" type="video/mp4">
</video>
<p>デフォルトでの色分けは<a href="https://alphafold.ebi.ac.uk/">AlphaFold Protein Structure Database</a>で使われている配色に準じています。</p>
<img src="ch06/./image/plddt1.png" width="100%" alt="" title="">
<p>別のカラーリングスキームとして<code>spectrum</code>があります。例えば<code>plddt (selection), spectrum, 50, 90</code>とすると、(selection)に入れたオブジェクトについてpLDDT値の下限（赤色）を50に上限（青色）を90としてグラデーション配色してくれます。</p>
<img src="ch06/./image/plddt2.png" width="100%" alt="" title="">
<p>詳細は<code>help plddt</code>を御覧ください。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<h2 id="インストール方法"><a class="header" href="#インストール方法">インストール方法</a></h2>
<p>大きく分けて、<strong>公式ウェブサイトで配布されているバイナリを入れる方法</strong>（バイナリ版）と、<strong>自身でPyMOLをソースコードからビルド＆コンパイルし、インストールする方法</strong>（オープンソース版）の2通りがあります。初心者に対しては確実に前者の方をおすすめしますが、<strong>ライセンス認証を求められる</strong>（一応無視しても使えるが少し煩わしい）というデメリットがあり、反対に後者のやり方では、ライセンス認証は求められないものの、インストールがやや難しく、玄人向けと言えます。</p>
<table><thead><tr><th align="left"></th><th align="center">バイナリ版</th><th align="center">オープンソース版</th></tr></thead><tbody>
<tr><td align="left">メリット</td><td align="center"><strong>インストールがとても簡単</strong><br>APBSを始めとした、いくつかのプラグインがプリインストールされている</td><td align="center"><strong>ライセンス認証が不要</strong></td></tr>
<tr><td align="left">デメリット</td><td align="center"><strong>起動時にライセンス認証を求められる</strong></td><td align="center"><strong>インストールが煩雑</strong><br>プラグインが同梱されていない（手動で追加インストールすることが求められる）</td></tr>
<tr><td align="left">備考</td><td align="center">有料ライセンスならば、専用の追加機能を利用できる（特にSchrödinger Maestroとの連携）</td><td align="center"></td></tr>
</tbody></table>
<p>PyMOLライセンスは基本的に有料で、1年または3年契約なのですが、教育用のサブスクリプション(Educational Subscription)ライセンスは、ウェブ上で申請することで<strong>無料</strong>で発行されます。いずれのライセンスを取得する場合でも、まずhttps://pymol.org/2/buy.html にアクセスし、申請フォームを埋めることでライセンス発行の手続きを進めることができます。</p>
<h3 id="バイナリ版のインストール方法"><a class="header" href="#バイナリ版のインストール方法">バイナリ版のインストール方法</a></h3>
<p>バイナリ版のインストール方法はとても簡単で、<a href="https://pymol.org/2/">公式ウェブサイト</a>のDownloadのところからインストーラーを取得することができます。Windows, macOS, Linuxいずれの場合も、基本的にはインストーラーを展開して指示に従ってインストールを進めるだけでOKのはずです。</p>
<h3 id="オープンソース版のインストール方法"><a class="header" href="#オープンソース版のインストール方法">オープンソース版のインストール方法</a></h3>
<p>オープンソース版のインストール方法は、OSの種類によって大きく異なります。</p>
<h4 id="windows-10の場合-2"><a class="header" href="#windows-10の場合-2">Windows 10の場合</a></h4>
<p>tonets先生のQiita記事 https://qiita.com/tonets/items/1927058e4297fc1c060d をアップデートする形で書きます。</p>
<p>WindowsではまずPython3が使える環境を構築する必要があります。これには様々な流儀がありますが、Anacondaを使う流儀で紹介します。</p>
<p>まずAnacondaを使ってPythonをインストールします。このときのバージョンはPython3.8です。</p>
<p>https://www.anaconda.com/products/individual</p>
<p>インストーラーをダウンロードしてきたら基本的にはデフォルトのままNextを押していきます。個人（only me）にインストールするか、システム全体にインストールするかを聞かれるところがありますが、ここでは個人を選択しておきます。</p>
<p>インストールされた場所を確認します。おそらく<code>C:\Users\ユーザー名\Anaconda3\</code>に <code>python.exe</code>があります。</p>
<p>コマンドプロンプトを立ち上げて（ショートカットキーWin+Rを押したあと、<code>cmd</code>と入力すると早い、もしかすると管理者権限が必要かも）、<code>cd C:\Users\ユーザー名\Anaconda3</code>としてAnaconda3のディレクトリに移動した後</p>
<pre><code>python.exe -m pip install --upgrade pip
</code></pre>
<p>として、<code>pip</code>をアップグレードする処理が働くかどうかを確認します。</p>
<p>ここでもし</p>
<pre><code>pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available.
</code></pre>
<p>というエラーが出る場合、OpenSSLの設定がうまくできていないみたいなので、以下のような回避策を行います。</p>
<p>Windowsのスタートボタンにある検索メニューに<strong>環境変数名の編集</strong>と入力し、環境変数の変数を行います。ここではPathの部分をダブルクリックし、画像のように環境変数名を編集して追加します。</p>
<img src="append01/./image/windows_inst1.png">
<p>一番下の設定は、私の環境では<code>Anaconda3\pkgs\openssl-1.1.1h-he774522_0\Library\bin</code>でしたが、Anacondaのバージョンによって微妙にopensslのディレクトリ名が変わるので、適宜確認してから入力してください。</p>
<p>この環境変数を追記したら、改めてコマンドプロンプトをいったん閉じて開き直し、<code>pip</code>のアップグレードがうまく行われることを確認してください。</p>
<p>うまくアップグレードされたようでしたら、次にPyMOLのビルドに必要なパッケージをダウンロードしインストールします。必要なファイルは https://www.lfd.uci.edu/~gohlke/pythonlibs/ の<strong>Pymol-open-source</strong>にある</p>
<ul>
<li>pymol_launcher-2.1-cp38-cp38-win_amd64.whl</li>
<li>pymol-2.4.0-cp38-cp38-win_amd64.whl</li>
<li>Pmw-2.0.1-py3-none-any.whl</li>
</ul>
<p>と、<strong>NumPy</strong>のところにある</p>
<ul>
<li>numpy-1.19.5+mkl-cp38-cp38-win_amd64.whl</li>
</ul>
<p>です。注意点として、<code>cpXX</code>の数字は必ずAnacondaのPythonバージョンと合わせてください。例えばAnacondaのPythonバージョンがPython 3.8.xならば、<code>cp38</code>を選びます。時間が経つに連れ、バージョンがともにアップデートされていきますので、それに合わせます。また、<code>win32</code>と<code>win_amd64</code>がありますが、これは今の時代でしたら基本的には<code>win_amd64</code>の方を使います。<code>win32</code>はたぶんそのうち絶滅します。また、現在<code>pymol-2.5.0a0</code>も存在していますが、基本的に<code>a0</code>は未完成の試作品なので、安定動作を取りたい人は手を出さないほうが良いでしょう。</p>
<p>これらを揃えたら、先程の<code>Anaconda3</code>の<code>python.exe</code>があったディレクトリに入れておきます。そしてコマンドプロンプトを開き、以下の順でインストールを行います。</p>
<pre><code>C:\Users\ユーザー名&gt;cd C:\Users\ユーザー名\Anaconda3
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install Pmw-2.0.1-py3-none-any.whl
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install numpy-1.19.5+mkl-cp38-cp38-win_amd64.whl
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install pymol-2.4.0-cp38-cp38-win_amd64.whl
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install pymol_launcher-2.1-cp38-cp38-win_amd64.whl
</code></pre>
<p>pymolのインストールはPmw, numpyの後にやりましょう。</p>
<p>以上でインストールが完了します。<code>C:\Users\ユーザー名\Anaconda3</code> の下に <code>PyMOL.exe</code> ができています。これをダブルクリックすればPyMOLが立ち上がります。</p>
<img src="append01/./image/windowspymol1.png">
<p>ドックにこのアイコンを登録しておけば簡単に開くことができます。</p>
<p>ところで、このインターフェイスはレガシーなTcl/Tkによる描画で、現在PyMOL側はこの表示を推奨していません。そこで、モダンなPyQt5を使った描画に変更します。これは簡単で</p>
<pre><code>C:\Users\ユーザー名&gt;cd C:\Users\ユーザー名\Anaconda3
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install pyqt5
</code></pre>
<p>を行うだけです。途中</p>
<img src="append01/./image/windows_inst2.png">
<p>エラーメッセージが出ることもありますが、最後にSuccessfully installedと書かれていれば問題ありません。</p>
<p>この設定をした後に改めてPyMOL.exeを開けば、インターフェイスが変化しています。</p>
<img src="append01/./image/windowspymol2.png">
<p>こちらの方が文字やボタンがきれいに表示されるので個人的に好きです。</p>
<h4 id="macosの場合"><a class="header" href="#macosの場合">macOSの場合</a></h4>
<p>以下の環境を想定しています。</p>
<h5 id="マシン環境"><a class="header" href="#マシン環境">マシン環境</a></h5>
<ul>
<li>macOS 11.1 (Big Sur), 2.8GHz Intel Core i7, メモリ16GB</li>
<li><a href="http://brew.sh/index_ja.html">ターミナルからHomebrewをインストール</a>してある</li>
<li><a href="http://xquartz.macosforge.org/landing/">Xquartzをインストール</a>してある</li>
</ul>
<p>また、Homebrewで入れたものを優先的に使うよう、<code>~/.bash_profile(or ~/.bashrc)</code>などの設定ファイルにHomebrewのパッケージの優先度を上げるための</p>
<pre><code>export PATH=&quot;/usr/local/bin:$PATH&quot;
</code></pre>
<p>を追記しておきます。</p>
<h5 id="概要"><a class="header" href="#概要">概要</a></h5>
<p>PyMOL 2以降では<strong>legacyで時代遅れなpython2がなくても動作するようになったようです</strong>。よって現行のPython 3.7のみで動作させることができるようです。またGUIインターフェースとしてこれまでtcl-tkを使っていたようでしたが、これもPyQt（ぱいきゅーと）5などのきれいなインタフェースを利用できるようになりました。ただし、相変わらずPyMOLはたくさんのプログラム依存の上に成り立っているため、少なくとも以下のプログラムをインストールしておく必要があります（PyMOL 2.3.0時点）。</p>
<ul>
<li>C++11 compiler (e.g. gcc 4.7+)</li>
<li>Python 2.7+</li>
<li>Pmw (Python Megawidgets) (optional, for legacy GUI/plugins)</li>
<li>OpenGL</li>
<li>GLEW</li>
<li>GLUT (freeglut) (optional, enable with --glut)</li>
<li>libpng</li>
<li>freetype</li>
<li>libxml2 (optional, for COLLADA export, disable with --no-libxml)</li>
<li>msgpack-c 2.1.5+ (optional, for fast MMTF loading and export,
disable with --use-msgpackc=no)</li>
<li>mmtf-cpp (for fast MMTF export, disable with --use-msgpackc=no)</li>
<li>PyQt5, PyQt4, PySide2 or PySide (optional, will fall back to Tk
interface if compiled with --glut)</li>
<li>glm</li>
<li>catch2 (optional, enable with --testing)</li>
</ul>
<p>を用意しておく必要があります。optionalとついているものは無くても動作しますが、今回はcatch2以外の全部を使用してインストールを試みます。mmtfというのはpdbの最新式バイナリ型PDBファイルで、ファイルサイズを非常に高効率で圧縮できるのが特徴です（ https://mmtf.rcsb.org/index.html ）。PyMOL 2.2からmmtf形式へのエクスポートにも対応したようです。興味がある方はこれも入れてインストールしてみましょう。</p>
<h4 id="homebrewで一発インストールする方法推奨"><a class="header" href="#homebrewで一発インストールする方法推奨">Homebrewで一発インストールする方法(推奨)</a></h4>
<p>アプリケーション &gt; ユーティリティ &gt; ターミナルを開き、<a href="http://brew.sh/index_ja.html">Homebrewをインストール</a>してあることが条件です。この状態で、ターミナルから、</p>
<pre><code class="language-bash">brew install pymol
</code></pre>
<p>と入力します。これで一発でインストールすることができます。終わったら、<strong>一度Command+Qキーでターミナルを完全に閉じてから</strong>、もう一度ターミナルを開いて</p>
<pre><code class="language-bash">pymol #または /usr/local/bin/pymol
</code></pre>
<p>でオープンソース版pymolが立ち上がります。このときターミナルにメッセージが流れるのが煩わしいと感じる場合は</p>
<pre><code class="language-bash">pymol &gt; /dev/null 2&gt;&amp;1 &amp;
</code></pre>
<p>で開くのも良いでしょう。</p>
<h4 id="centos-75の場合"><a class="header" href="#centos-75の場合">CentOS 7.5の場合</a></h4>
<h5 id="環境-1"><a class="header" href="#環境-1">環境</a></h5>
<ul>
<li>CentOS 7.5</li>
<li>sudo権限が使える場合</li>
</ul>
<h5 id="インストール方法-1"><a class="header" href="#インストール方法-1">インストール方法</a></h5>
<p>上のMacと似たような流れでインストールすることができます。また必要なパッケージのほとんどは管理者のyumを使ってシステムに直接インストールできるのでとても簡単です。rootでない管理者の場合はyumの前にsudoをつけて実行します。</p>
<pre><code class="language-bash">yum -y install epel-release
yum -y install gcc gcc-c++ python-devel tkinter glew-devel freeglut-devel \
libpng-devel freetype-devel libxml2-devel glm-devel msgpack
yum -y install python36u-pip
# pip3.6の場所の確認
which pip3.6
# 現在使用中のpython3環境にpip3.6で追加パッケージをインストールする
pip3.6 install --upgrade pip
pip3.6 install sip pyqt5 pmw
pip3.6 install msgpack-python msgpack-tool mmtf-python
# PyMOL 2.3のソースコードをダウンロードして、ビルド＆インストール
cd /path/to/pymol-open-source
# rm -rf build #インストールでエラーが出てしまった場合、再インストールを試す前にbuildディレクトリを消しておく
python3.6 setup.py build install --prefix=/path/to/pymol/2.3 --glut --use-msgpackc=c++11
</code></pre>
<p>だいたいこの流れでインストールができると思います。ただし、もしGTX 1080TiなどのNVIDIAグラフィックドライバを積んでいる場合にはそちらに切り替えたほうがPyMOLのGUI操作がサクサクになると思われますので、その設定もしておくと良いでしょう。
参考：<a href="https://qiita.com/inferist/items/770a88151d27fa117111">CentOS 7 上で PyMOL をソースからビルド</a></p>
<h4 id="ubuntu-1804の場合"><a class="header" href="#ubuntu-1804の場合">Ubuntu 18.04の場合</a></h4>
<h5 id="環境-2"><a class="header" href="#環境-2">環境</a></h5>
<ul>
<li>Ubuntu 18.04</li>
<li>sudo権限が使える場合</li>
</ul>
<h5 id="インストール方法-2"><a class="header" href="#インストール方法-2">インストール方法</a></h5>
<p><code>apt</code>を使ってパッケージをインストールした後、後はだいたいCentOS 7のときと流れは同じです。Python 3のバージョンは3.6、3.7どちらを使っても大丈夫です（下の例では3.6にしています）。</p>
<pre><code class="language-bash">sudo apt install freeglut3-dev python2.7-dev python3.6-dev \
libxml2-dev gcc tcl8.6-dev tk8.6-dev python3-tk \
libmsgpack-dev libpng-dev libglew2.0 libfreetype6-dev \
libglm-dev libglew-dev python-pyqt5.qtopengl
# python3.6に対応したpipのインストール
sudo apt install python3-pip
# 現在使用中のpython3環境にpip3で追加パッケージをインストールする
sudo pip3 install --upgrade pip
sudo pip3 install sip pyqt5 pmw
sudo pip3 install msgpack-python
# 新しい依存パッケージmmtf-cppを/usr/localにインストール https://github.com/rcsb/mmtf-cpp
sudo apt install ninja-build cmake
wget https://github.com/rcsb/mmtf-cpp/archive/v1.0.0.tar.gz
tar zxvf v1.0.0.tar.gz
cd v1.0.0
mkdir build ; cd build
cmake -G Ninja ..
sudo ninja install
# PyMOL 2.3のソースコードをダウンロードして、ビルド＆インストール
wget https://github.com/schrodinger/pymol-open-source/archive/v2.3.0.tar.gz
tar zxvf v2.3.0.tar.gz
cd pymol-open-source-2.3.0
# rm -rf build #インストールでエラーが出てしまった場合、再インストールを試す前にbuildディレクトリを消しておく
python3 setup.py build install --prefix=/path/to/pymol/2.3 --glut --use-msgpackc=c++11
</code></pre>
<h3 id="プラグインのインストール方法"><a class="header" href="#プラグインのインストール方法">プラグインのインストール方法</a></h3>
<h4 id="pymol-2からのプラグイン"><a class="header" href="#pymol-2からのプラグイン">PyMOL 2からのプラグイン</a></h4>
<p>バイナリ版PyMOL2.0に存在したプラグインはこちらのソースビルド版には初期状態で入っていません。しかし特にAPBS pluginなどは論文で使う研究者も多いはずです。macOSの場合、すでにこのバイナリ版PyMOLを持っているならば、<code>/Applications/PyMOL.app/Contents/share/pymol/data/startup/</code>にあったプラグインを<code>~/apps/pymol/2.3/lib/python3.7/site-packages/pymol/pymol_path/data/startup</code>に持ってくると使うことができます。</p>
<pre><code class="language-bash"># 手動インストールの場合はこっち
# cp -rp /Applications/PyMOL.app/Contents/share/pymol/data/startup/* /path/to/pymol/2.3/lib/python3.7/site-packages/pymol/pymol_path/data/startup
# homebrewでインストールした場合はこっち
cp -rp /Applications/PyMOL.app/Contents/share/pymol/data/startup/* /usr/local/Cellar/pymol/2.3.0/libexec/lib/python3.7/site-packages/pymol/pymol_path/data/startup/
</code></pre>
<p>APBSやPDB2PQRのプラグインへのPATHは各自設定してください。</p>
<h2 id="pymolの用語集"><a class="header" href="#pymolの用語集">PyMOLの用語集</a></h2>
<p>気づいたら書いていきます。</p>
<h3 id="オブジェクト-object"><a class="header" href="#オブジェクト-object">オブジェクト (object)</a></h3>
<p>PyMOL上の<strong>オブジェクト</strong>とは、PyMOL上に表示された構造ファイル、または選択範囲のことです。特に、PyMOLの右側のメニューはオブジェクトを操作する<strong>オブジェクトパネル</strong>と呼ばれます。</p>
<img src="append01/../ch02/image/viewer/objectpanel1.png">
<p>PyMOLでは構造情報だけでなく、選択範囲についてもオブジェクトのように扱うことができ、<code>(sele)</code>として表示されます。この他にも()で示されるオブジェクトが登場することがありますが、それらは選択範囲のオブジェクトであり、構造情報のオブジェクトとは区別されます。</p>
<img src="append01/../ch02/image/viewer/objectpanel2.png">
<h3 id="セグメントsegment-identifier"><a class="header" href="#セグメントsegment-identifier">セグメント（segment identifier）</a></h3>
<p><strong>セグメント</strong>とは、構造ファイルの中のsegment identifier(segment ID)に登録されている情報のことです。かつて<code>.pdb</code>ファイル形式が主流だった頃、segment identifierは原子の座標を記述する<code>ATOM</code>, <code>HETATM</code>レコードの中の73〜76行目に記述するようになっていました。特に、同一chain IDにありながらある種の原子のグループごとに分けて記述したい場合（例：共有結合しているタンパク質とリガンドを分けたい時）に用いられましたが、今はChain IDで分けるのが主流となっています。segment identifierは現在廃止された仕様ですが、PyMOLやChimera, CHARMMなど一部のプログラムは未だにこれを利用することができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="インストール方法-3"><a class="header" href="#インストール方法-3">インストール方法</a></h2>
<p>大きく分けて、<strong>公式ウェブサイトで配布されているバイナリを入れる方法</strong>（バイナリ版）と、<strong>自身でPyMOLをソースコードからビルド＆コンパイルし、インストールする方法</strong>（オープンソース版）の2通りがあります。初心者に対しては確実に前者の方をおすすめしますが、<strong>ライセンス認証を求められる</strong>（一応無視しても使えるが少し煩わしい）というデメリットがあり、反対に後者のやり方では、ライセンス認証は求められないものの、インストールがやや難しく、玄人向けと言えます。</p>
<table><thead><tr><th align="left"></th><th align="center">バイナリ版</th><th align="center">オープンソース版</th></tr></thead><tbody>
<tr><td align="left">メリット</td><td align="center"><strong>インストールがとても簡単</strong><br>APBSを始めとした、いくつかのプラグインがプリインストールされている</td><td align="center"><strong>ライセンス認証が不要</strong></td></tr>
<tr><td align="left">デメリット</td><td align="center"><strong>起動時にライセンス認証を求められる</strong></td><td align="center"><strong>インストールが煩雑</strong><br>プラグインが同梱されていない（手動で追加インストールすることが求められる）</td></tr>
<tr><td align="left">備考</td><td align="center">有料ライセンスならば、専用の追加機能を利用できる（特にSchrödinger Maestroとの連携）</td><td align="center"></td></tr>
</tbody></table>
<p>PyMOLライセンスは基本的に有料で、1年または3年契約なのですが、教育用のサブスクリプション(Educational Subscription)ライセンスは、ウェブ上で申請することで<strong>無料</strong>で発行されます。いずれのライセンスを取得する場合でも、まずhttps://pymol.org/2/buy.html にアクセスし、申請フォームを埋めることでライセンス発行の手続きを進めることができます。</p>
<h3 id="バイナリ版のインストール方法-1"><a class="header" href="#バイナリ版のインストール方法-1">バイナリ版のインストール方法</a></h3>
<p>バイナリ版のインストール方法はとても簡単で、<a href="https://pymol.org/2/">公式ウェブサイト</a>のDownloadのところからインストーラーを取得することができます。Windows, macOS, Linuxいずれの場合も、基本的にはインストーラーを展開して指示に従ってインストールを進めるだけでOKのはずです。</p>
<h3 id="オープンソース版のインストール方法-1"><a class="header" href="#オープンソース版のインストール方法-1">オープンソース版のインストール方法</a></h3>
<p>オープンソース版のインストール方法は、OSの種類によって大きく異なります。</p>
<h4 id="windows-10の場合-3"><a class="header" href="#windows-10の場合-3">Windows 10の場合</a></h4>
<p>tonets先生のQiita記事 https://qiita.com/tonets/items/1927058e4297fc1c060d をアップデートする形で書きます。</p>
<p>WindowsではまずPython3が使える環境を構築する必要があります。これには様々な流儀がありますが、Anacondaを使う流儀で紹介します。</p>
<p>まずAnacondaを使ってPythonをインストールします。このときのバージョンはPython3.8です。</p>
<p>https://www.anaconda.com/products/individual</p>
<p>インストーラーをダウンロードしてきたら基本的にはデフォルトのままNextを押していきます。個人（only me）にインストールするか、システム全体にインストールするかを聞かれるところがありますが、ここでは個人を選択しておきます。</p>
<p>インストールされた場所を確認します。おそらく<code>C:\Users\ユーザー名\Anaconda3\</code>に <code>python.exe</code>があります。</p>
<p>コマンドプロンプトを立ち上げて（ショートカットキーWin+Rを押したあと、<code>cmd</code>と入力すると早い、もしかすると管理者権限が必要かも）、<code>cd C:\Users\ユーザー名\Anaconda3</code>としてAnaconda3のディレクトリに移動した後</p>
<pre><code>python.exe -m pip install --upgrade pip
</code></pre>
<p>として、<code>pip</code>をアップグレードする処理が働くかどうかを確認します。</p>
<p>ここでもし</p>
<pre><code>pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available.
</code></pre>
<p>というエラーが出る場合、OpenSSLの設定がうまくできていないみたいなので、以下のような回避策を行います。</p>
<p>Windowsのスタートボタンにある検索メニューに<strong>環境変数名の編集</strong>と入力し、環境変数の変数を行います。ここではPathの部分をダブルクリックし、画像のように環境変数名を編集して追加します。</p>
<img src="append01/./image/windows_inst1.png">
<p>一番下の設定は、私の環境では<code>Anaconda3\pkgs\openssl-1.1.1h-he774522_0\Library\bin</code>でしたが、Anacondaのバージョンによって微妙にopensslのディレクトリ名が変わるので、適宜確認してから入力してください。</p>
<p>この環境変数を追記したら、改めてコマンドプロンプトをいったん閉じて開き直し、<code>pip</code>のアップグレードがうまく行われることを確認してください。</p>
<p>うまくアップグレードされたようでしたら、次にPyMOLのビルドに必要なパッケージをダウンロードしインストールします。必要なファイルは https://www.lfd.uci.edu/~gohlke/pythonlibs/ の<strong>Pymol-open-source</strong>にある</p>
<ul>
<li>pymol_launcher-2.1-cp38-cp38-win_amd64.whl</li>
<li>pymol-2.4.0-cp38-cp38-win_amd64.whl</li>
<li>Pmw-2.0.1-py3-none-any.whl</li>
</ul>
<p>と、<strong>NumPy</strong>のところにある</p>
<ul>
<li>numpy-1.19.5+mkl-cp38-cp38-win_amd64.whl</li>
</ul>
<p>です。注意点として、<code>cpXX</code>の数字は必ずAnacondaのPythonバージョンと合わせてください。例えばAnacondaのPythonバージョンがPython 3.8.xならば、<code>cp38</code>を選びます。時間が経つに連れ、バージョンがともにアップデートされていきますので、それに合わせます。また、<code>win32</code>と<code>win_amd64</code>がありますが、これは今の時代でしたら基本的には<code>win_amd64</code>の方を使います。<code>win32</code>はたぶんそのうち絶滅します。また、現在<code>pymol-2.5.0a0</code>も存在していますが、基本的に<code>a0</code>は未完成の試作品なので、安定動作を取りたい人は手を出さないほうが良いでしょう。</p>
<p>これらを揃えたら、先程の<code>Anaconda3</code>の<code>python.exe</code>があったディレクトリに入れておきます。そしてコマンドプロンプトを開き、以下の順でインストールを行います。</p>
<pre><code>C:\Users\ユーザー名&gt;cd C:\Users\ユーザー名\Anaconda3
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install Pmw-2.0.1-py3-none-any.whl
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install numpy-1.19.5+mkl-cp38-cp38-win_amd64.whl
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install pymol-2.4.0-cp38-cp38-win_amd64.whl
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install pymol_launcher-2.1-cp38-cp38-win_amd64.whl
</code></pre>
<p>pymolのインストールはPmw, numpyの後にやりましょう。</p>
<p>以上でインストールが完了します。<code>C:\Users\ユーザー名\Anaconda3</code> の下に <code>PyMOL.exe</code> ができています。これをダブルクリックすればPyMOLが立ち上がります。</p>
<img src="append01/./image/windowspymol1.png">
<p>ドックにこのアイコンを登録しておけば簡単に開くことができます。</p>
<p>ところで、このインターフェイスはレガシーなTcl/Tkによる描画で、現在PyMOL側はこの表示を推奨していません。そこで、モダンなPyQt5を使った描画に変更します。これは簡単で</p>
<pre><code>C:\Users\ユーザー名&gt;cd C:\Users\ユーザー名\Anaconda3
C:\Users\ユーザー名\Anaconda3&gt; python.exe -m pip install pyqt5
</code></pre>
<p>を行うだけです。途中</p>
<img src="append01/./image/windows_inst2.png">
<p>エラーメッセージが出ることもありますが、最後にSuccessfully installedと書かれていれば問題ありません。</p>
<p>この設定をした後に改めてPyMOL.exeを開けば、インターフェイスが変化しています。</p>
<img src="append01/./image/windowspymol2.png">
<p>こちらの方が文字やボタンがきれいに表示されるので個人的に好きです。</p>
<h4 id="macosの場合-1"><a class="header" href="#macosの場合-1">macOSの場合</a></h4>
<p>以下の環境を想定しています。</p>
<h5 id="マシン環境-1"><a class="header" href="#マシン環境-1">マシン環境</a></h5>
<ul>
<li>macOS 11.1 (Big Sur), 2.8GHz Intel Core i7, メモリ16GB</li>
<li><a href="http://brew.sh/index_ja.html">ターミナルからHomebrewをインストール</a>してある</li>
<li><a href="http://xquartz.macosforge.org/landing/">Xquartzをインストール</a>してある</li>
</ul>
<p>また、Homebrewで入れたものを優先的に使うよう、<code>~/.bash_profile(or ~/.bashrc)</code>などの設定ファイルにHomebrewのパッケージの優先度を上げるための</p>
<pre><code>export PATH=&quot;/usr/local/bin:$PATH&quot;
</code></pre>
<p>を追記しておきます。</p>
<h5 id="概要-1"><a class="header" href="#概要-1">概要</a></h5>
<p>PyMOL 2以降では<strong>legacyで時代遅れなpython2がなくても動作するようになったようです</strong>。よって現行のPython 3.7のみで動作させることができるようです。またGUIインターフェースとしてこれまでtcl-tkを使っていたようでしたが、これもPyQt（ぱいきゅーと）5などのきれいなインタフェースを利用できるようになりました。ただし、相変わらずPyMOLはたくさんのプログラム依存の上に成り立っているため、少なくとも以下のプログラムをインストールしておく必要があります（PyMOL 2.3.0時点）。</p>
<ul>
<li>C++11 compiler (e.g. gcc 4.7+)</li>
<li>Python 2.7+</li>
<li>Pmw (Python Megawidgets) (optional, for legacy GUI/plugins)</li>
<li>OpenGL</li>
<li>GLEW</li>
<li>GLUT (freeglut) (optional, enable with --glut)</li>
<li>libpng</li>
<li>freetype</li>
<li>libxml2 (optional, for COLLADA export, disable with --no-libxml)</li>
<li>msgpack-c 2.1.5+ (optional, for fast MMTF loading and export,
disable with --use-msgpackc=no)</li>
<li>mmtf-cpp (for fast MMTF export, disable with --use-msgpackc=no)</li>
<li>PyQt5, PyQt4, PySide2 or PySide (optional, will fall back to Tk
interface if compiled with --glut)</li>
<li>glm</li>
<li>catch2 (optional, enable with --testing)</li>
</ul>
<p>を用意しておく必要があります。optionalとついているものは無くても動作しますが、今回はcatch2以外の全部を使用してインストールを試みます。mmtfというのはpdbの最新式バイナリ型PDBファイルで、ファイルサイズを非常に高効率で圧縮できるのが特徴です（ https://mmtf.rcsb.org/index.html ）。PyMOL 2.2からmmtf形式へのエクスポートにも対応したようです。興味がある方はこれも入れてインストールしてみましょう。</p>
<h4 id="homebrewで一発インストールする方法推奨-1"><a class="header" href="#homebrewで一発インストールする方法推奨-1">Homebrewで一発インストールする方法(推奨)</a></h4>
<p>アプリケーション &gt; ユーティリティ &gt; ターミナルを開き、<a href="http://brew.sh/index_ja.html">Homebrewをインストール</a>してあることが条件です。この状態で、ターミナルから、</p>
<pre><code class="language-bash">brew install pymol
</code></pre>
<p>と入力します。これで一発でインストールすることができます。終わったら、<strong>一度Command+Qキーでターミナルを完全に閉じてから</strong>、もう一度ターミナルを開いて</p>
<pre><code class="language-bash">pymol #または /usr/local/bin/pymol
</code></pre>
<p>でオープンソース版pymolが立ち上がります。このときターミナルにメッセージが流れるのが煩わしいと感じる場合は</p>
<pre><code class="language-bash">pymol &gt; /dev/null 2&gt;&amp;1 &amp;
</code></pre>
<p>で開くのも良いでしょう。</p>
<h4 id="centos-75の場合-1"><a class="header" href="#centos-75の場合-1">CentOS 7.5の場合</a></h4>
<h5 id="環境-3"><a class="header" href="#環境-3">環境</a></h5>
<ul>
<li>CentOS 7.5</li>
<li>sudo権限が使える場合</li>
</ul>
<h5 id="インストール方法-4"><a class="header" href="#インストール方法-4">インストール方法</a></h5>
<p>上のMacと似たような流れでインストールすることができます。また必要なパッケージのほとんどは管理者のyumを使ってシステムに直接インストールできるのでとても簡単です。rootでない管理者の場合はyumの前にsudoをつけて実行します。</p>
<pre><code class="language-bash">yum -y install epel-release
yum -y install gcc gcc-c++ python-devel tkinter glew-devel freeglut-devel \
libpng-devel freetype-devel libxml2-devel glm-devel msgpack
yum -y install python36u-pip
# pip3.6の場所の確認
which pip3.6
# 現在使用中のpython3環境にpip3.6で追加パッケージをインストールする
pip3.6 install --upgrade pip
pip3.6 install sip pyqt5 pmw
pip3.6 install msgpack-python msgpack-tool mmtf-python
# PyMOL 2.3のソースコードをダウンロードして、ビルド＆インストール
cd /path/to/pymol-open-source
# rm -rf build #インストールでエラーが出てしまった場合、再インストールを試す前にbuildディレクトリを消しておく
python3.6 setup.py build install --prefix=/path/to/pymol/2.3 --glut --use-msgpackc=c++11
</code></pre>
<p>だいたいこの流れでインストールができると思います。ただし、もしGTX 1080TiなどのNVIDIAグラフィックドライバを積んでいる場合にはそちらに切り替えたほうがPyMOLのGUI操作がサクサクになると思われますので、その設定もしておくと良いでしょう。
参考：<a href="https://qiita.com/inferist/items/770a88151d27fa117111">CentOS 7 上で PyMOL をソースからビルド</a></p>
<h4 id="ubuntu-1804の場合-1"><a class="header" href="#ubuntu-1804の場合-1">Ubuntu 18.04の場合</a></h4>
<h5 id="環境-4"><a class="header" href="#環境-4">環境</a></h5>
<ul>
<li>Ubuntu 18.04</li>
<li>sudo権限が使える場合</li>
</ul>
<h5 id="インストール方法-5"><a class="header" href="#インストール方法-5">インストール方法</a></h5>
<p><code>apt</code>を使ってパッケージをインストールした後、後はだいたいCentOS 7のときと流れは同じです。Python 3のバージョンは3.6、3.7どちらを使っても大丈夫です（下の例では3.6にしています）。</p>
<pre><code class="language-bash">sudo apt install freeglut3-dev python2.7-dev python3.6-dev \
libxml2-dev gcc tcl8.6-dev tk8.6-dev python3-tk \
libmsgpack-dev libpng-dev libglew2.0 libfreetype6-dev \
libglm-dev libglew-dev python-pyqt5.qtopengl
# python3.6に対応したpipのインストール
sudo apt install python3-pip
# 現在使用中のpython3環境にpip3で追加パッケージをインストールする
sudo pip3 install --upgrade pip
sudo pip3 install sip pyqt5 pmw
sudo pip3 install msgpack-python
# 新しい依存パッケージmmtf-cppを/usr/localにインストール https://github.com/rcsb/mmtf-cpp
sudo apt install ninja-build cmake
wget https://github.com/rcsb/mmtf-cpp/archive/v1.0.0.tar.gz
tar zxvf v1.0.0.tar.gz
cd v1.0.0
mkdir build ; cd build
cmake -G Ninja ..
sudo ninja install
# PyMOL 2.3のソースコードをダウンロードして、ビルド＆インストール
wget https://github.com/schrodinger/pymol-open-source/archive/v2.3.0.tar.gz
tar zxvf v2.3.0.tar.gz
cd pymol-open-source-2.3.0
# rm -rf build #インストールでエラーが出てしまった場合、再インストールを試す前にbuildディレクトリを消しておく
python3 setup.py build install --prefix=/path/to/pymol/2.3 --glut --use-msgpackc=c++11
</code></pre>
<h3 id="プラグインのインストール方法-1"><a class="header" href="#プラグインのインストール方法-1">プラグインのインストール方法</a></h3>
<h4 id="pymol-2からのプラグイン-1"><a class="header" href="#pymol-2からのプラグイン-1">PyMOL 2からのプラグイン</a></h4>
<p>バイナリ版PyMOL2.0に存在したプラグインはこちらのソースビルド版には初期状態で入っていません。しかし特にAPBS pluginなどは論文で使う研究者も多いはずです。macOSの場合、すでにこのバイナリ版PyMOLを持っているならば、<code>/Applications/PyMOL.app/Contents/share/pymol/data/startup/</code>にあったプラグインを<code>~/apps/pymol/2.3/lib/python3.7/site-packages/pymol/pymol_path/data/startup</code>に持ってくると使うことができます。</p>
<pre><code class="language-bash"># 手動インストールの場合はこっち
# cp -rp /Applications/PyMOL.app/Contents/share/pymol/data/startup/* /path/to/pymol/2.3/lib/python3.7/site-packages/pymol/pymol_path/data/startup
# homebrewでインストールした場合はこっち
cp -rp /Applications/PyMOL.app/Contents/share/pymol/data/startup/* /usr/local/Cellar/pymol/2.3.0/libexec/lib/python3.7/site-packages/pymol/pymol_path/data/startup/
</code></pre>
<p>APBSやPDB2PQRのプラグインへのPATHは各自設定してください。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="pymolの用語集-1"><a class="header" href="#pymolの用語集-1">PyMOLの用語集</a></h2>
<p>気づいたら書いていきます。</p>
<h3 id="オブジェクト-object-1"><a class="header" href="#オブジェクト-object-1">オブジェクト (object)</a></h3>
<p>PyMOL上の<strong>オブジェクト</strong>とは、PyMOL上に表示された構造ファイル、または選択範囲のことです。特に、PyMOLの右側のメニューはオブジェクトを操作する<strong>オブジェクトパネル</strong>と呼ばれます。</p>
<img src="append01/../ch02/image/viewer/objectpanel1.png">
<p>PyMOLでは構造情報だけでなく、選択範囲についてもオブジェクトのように扱うことができ、<code>(sele)</code>として表示されます。この他にも()で示されるオブジェクトが登場することがありますが、それらは選択範囲のオブジェクトであり、構造情報のオブジェクトとは区別されます。</p>
<img src="append01/../ch02/image/viewer/objectpanel2.png">
<h3 id="セグメントsegment-identifier-1"><a class="header" href="#セグメントsegment-identifier-1">セグメント（segment identifier）</a></h3>
<p><strong>セグメント</strong>とは、構造ファイルの中のsegment identifier(segment ID)に登録されている情報のことです。かつて<code>.pdb</code>ファイル形式が主流だった頃、segment identifierは原子の座標を記述する<code>ATOM</code>, <code>HETATM</code>レコードの中の73〜76行目に記述するようになっていました。特に、同一chain IDにありながらある種の原子のグループごとに分けて記述したい場合（例：共有結合しているタンパク質とリガンドを分けたい時）に用いられましたが、今はChain IDで分けるのが主流となっています。segment identifierは現在廃止された仕様ですが、PyMOLやChimera, CHARMMなど一部のプログラムは未だにこれを利用することができます。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="選択範囲の文法と演算子"><a class="header" href="#選択範囲の文法と演算子">選択範囲の文法と演算子</a></h2>
<p><a href="https://pymolwiki.org/index.php/Selection_Algebra">https://pymolwiki.org/index.php/Selection_Algebra</a> からの和訳です。</p>
<p>PyMOLのSelection文法を使うことで識別子（identifier）やプロパティに基づいてPyMOL内に表示されている原子を選択することができます。多くのPyMOLコマンド (<code>color</code>, <code>show</code> など) では、存在する原子の一部に対してのみ操作を適用するために、原子選択の引数を与えることが可能です。例えば</p>
<p><code>PyMOL&gt;show spheres, solvent and chain A</code></p>
<p>これによって、「chain Aかつ溶媒のみ」（<code>solvent and chain A</code>）を「sphere表示にする(<code>show spheres</code>)」という操作を与えることができます。</p>
<p>Selectionは、論理演算子（<code>true/false</code>のブール型変数、<code>and</code>, <code>or</code>, <code>and not</code>など)と組み合わせることで、より精密に包括的に行うことができます。ブール型の<code>and</code>は指定されたプロパティの両方（またはすべて）を持つ項目のみを選択し、<code>or</code>はそれらのどちらか（またはいずれか）を持つ項目を選択します。</p>
<h3 id="選択演算子修飾子テーブル"><a class="header" href="#選択演算子修飾子テーブル">選択演算子/修飾子テーブル</a></h3>
<p>選択演算子と修飾子を以下に示します。ダミー変数<code>s1</code>と<code>s2</code>は, <code>chain a</code>や<code>hydro.</code>といった選択式を表します。</p>
<table><thead><tr><th> 選択演算子 </th><th> エイリアス </th><th> 説明 </th></tr></thead><tbody>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" >全般</td></tr>
<tr><td> <code>all</code> </td><td> <code>*</code> </td><td> PyMOLに現在ロードされているすべての原子 </td></tr>
<tr><td> <code>none</code> </td><td> </td><td> 空のselectionを生成 </td></tr>
<tr><td> <code>enabled</code> </td><td> </td><td> 有効化されたオブジェクトの原子 </td></tr>
<tr><td> Named selections </td><td> </td><td> </td></tr>
<tr><td> <span style="color: #999">sele</span> </td><td> </td><td> 名前付きの選択範囲またはオブジェクト &quot;sele&quot;、ただし他の演算子の名前と競合しない場合に限る </td></tr>
<tr><td> %<span style="color: #999">sele</span> </td><td> </td><td> 名前付き選択範囲またはオブジェクト&quot;sele&quot; <br><span style="padding: 1px 4px; background-color: #fc3; border: 1px solid #ccc">曖昧さを避けるために推奨</span> </td></tr>
<tr><td> ?<span style="color: #999">sele</span> </td><td> </td><td> 名前付き選択範囲またはオブジェクト &quot;sele&quot;, ただし、名前付き選択範囲またはオブジェクト &quot;sele&quot; が存在しない場合は空の選択範囲になります </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" >論理式</td></tr>
<tr><td> not <span style="color: #999">S1</span> </td><td> <code>!</code> </td><td> 選択範囲を反転させます。 </td></tr>
<tr><td> <span style="color: #999">S1</span> and <span style="color: #999">S2</span> </td><td> <code>&amp;</code> </td><td> プロパティS1とS2の両方に含まれる原子 </td></tr>
<tr><td> <span style="color: #999">S1</span> or <span style="color: #999">S2</span> </td><td> |</td><td> プロパティS1またはS2のいずれかに含まれる原子 </td></tr>
<tr><td> <span style="color: #999">S1 S2</span> </td><td> </td><td> 暗黙的に上記の<strong>or</strong>を指定します </td></tr>
<tr><td> <span style="color: #999">S1</span> and (<span style="color: #999">S2</span> or <span style="color: #999">S3</span>) </td><td> </td><td> （）を使うことで評価順を制御できます </td></tr>
<tr><td> first <span style="color: #999">S1</span> </td><td> </td><td> プロパティS1を持つ最初の原子（1原子のみ選択） </td></tr>
<tr><td> last <span style="color: #999">S1</span> </td><td> </td><td> プロパティS1を持つ最後の原子（1原子のみ選択） </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" >識別子（Identifier）</td></tr>
<tr><td> model <span style="color: #999">1ubq</span> </td><td> <code>m.</code> </td><td> オブジェクト&quot;1ubq&quot;由来の原子 </td></tr>
<tr><td> chain <span style="color: #999">C</span> </td><td> <code>c.</code> </td><td> チェイン識別子&quot;C&quot;由来の原子 </td></tr>
<tr><td> segi <span style="color: #999">S</span> </td><td> <code>s.</code> </td><td> セグメント識別子&quot;S&quot;由来の原子 (mmCIF形式の場合は<strong>label_asym_id</strong>を基準に判定します) </td></tr>
<tr><td> resn <span style="color: #999">ALA</span> </td><td> <code>r.</code> </td><td> 残基名が &quot;ALA&quot;である原子 </td></tr>
<tr><td> resi <span style="color: #999">100-200</span> </td><td> <code>i.</code> </td><td> 残基番号が100から200の間になっている残基の原子 </td></tr>
<tr><td> name <span style="color: #999">CA</span> </td><td> <code>n.</code> </td><td> 原子名が &quot;CA&quot; となっている原子 </td></tr>
<tr><td> alt <span style="color: #999">A</span> </td><td> </td><td> Alternate locationが &quot;A&quot;である原子 </td></tr>
<tr><td> index <span style="color: #999">123</span> </td><td> idx. </td><td> PyMOL内部のオブジェクト内原子インデックスが123に該当する原子 (<code>sort</code>で変更可能) </td></tr>
<tr><td> id <span style="color: #999">123</span> </td><td> </td><td> PDBファイル内のIDカラムの数字が123の原子 </td></tr>
<tr><td> rank <span style="color: #999">123</span> </td><td> </td><td> ロード時のオブジェクトごとの原子インデックスが123に該当する原子 (retain_orderを参照) </td></tr>
<tr><td> pepseq <span style="color: #999">ACDEF</span> </td><td> ps. </td><td> アミノ酸の一文字表記で&quot;ACDEF&quot;となっている部分の配列を選択 (FindSeqも参照) </td></tr>
<tr><td> label <span style="color: #999">&quot;Hello World&quot;</span> </td><td> </td><td> &quot;Hello World&quot;とラベルされている原子 <em>(PyMOL 1.9から実装)</em> </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" >識別子のマッチング</td></tr>
<tr><td> <span style="color: #999">S1</span> in <span style="color: #999">S2</span> </td><td> </td><td> S1 の原子のうち，name, resi, resn, chain, segi がすべて S2 の原子と一致する原子 </td></tr>
<tr><td> <span style="color: #999">S1</span> like <span style="color: #999">S2</span> </td><td> </td><td> S1の原子で、名前とresiの識別子がS2の原子と一致するもの</td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" >エンティティ（Entity）の拡張</td></tr>
<tr><td colspan="3"><b>重要：&quot;by-&quot;演算子の優先順位は弱いため、<code>(byres S1 or S2)</code>は実際には<code>(byres (S1 or S2)</code>と同じであり、<code>((byres S1) or S2)</code>と同じではありません。) </b></td></tr>
<tr><td> byobject <span style="color: #999">S1</span> </td><td> </td><td> S1の範囲を拡張してオブジェクト単位で選択します </td></tr>
<tr><td> bysegi <span style="color: #999">S1</span> </td><td> <code>bs.</code> </td><td> S1の範囲を拡張してセグメント単位で選択します </td></tr>
<tr><td> bychain <span style="color: #999">S1</span> </td><td> <code>bc.</code> </td><td> S1の範囲を拡張してチェイン単位で選択します </td></tr>
<tr><td> byres <span style="color: #999">S1</span> </td><td> <code>br.</code> </td><td> S1の範囲を拡張して残基単位で選択します </td></tr>
<tr><td> bycalpha <span style="color: #999">S1</span> </td><td> <code>bca.</code> </td><td> S1に少なくとも1個の原子を有する残基のCα原子 </td></tr>
<tr><td> bymolecule <span style="color: #999">S1</span> </td><td> <code>bm.</code> </td><td> S1の範囲を拡張して分子単位で選択します。bondで結合されている範囲を「分子」とみなします </td></tr>
<tr><td> byfragment <span style="color: #999">S1</span> </td><td> <code>bf.</code> </td><td> </td></tr>
<tr><td> byring <span style="color: #999">S1</span> </td><td> </td><td> S1に少なくとも1つの原子を有するサイズ7以下のすべての環 <em>(PyMOL 1.8.2で実装)</em> </td></tr>
<tr><td> bycell <span style="color: #999">S1</span> </td><td> </td><td> 選択範囲をunit cellに拡張する </td></tr>
<tr><td> Bond expansion </td><td> </td><td> </td></tr>
<tr><td> bound_to <span style="color: #999">S1</span> </td><td> bto. </td><td> S1に直接結合している原子(S1を含む) </td></tr>
<tr><td> neighbor <span style="color: #999">S1</span> </td><td> nbr. </td><td> S1に直接結合している原子(S1は含まない) </td></tr>
<tr><td> <span style="color: #999">S1</span> extend <span style="color: #999">3</span> </td><td> xt. </td><td> S1の範囲をS1に結合している原子から3結合分だけ広げる </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" > 距離基準 (Proximity) </td></tr>
<tr><td> <span style="color: #999">S1</span> within <span style="color: #999">12.3</span> of <span style="color: #999">S2</span> </td><td> w. </td><td> S2中の任意の原子から12.3 Å以内に存在するS1の原子 </td></tr>
<tr><td> <span style="color: #999">S1</span> around <span style="color: #999">12.3</span> </td><td> a. </td><td> S1の全原子の中心から12.3 Å以内の中心を持つ原子 </td></tr>
<tr><td> <span style="color: #999">S1</span> expand <span style="color: #999">12.3</span> </td><td> x. </td><td> S1の全原子の中心から12.3 Å以内の原子にまでS1範囲を拡張 </td></tr>
<tr><td> <span style="color: #999">S1</span> gap <span style="color: #999">1.2</span> </td><td> </td><td> VDW半径がS1のVDW半径から1.2 Å以上離れている原子</td></tr>
<tr><td> <span style="color: #999">S1</span> near_to <span style="color: #999">12.3</span> of <span style="color: #999">S2</span> </td><td> nto. </td><td> <em>within</em>と同じだが、S2は選択範囲から外れる (なので<code>S1 and S2 around 12.3</code>に同じ) </td></tr>
<tr><td> <span style="color: #999">S1</span> beyond <span style="color: #999">12.3</span> of <span style="color: #999">S2</span> </td><td> be. </td><td> S2から12.3 Å以上離れているS1の原子 </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" > 属性基準 (Properties) </td></tr>
<tr><td> partial_charge <span style="color: #999">&lt; 1.2</span> </td><td> pc. </td><td>（部分電荷のパラメータがロードした構造データに含まれている場合のみ）partial_chargeの値が1.2以下の原子</td></tr>
<tr><td> formal_charge <span style="color: #999">= 1</span> </td><td> fc. </td><td> </td></tr>
<tr><td> b <span style="color: #999">&lt; 100.0</span> </td><td> </td><td> B-factoが100.0より小さい原子 </td></tr>
<tr><td> q <span style="color: #999">&lt; 1.0</span> </td><td> </td><td> Occupancyが1.0より小さい原子 </td></tr>
<tr><td> ss <span style="color: #999">H+S</span> </td><td> </td><td> 二次構造がH (helix)またはS (sheet)となっている原子 </td></tr>
<tr><td> elem <span style="color: #999">C</span> </td><td> e. </td><td> 原子種がC (炭素)の原子 </td></tr>
<tr><td> p<span style="color: #999">.foo</span> = <span style="color: #999">12</span> </td><td> </td><td> </td></tr>
<tr><td> p<span style="color: #999">.foo</span> &lt; <span style="color: #999">12.3</span> </td><td> </td><td> </td></tr>
<tr><td> p<span style="color: #999">.foo</span> in <span style="color: #999">12+34</span> </td><td> </td><td> </td></tr>
<tr><td> stereo <span style="color: #999">R</span> </td><td> </td><td> キラル化合物でR/S不斉中心のうちRという情報が入っている原子<em>(<a href="https://pymol.org/d/media:stereochemistry">Incentive PyMOL 1.4-1.8</a>のみ)</em> </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" > Flags </td></tr>
<tr><td> bonded </td><td> </td><td> 1つ以上の結合を持つ原子 </td></tr>
<tr><td> protected </td><td> </td><td>  </td></tr>
<tr><td> fixed </td><td> fxd. </td><td>  </td></tr>
<tr><td> restrained </td><td> rst. </td><td>  </td></tr>
<tr><td> masked </td><td> msk. </td><td>  </td></tr>
<tr><td> flag <span style="color: #999">25</span> </td><td> f. </td><td>  </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" > 化学的な分類基準（chemical class） </td></tr>
<tr><td> organic </td><td> org. </td><td> ポリマー（タンパク質または核酸）でない有機化合物(例： リガンドや緩衝液) </td></tr>
<tr><td> inorganic </td><td> ino. </td><td> ポリマーでない無機化合物・イオン </td></tr>
<tr><td> solvent </td><td> sol. </td><td> 水分子 </td></tr>
<tr><td> polymer </td><td> pol. </td><td> ポリマー、タンパク質または核酸 </td></tr>
<tr><td> polymer.protein </td><td> </td><td> タンパク質 <em>(New in PyMOL 2.1)</em> </td></tr>
<tr><td> polymer.nucleic </td><td> </td><td> 核酸 <em>(New in PyMOL 2.1)</em> </td></tr>
<tr><td> guide </td><td> </td><td> タンパク質のCAと核酸のC4*/C4' </td></tr>
<tr><td> hetatm </td><td> </td><td> PDBのHETATMレコードに入っている原子 </td></tr>
<tr><td> hydrogens </td><td> h. </td><td> 水素原子 </td></tr>
<tr><td> backbone </td><td> bb. </td><td> ポリマーの主鎖・バックボーン原子 <em>(new in PyMOL 1.6.1)</em> </td></tr>
<tr><td> sidechain </td><td> sc. </td><td> ポリマーの側鎖原子 <em>(new in PyMOL 1.6.1)</em> </td></tr>
<tr><td> metals </td><td> </td><td> 金属原子 <em>(new in PyMOL 1.6.1)</em> </td></tr>
<tr><td> donors </td><td> don. </td><td> 水素結合でドナーとなる原子 </td></tr>
<tr><td> acceptors </td><td> acc. </td><td> 水素結合でアクセプターとなる原子 </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" > 表示形式基準（Style） </td></tr>
<tr><td> visible </td><td> v. </td><td> 何らかの表示形式で表示されているenabled状態のオブジェクトに含まれる原子</td></tr>
<tr><td> rep <span style="color: #999">cartoon</span> </td><td> </td><td> Cartoon表示となっている原子 </td></tr>
<tr><td> color <span style="color: #999">blue</span> </td><td> </td><td> 原子のカラーリングが (color indexで)blueになっている原子 </td></tr>
<tr><td> cartoon_color <span style="color: #999">blue</span> </td><td> </td><td> Atoms with atom-level cartoon_color setting (by color index) </td></tr>
<tr><td> ribbon_color <span style="color: #999">blue</span> </td><td> </td><td> Atoms with atom-level ribbon_color setting (by color index) </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" > 非分子（Non molecular） </td></tr>
<tr><td> center </td><td> </td><td> sceneの中央においてある仮想の原子 </td></tr>
<tr><td> origin </td><td> </td><td> 回転中心においてある仮想の原子 </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" > 座標基準 (Coordinates) </td></tr>
<tr><td> state <span style="color: #999">123</span> </td><td> </td><td> Atoms with coordinates in state 123 </td></tr>
<tr><td> present </td><td> pr. </td><td> Atoms with coordinates in the current state </td></tr>
<tr><td> x <span style="color: #999">&lt; 12.3</span> </td><td> </td><td> Atoms with model-space x coordinate less than 12.3 </td></tr>
<tr><td> y <span style="color: #999">&lt; 12.3</span> </td><td> </td><td> Atoms with model-space y coordinate less than 12.3 </td></tr>
<tr><td> z <span style="color: #999">&gt; 12.3</span> </td><td> </td><td> Atoms with model-space z coordinate greater than 12.3 </td></tr>
<tr><td colspan="3" style="font-weight:bold; background-color:#CCCCCC;" > Atom Typing </td></tr>
<tr><td> text_type <span style="color: #999">TT</span> </td><td> tt. </td><td> <em>Auto-assigned in <a href="https://pymol.org/d/media:atomtyping">Incentive PyMOL 1.4-1.8</a>)</em> </td></tr>
<tr><td> numeric_type <span style="color: #999">123</span> </td><td> nt. </td><td>                                                                                                                                            </td></tr>
</tbody></table>
<a class="header" href="append01/selealgebra.html#距離演算子の比較" id="距離演算子の比較"><h3 id="距離演算子の比較"><a class="header" href="#距離演算子の比較">距離演算子の比較</a></h3></a>
<p>2原子の距離を基準に選択する上で類似した演算子がいくつかあります。以下の表ではどのように異なるかを詳しく示します。</p>
<p><strong>文法 1</strong>: <em>s1</em> operator X of <em>s2</em>
<strong>文法 2</strong>: <em>s1</em> and (<em>s2</em> operator X)</p>
<table><thead><tr><th> 距離演算子 </th><th> 距離がX以上か以下か </th><th> どこから測定するか </th><th> s2を含むか   </th><th> 文法 </th><th> 備考                    </th></tr></thead><tbody>
<tr><td> <code>near_to</code> </td><td> ≤ X             </td><td> center        </td><td> 含まない       </td><td> 1      </td><td> <code>around</code>と等価   </td></tr>
<tr><td> <code>within</code>   </td><td> ≤ X             </td><td> center        </td><td> s1に該当する場合 </td><td> 1      </td><td>                          </td></tr>
<tr><td> <code>beyond</code>   </td><td> &gt; X            </td><td> center        </td><td> 含まない       </td><td> 1      </td><td>                          </td></tr>
<tr><td> <code>gap</code>      </td><td> &gt; X            </td><td> center+vdw    </td><td> 含まない       </td><td> 2      </td><td>                          </td></tr>
<tr><td> <code>around</code>   </td><td> ≤ X             </td><td> center        </td><td> 含まない      </td><td> 2      </td><td> <code>near_to</code>と等価 </td></tr>
<tr><td> <code>expand</code>   </td><td> ≤ X             </td><td> center        </td><td> 常に含む      </td><td> 2      </td><td>                          </td></tr>
</tbody></table>
<h3 id="入力について"><a class="header" href="#入力について">入力について</a></h3>
<ul>
<li>名前とキーワードは <code>ignore_case</code> が設定されていない限り大文字小文字を区別しない。</li>
<li>名前とキーワードは、曖昧でない接頭辞に省略することが可能。</li>
</ul>
<p><strong>おすすめ設定</strong>： <strong>大文字小文字を区別</strong>して、<strong>省略されていない選択式</strong>で書きます。そうすることで、実行時の設定や将来の言語の変更 (新しいキーワードの追加など) に対して記述が堅牢になります。</p>
<h3 id="実用例"><a class="header" href="#実用例">実用例</a></h3>
<p>Logicalな選択範囲は組み合わせることができます。例えば以下のようにしてチェインAの一部であり、残基番号125ではない原子を選択することができます。</p>
<pre><code class="language-python"># チェインAの一部であり、残基番号125ではない原子を選択。
select chain A and (not resi 125)
</code></pre>
<p>以下に様々な選択範囲の結合例を示します。</p>
<pre><code class="language-python"># 以下の2つの選択は等価です。
# チェインAにあるCβ、Cγ1、Cγ2原子を選択
select (name CB or name CG1 or name CG2) and chain A
select name CB+CG1+CG2 and chain A

# 5 Å以内の全ての残基、または有機低分子を選択。
select br. all within 5 of organic

# ヘリックス構造部分を選択
select ss 'H'

# lineで表示されているものを選択
select rep lines

# 水の3Å以内で、B因子が20以下の残基をすべて選択。
select br. b&lt;20 &amp; (all within 3 of resn HOH)

# すべての青色になっているものを選択
select color blue

# 最初のArg残基を選択
select first resn ARG

# 1fooのセグメントGのチェインXの残基444のCα炭素を選択
select 1foo/G/X/444/CA
# 上に同じ
select 1foo and segi G and c. X and i. 444 and n. CA

# 残基番号23にCα炭素が存在するオブジェクトをまるごと選択
select bo. i. 23 and n. CA

# チェインCが存在している分子を選択
select bm. c. C
</code></pre>
<p>算術演算の群の結果と同様に、論理演算の群はどの演算が最初に実行されるかによって異なります。ユーザーの想定している順序で操作が実行されるようにするには、括弧を使用します。</p>
<pre><code class="language-python">byres ((chain A or (chain B and (not resi 125))) around 5)
</code></pre>
<p>PyMOL は、論理的な選択範囲を一番内側の括弧から外に展開します。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
